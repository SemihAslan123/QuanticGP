{"ast":null,"code":"import _toConsumableArray from \"/home/esteban/2emeAnnee/S3/devWeb/QuanticGP10/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/home/esteban/2emeAnnee/S3/devWeb/QuanticGP10/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createClass from \"/home/esteban/2emeAnnee/S3/devWeb/QuanticGP10/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/home/esteban/2emeAnnee/S3/devWeb/QuanticGP10/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.find.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.find.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/esnext.iterator.some.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.timers.js\";\nimport { LeafBlot, Scope } from 'parchment';\nimport { cloneDeep, isEqual } from 'lodash-es';\nimport Emitter from './emitter.js';\nimport logger from './logger.js';\nvar debug = logger('quill:selection');\nexport var Range = /*#__PURE__*/_createClass(function Range(index) {\n  _classCallCheck(this, Range);\n  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  this.index = index;\n  this.length = length;\n});\nvar Selection = /*#__PURE__*/function () {\n  function Selection(scroll, emitter) {\n    var _this = this;\n    _classCallCheck(this, Selection);\n    this.emitter = emitter;\n    this.scroll = scroll;\n    this.composing = false;\n    this.mouseDown = false;\n    this.root = this.scroll.domNode;\n    // @ts-expect-error\n    this.cursor = this.scroll.create('cursor', this);\n    // savedRange is last non-null range\n    this.savedRange = new Range(0, 0);\n    this.lastRange = this.savedRange;\n    this.lastNative = null;\n    this.handleComposition();\n    this.handleDragging();\n    this.emitter.listenDOM('selectionchange', document, function () {\n      if (!_this.mouseDown && !_this.composing) {\n        setTimeout(_this.update.bind(_this, Emitter.sources.USER), 1);\n      }\n    });\n    this.emitter.on(Emitter.events.SCROLL_BEFORE_UPDATE, function () {\n      if (!_this.hasFocus()) return;\n      var _native = _this.getNativeRange();\n      if (_native == null) return;\n      if (_native.start.node === _this.cursor.textNode) return; // cursor.restore() will handle\n      _this.emitter.once(Emitter.events.SCROLL_UPDATE, function (source, mutations) {\n        try {\n          if (_this.root.contains(_native.start.node) && _this.root.contains(_native.end.node)) {\n            _this.setNativeRange(_native.start.node, _native.start.offset, _native.end.node, _native.end.offset);\n          }\n          var triggeredByTyping = mutations.some(function (mutation) {\n            return mutation.type === 'characterData' || mutation.type === 'childList' || mutation.type === 'attributes' && mutation.target === _this.root;\n          });\n          _this.update(triggeredByTyping ? Emitter.sources.SILENT : source);\n        } catch (ignored) {\n          // ignore\n        }\n      });\n    });\n    this.emitter.on(Emitter.events.SCROLL_OPTIMIZE, function (mutations, context) {\n      if (context.range) {\n        var _context$range = context.range,\n          startNode = _context$range.startNode,\n          startOffset = _context$range.startOffset,\n          endNode = _context$range.endNode,\n          endOffset = _context$range.endOffset;\n        _this.setNativeRange(startNode, startOffset, endNode, endOffset);\n        _this.update(Emitter.sources.SILENT);\n      }\n    });\n    this.update(Emitter.sources.SILENT);\n  }\n  return _createClass(Selection, [{\n    key: \"handleComposition\",\n    value: function handleComposition() {\n      var _this2 = this;\n      this.emitter.on(Emitter.events.COMPOSITION_BEFORE_START, function () {\n        _this2.composing = true;\n      });\n      this.emitter.on(Emitter.events.COMPOSITION_END, function () {\n        _this2.composing = false;\n        if (_this2.cursor.parent) {\n          var range = _this2.cursor.restore();\n          if (!range) return;\n          setTimeout(function () {\n            _this2.setNativeRange(range.startNode, range.startOffset, range.endNode, range.endOffset);\n          }, 1);\n        }\n      });\n    }\n  }, {\n    key: \"handleDragging\",\n    value: function handleDragging() {\n      var _this3 = this;\n      this.emitter.listenDOM('mousedown', document.body, function () {\n        _this3.mouseDown = true;\n      });\n      this.emitter.listenDOM('mouseup', document.body, function () {\n        _this3.mouseDown = false;\n        _this3.update(Emitter.sources.USER);\n      });\n    }\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      if (this.hasFocus()) return;\n      this.root.focus({\n        preventScroll: true\n      });\n      this.setRange(this.savedRange);\n    }\n  }, {\n    key: \"format\",\n    value: function format(_format, value) {\n      this.scroll.update();\n      var nativeRange = this.getNativeRange();\n      if (nativeRange == null || !nativeRange[\"native\"].collapsed || this.scroll.query(_format, Scope.BLOCK)) return;\n      if (nativeRange.start.node !== this.cursor.textNode) {\n        var blot = this.scroll.find(nativeRange.start.node, false);\n        if (blot == null) return;\n        // TODO Give blot ability to not split\n        if (blot instanceof LeafBlot) {\n          var after = blot.split(nativeRange.start.offset);\n          blot.parent.insertBefore(this.cursor, after);\n        } else {\n          // @ts-expect-error TODO: nativeRange.start.node doesn't seem to match function signature\n          blot.insertBefore(this.cursor, nativeRange.start.node); // Should never happen\n        }\n        this.cursor.attach();\n      }\n      this.cursor.format(_format, value);\n      this.scroll.optimize();\n      this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length);\n      this.update();\n    }\n  }, {\n    key: \"getBounds\",\n    value: function getBounds(index) {\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var scrollLength = this.scroll.length();\n      index = Math.min(index, scrollLength - 1);\n      length = Math.min(index + length, scrollLength - 1) - index;\n      var node;\n      var _this$scroll$leaf = this.scroll.leaf(index),\n        _this$scroll$leaf2 = _slicedToArray(_this$scroll$leaf, 2),\n        leaf = _this$scroll$leaf2[0],\n        offset = _this$scroll$leaf2[1];\n      if (leaf == null) return null;\n      if (length > 0 && offset === leaf.length()) {\n        var _this$scroll$leaf3 = this.scroll.leaf(index + 1),\n          _this$scroll$leaf4 = _slicedToArray(_this$scroll$leaf3, 1),\n          next = _this$scroll$leaf4[0];\n        if (next) {\n          var _this$scroll$line = this.scroll.line(index),\n            _this$scroll$line2 = _slicedToArray(_this$scroll$line, 1),\n            line = _this$scroll$line2[0];\n          var _this$scroll$line3 = this.scroll.line(index + 1),\n            _this$scroll$line4 = _slicedToArray(_this$scroll$line3, 1),\n            nextLine = _this$scroll$line4[0];\n          if (line === nextLine) {\n            leaf = next;\n            offset = 0;\n          }\n        }\n      }\n      var _leaf$position = leaf.position(offset, true);\n      var _leaf$position2 = _slicedToArray(_leaf$position, 2);\n      node = _leaf$position2[0];\n      offset = _leaf$position2[1];\n      var range = document.createRange();\n      if (length > 0) {\n        range.setStart(node, offset);\n        var _this$scroll$leaf5 = this.scroll.leaf(index + length);\n        var _this$scroll$leaf6 = _slicedToArray(_this$scroll$leaf5, 2);\n        leaf = _this$scroll$leaf6[0];\n        offset = _this$scroll$leaf6[1];\n        if (leaf == null) return null;\n        var _leaf$position3 = leaf.position(offset, true);\n        var _leaf$position4 = _slicedToArray(_leaf$position3, 2);\n        node = _leaf$position4[0];\n        offset = _leaf$position4[1];\n        range.setEnd(node, offset);\n        return range.getBoundingClientRect();\n      }\n      var side = 'left';\n      var rect;\n      if (node instanceof Text) {\n        // Return null if the text node is empty because it is\n        // not able to get a useful client rect:\n        // https://github.com/w3c/csswg-drafts/issues/2514.\n        // Empty text nodes are most likely caused by TextBlot#optimize()\n        // not getting called when editor content changes.\n        if (!node.data.length) {\n          return null;\n        }\n        if (offset < node.data.length) {\n          range.setStart(node, offset);\n          range.setEnd(node, offset + 1);\n        } else {\n          range.setStart(node, offset - 1);\n          range.setEnd(node, offset);\n          side = 'right';\n        }\n        rect = range.getBoundingClientRect();\n      } else {\n        if (!(leaf.domNode instanceof Element)) return null;\n        rect = leaf.domNode.getBoundingClientRect();\n        if (offset > 0) side = 'right';\n      }\n      return {\n        bottom: rect.top + rect.height,\n        height: rect.height,\n        left: rect[side],\n        right: rect[side],\n        top: rect.top,\n        width: 0\n      };\n    }\n  }, {\n    key: \"getNativeRange\",\n    value: function getNativeRange() {\n      var selection = document.getSelection();\n      if (selection == null || selection.rangeCount <= 0) return null;\n      var nativeRange = selection.getRangeAt(0);\n      if (nativeRange == null) return null;\n      var range = this.normalizeNative(nativeRange);\n      debug.info('getNativeRange', range);\n      return range;\n    }\n  }, {\n    key: \"getRange\",\n    value: function getRange() {\n      var root = this.scroll.domNode;\n      if ('isConnected' in root && !root.isConnected) {\n        // document.getSelection() forces layout on Blink, so we trend to\n        // not calling it.\n        return [null, null];\n      }\n      var normalized = this.getNativeRange();\n      if (normalized == null) return [null, null];\n      var range = this.normalizedToRange(normalized);\n      return [range, normalized];\n    }\n  }, {\n    key: \"hasFocus\",\n    value: function hasFocus() {\n      return document.activeElement === this.root || document.activeElement != null && contains(this.root, document.activeElement);\n    }\n  }, {\n    key: \"normalizedToRange\",\n    value: function normalizedToRange(range) {\n      var _this4 = this;\n      var positions = [[range.start.node, range.start.offset]];\n      if (!range[\"native\"].collapsed) {\n        positions.push([range.end.node, range.end.offset]);\n      }\n      var indexes = positions.map(function (position) {\n        var _position = _slicedToArray(position, 2),\n          node = _position[0],\n          offset = _position[1];\n        var blot = _this4.scroll.find(node, true);\n        // @ts-expect-error Fix me later\n        var index = blot.offset(_this4.scroll);\n        if (offset === 0) {\n          return index;\n        }\n        if (blot instanceof LeafBlot) {\n          return index + blot.index(node, offset);\n        }\n        // @ts-expect-error Fix me later\n        return index + blot.length();\n      });\n      var end = Math.min(Math.max.apply(Math, _toConsumableArray(indexes)), this.scroll.length() - 1);\n      var start = Math.min.apply(Math, [end].concat(_toConsumableArray(indexes)));\n      return new Range(start, end - start);\n    }\n  }, {\n    key: \"normalizeNative\",\n    value: function normalizeNative(nativeRange) {\n      if (!contains(this.root, nativeRange.startContainer) || !nativeRange.collapsed && !contains(this.root, nativeRange.endContainer)) {\n        return null;\n      }\n      var range = {\n        start: {\n          node: nativeRange.startContainer,\n          offset: nativeRange.startOffset\n        },\n        end: {\n          node: nativeRange.endContainer,\n          offset: nativeRange.endOffset\n        },\n        \"native\": nativeRange\n      };\n      [range.start, range.end].forEach(function (position) {\n        var node = position.node,\n          offset = position.offset;\n        while (!(node instanceof Text) && node.childNodes.length > 0) {\n          if (node.childNodes.length > offset) {\n            node = node.childNodes[offset];\n            offset = 0;\n          } else if (node.childNodes.length === offset) {\n            // @ts-expect-error Fix me later\n            node = node.lastChild;\n            if (node instanceof Text) {\n              offset = node.data.length;\n            } else if (node.childNodes.length > 0) {\n              // Container case\n              offset = node.childNodes.length;\n            } else {\n              // Embed case\n              offset = node.childNodes.length + 1;\n            }\n          } else {\n            break;\n          }\n        }\n        position.node = node;\n        position.offset = offset;\n      });\n      return range;\n    }\n  }, {\n    key: \"rangeToNative\",\n    value: function rangeToNative(range) {\n      var _this5 = this;\n      var scrollLength = this.scroll.length();\n      var getPosition = function getPosition(index, inclusive) {\n        index = Math.min(scrollLength - 1, index);\n        var _this5$scroll$leaf = _this5.scroll.leaf(index),\n          _this5$scroll$leaf2 = _slicedToArray(_this5$scroll$leaf, 2),\n          leaf = _this5$scroll$leaf2[0],\n          leafOffset = _this5$scroll$leaf2[1];\n        return leaf ? leaf.position(leafOffset, inclusive) : [null, -1];\n      };\n      return [].concat(_toConsumableArray(getPosition(range.index, false)), _toConsumableArray(getPosition(range.index + range.length, true)));\n    }\n  }, {\n    key: \"setNativeRange\",\n    value: function setNativeRange(startNode, startOffset) {\n      var endNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : startNode;\n      var endOffset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : startOffset;\n      var force = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      debug.info('setNativeRange', startNode, startOffset, endNode, endOffset);\n      if (startNode != null && (this.root.parentNode == null || startNode.parentNode == null ||\n      // @ts-expect-error Fix me later\n      endNode.parentNode == null)) {\n        return;\n      }\n      var selection = document.getSelection();\n      if (selection == null) return;\n      if (startNode != null) {\n        if (!this.hasFocus()) this.root.focus({\n          preventScroll: true\n        });\n        var _ref = this.getNativeRange() || {},\n          _native2 = _ref[\"native\"];\n        if (_native2 == null || force || startNode !== _native2.startContainer || startOffset !== _native2.startOffset || endNode !== _native2.endContainer || endOffset !== _native2.endOffset) {\n          if (startNode instanceof Element && startNode.tagName === 'BR') {\n            // @ts-expect-error Fix me later\n            startOffset = Array.from(startNode.parentNode.childNodes).indexOf(startNode);\n            startNode = startNode.parentNode;\n          }\n          if (endNode instanceof Element && endNode.tagName === 'BR') {\n            // @ts-expect-error Fix me later\n            endOffset = Array.from(endNode.parentNode.childNodes).indexOf(endNode);\n            endNode = endNode.parentNode;\n          }\n          var range = document.createRange();\n          // @ts-expect-error Fix me later\n          range.setStart(startNode, startOffset);\n          // @ts-expect-error Fix me later\n          range.setEnd(endNode, endOffset);\n          selection.removeAllRanges();\n          selection.addRange(range);\n        }\n      } else {\n        selection.removeAllRanges();\n        this.root.blur();\n      }\n    }\n  }, {\n    key: \"setRange\",\n    value: function setRange(range) {\n      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Emitter.sources.API;\n      if (typeof force === 'string') {\n        source = force;\n        force = false;\n      }\n      debug.info('setRange', range);\n      if (range != null) {\n        var args = this.rangeToNative(range);\n        this.setNativeRange.apply(this, _toConsumableArray(args).concat([force]));\n      } else {\n        this.setNativeRange(null);\n      }\n      this.update(source);\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Emitter.sources.USER;\n      var oldRange = this.lastRange;\n      var _this$getRange = this.getRange(),\n        _this$getRange2 = _slicedToArray(_this$getRange, 2),\n        lastRange = _this$getRange2[0],\n        nativeRange = _this$getRange2[1];\n      this.lastRange = lastRange;\n      this.lastNative = nativeRange;\n      if (this.lastRange != null) {\n        this.savedRange = this.lastRange;\n      }\n      if (!isEqual(oldRange, this.lastRange)) {\n        var _this$emitter;\n        if (!this.composing && nativeRange != null && nativeRange[\"native\"].collapsed && nativeRange.start.node !== this.cursor.textNode) {\n          var range = this.cursor.restore();\n          if (range) {\n            this.setNativeRange(range.startNode, range.startOffset, range.endNode, range.endOffset);\n          }\n        }\n        var args = [Emitter.events.SELECTION_CHANGE, cloneDeep(this.lastRange), cloneDeep(oldRange), source];\n        (_this$emitter = this.emitter).emit.apply(_this$emitter, [Emitter.events.EDITOR_CHANGE].concat(args));\n        if (source !== Emitter.sources.SILENT) {\n          var _this$emitter2;\n          (_this$emitter2 = this.emitter).emit.apply(_this$emitter2, args);\n        }\n      }\n    }\n  }]);\n}();\nfunction contains(parent, descendant) {\n  try {\n    // Firefox inserts inaccessible nodes around video elements\n    descendant.parentNode; // eslint-disable-line @typescript-eslint/no-unused-expressions\n  } catch (e) {\n    return false;\n  }\n  return parent.contains(descendant);\n}\nexport default Selection;","map":{"version":3,"names":["LeafBlot","Scope","cloneDeep","isEqual","Emitter","logger","debug","Range","_createClass","index","_classCallCheck","length","arguments","undefined","Selection","scroll","emitter","_this","composing","mouseDown","root","domNode","cursor","create","savedRange","lastRange","lastNative","handleComposition","handleDragging","listenDOM","document","setTimeout","update","bind","sources","USER","on","events","SCROLL_BEFORE_UPDATE","hasFocus","native","getNativeRange","start","node","textNode","once","SCROLL_UPDATE","source","mutations","contains","end","setNativeRange","offset","triggeredByTyping","some","mutation","type","target","SILENT","ignored","SCROLL_OPTIMIZE","context","range","_context$range","startNode","startOffset","endNode","endOffset","key","value","_this2","COMPOSITION_BEFORE_START","COMPOSITION_END","parent","restore","_this3","body","focus","preventScroll","setRange","format","nativeRange","collapsed","query","BLOCK","blot","find","after","split","insertBefore","attach","optimize","data","getBounds","scrollLength","Math","min","_this$scroll$leaf","leaf","_this$scroll$leaf2","_slicedToArray","_this$scroll$leaf3","_this$scroll$leaf4","next","_this$scroll$line","line","_this$scroll$line2","_this$scroll$line3","_this$scroll$line4","nextLine","_leaf$position","position","_leaf$position2","createRange","setStart","_this$scroll$leaf5","_this$scroll$leaf6","_leaf$position3","_leaf$position4","setEnd","getBoundingClientRect","side","rect","Text","Element","bottom","top","height","left","right","width","selection","getSelection","rangeCount","getRangeAt","normalizeNative","info","getRange","isConnected","normalized","normalizedToRange","activeElement","_this4","positions","push","indexes","map","_position","max","apply","_toConsumableArray","concat","startContainer","endContainer","forEach","childNodes","lastChild","rangeToNative","_this5","getPosition","inclusive","_this5$scroll$leaf","_this5$scroll$leaf2","leafOffset","force","parentNode","_ref","tagName","Array","from","indexOf","removeAllRanges","addRange","blur","API","args","oldRange","_this$getRange","_this$getRange2","_this$emitter","SELECTION_CHANGE","emit","EDITOR_CHANGE","_this$emitter2","descendant","e"],"sources":["../../src/core/selection.ts"],"sourcesContent":["import { LeafBlot, Scope } from 'parchment';\nimport { cloneDeep, isEqual } from 'lodash-es';\nimport Emitter from './emitter.js';\nimport type { EmitterSource } from './emitter.js';\nimport logger from './logger.js';\nimport type Cursor from '../blots/cursor.js';\nimport type Scroll from '../blots/scroll.js';\n\nconst debug = logger('quill:selection');\n\ntype NativeRange = AbstractRange;\n\ninterface NormalizedRange {\n  start: {\n    node: NativeRange['startContainer'];\n    offset: NativeRange['startOffset'];\n  };\n  end: { node: NativeRange['endContainer']; offset: NativeRange['endOffset'] };\n  native: NativeRange;\n}\n\nexport interface Bounds {\n  bottom: number;\n  height: number;\n  left: number;\n  right: number;\n  top: number;\n  width: number;\n}\n\nexport class Range {\n  constructor(\n    public index: number,\n    public length = 0,\n  ) {}\n}\n\nclass Selection {\n  scroll: Scroll;\n  emitter: Emitter;\n  composing: boolean;\n  mouseDown: boolean;\n\n  root: HTMLElement;\n  cursor: Cursor;\n  savedRange: Range;\n  lastRange: Range | null;\n  lastNative: NormalizedRange | null;\n\n  constructor(scroll: Scroll, emitter: Emitter) {\n    this.emitter = emitter;\n    this.scroll = scroll;\n    this.composing = false;\n    this.mouseDown = false;\n    this.root = this.scroll.domNode;\n    // @ts-expect-error\n    this.cursor = this.scroll.create('cursor', this);\n    // savedRange is last non-null range\n    this.savedRange = new Range(0, 0);\n    this.lastRange = this.savedRange;\n    this.lastNative = null;\n    this.handleComposition();\n    this.handleDragging();\n    this.emitter.listenDOM('selectionchange', document, () => {\n      if (!this.mouseDown && !this.composing) {\n        setTimeout(this.update.bind(this, Emitter.sources.USER), 1);\n      }\n    });\n    this.emitter.on(Emitter.events.SCROLL_BEFORE_UPDATE, () => {\n      if (!this.hasFocus()) return;\n      const native = this.getNativeRange();\n      if (native == null) return;\n      if (native.start.node === this.cursor.textNode) return; // cursor.restore() will handle\n      this.emitter.once(\n        Emitter.events.SCROLL_UPDATE,\n        (source, mutations: MutationRecord[]) => {\n          try {\n            if (\n              this.root.contains(native.start.node) &&\n              this.root.contains(native.end.node)\n            ) {\n              this.setNativeRange(\n                native.start.node,\n                native.start.offset,\n                native.end.node,\n                native.end.offset,\n              );\n            }\n            const triggeredByTyping = mutations.some(\n              (mutation) =>\n                mutation.type === 'characterData' ||\n                mutation.type === 'childList' ||\n                (mutation.type === 'attributes' &&\n                  mutation.target === this.root),\n            );\n            this.update(triggeredByTyping ? Emitter.sources.SILENT : source);\n          } catch (ignored) {\n            // ignore\n          }\n        },\n      );\n    });\n    this.emitter.on(Emitter.events.SCROLL_OPTIMIZE, (mutations, context) => {\n      if (context.range) {\n        const { startNode, startOffset, endNode, endOffset } = context.range;\n        this.setNativeRange(startNode, startOffset, endNode, endOffset);\n        this.update(Emitter.sources.SILENT);\n      }\n    });\n    this.update(Emitter.sources.SILENT);\n  }\n\n  handleComposition() {\n    this.emitter.on(Emitter.events.COMPOSITION_BEFORE_START, () => {\n      this.composing = true;\n    });\n    this.emitter.on(Emitter.events.COMPOSITION_END, () => {\n      this.composing = false;\n      if (this.cursor.parent) {\n        const range = this.cursor.restore();\n        if (!range) return;\n        setTimeout(() => {\n          this.setNativeRange(\n            range.startNode,\n            range.startOffset,\n            range.endNode,\n            range.endOffset,\n          );\n        }, 1);\n      }\n    });\n  }\n\n  handleDragging() {\n    this.emitter.listenDOM('mousedown', document.body, () => {\n      this.mouseDown = true;\n    });\n    this.emitter.listenDOM('mouseup', document.body, () => {\n      this.mouseDown = false;\n      this.update(Emitter.sources.USER);\n    });\n  }\n\n  focus() {\n    if (this.hasFocus()) return;\n    this.root.focus({ preventScroll: true });\n    this.setRange(this.savedRange);\n  }\n\n  format(format: string, value: unknown) {\n    this.scroll.update();\n    const nativeRange = this.getNativeRange();\n    if (\n      nativeRange == null ||\n      !nativeRange.native.collapsed ||\n      this.scroll.query(format, Scope.BLOCK)\n    )\n      return;\n    if (nativeRange.start.node !== this.cursor.textNode) {\n      const blot = this.scroll.find(nativeRange.start.node, false);\n      if (blot == null) return;\n      // TODO Give blot ability to not split\n      if (blot instanceof LeafBlot) {\n        const after = blot.split(nativeRange.start.offset);\n        blot.parent.insertBefore(this.cursor, after);\n      } else {\n        // @ts-expect-error TODO: nativeRange.start.node doesn't seem to match function signature\n        blot.insertBefore(this.cursor, nativeRange.start.node); // Should never happen\n      }\n      this.cursor.attach();\n    }\n    this.cursor.format(format, value);\n    this.scroll.optimize();\n    this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length);\n    this.update();\n  }\n\n  getBounds(index: number, length = 0) {\n    const scrollLength = this.scroll.length();\n    index = Math.min(index, scrollLength - 1);\n    length = Math.min(index + length, scrollLength - 1) - index;\n    let node: Node;\n    let [leaf, offset] = this.scroll.leaf(index);\n    if (leaf == null) return null;\n    if (length > 0 && offset === leaf.length()) {\n      const [next] = this.scroll.leaf(index + 1);\n      if (next) {\n        const [line] = this.scroll.line(index);\n        const [nextLine] = this.scroll.line(index + 1);\n        if (line === nextLine) {\n          leaf = next;\n          offset = 0;\n        }\n      }\n    }\n    [node, offset] = leaf.position(offset, true);\n    const range = document.createRange();\n    if (length > 0) {\n      range.setStart(node, offset);\n      [leaf, offset] = this.scroll.leaf(index + length);\n      if (leaf == null) return null;\n      [node, offset] = leaf.position(offset, true);\n      range.setEnd(node, offset);\n      return range.getBoundingClientRect();\n    }\n    let side: 'left' | 'right' = 'left';\n    let rect: DOMRect;\n    if (node instanceof Text) {\n      // Return null if the text node is empty because it is\n      // not able to get a useful client rect:\n      // https://github.com/w3c/csswg-drafts/issues/2514.\n      // Empty text nodes are most likely caused by TextBlot#optimize()\n      // not getting called when editor content changes.\n      if (!node.data.length) {\n        return null;\n      }\n      if (offset < node.data.length) {\n        range.setStart(node, offset);\n        range.setEnd(node, offset + 1);\n      } else {\n        range.setStart(node, offset - 1);\n        range.setEnd(node, offset);\n        side = 'right';\n      }\n      rect = range.getBoundingClientRect();\n    } else {\n      if (!(leaf.domNode instanceof Element)) return null;\n      rect = leaf.domNode.getBoundingClientRect();\n      if (offset > 0) side = 'right';\n    }\n    return {\n      bottom: rect.top + rect.height,\n      height: rect.height,\n      left: rect[side],\n      right: rect[side],\n      top: rect.top,\n      width: 0,\n    };\n  }\n\n  getNativeRange(): NormalizedRange | null {\n    const selection = document.getSelection();\n    if (selection == null || selection.rangeCount <= 0) return null;\n    const nativeRange = selection.getRangeAt(0);\n    if (nativeRange == null) return null;\n    const range = this.normalizeNative(nativeRange);\n    debug.info('getNativeRange', range);\n    return range;\n  }\n\n  getRange(): [Range, NormalizedRange] | [null, null] {\n    const root = this.scroll.domNode;\n    if ('isConnected' in root && !root.isConnected) {\n      // document.getSelection() forces layout on Blink, so we trend to\n      // not calling it.\n      return [null, null];\n    }\n    const normalized = this.getNativeRange();\n    if (normalized == null) return [null, null];\n    const range = this.normalizedToRange(normalized);\n    return [range, normalized];\n  }\n\n  hasFocus(): boolean {\n    return (\n      document.activeElement === this.root ||\n      (document.activeElement != null &&\n        contains(this.root, document.activeElement))\n    );\n  }\n\n  normalizedToRange(range: NormalizedRange) {\n    const positions: [Node, number][] = [\n      [range.start.node, range.start.offset],\n    ];\n    if (!range.native.collapsed) {\n      positions.push([range.end.node, range.end.offset]);\n    }\n    const indexes = positions.map((position) => {\n      const [node, offset] = position;\n      const blot = this.scroll.find(node, true);\n      // @ts-expect-error Fix me later\n      const index = blot.offset(this.scroll);\n      if (offset === 0) {\n        return index;\n      }\n      if (blot instanceof LeafBlot) {\n        return index + blot.index(node, offset);\n      }\n      // @ts-expect-error Fix me later\n      return index + blot.length();\n    });\n    const end = Math.min(Math.max(...indexes), this.scroll.length() - 1);\n    const start = Math.min(end, ...indexes);\n    return new Range(start, end - start);\n  }\n\n  normalizeNative(nativeRange: NativeRange) {\n    if (\n      !contains(this.root, nativeRange.startContainer) ||\n      (!nativeRange.collapsed && !contains(this.root, nativeRange.endContainer))\n    ) {\n      return null;\n    }\n    const range = {\n      start: {\n        node: nativeRange.startContainer,\n        offset: nativeRange.startOffset,\n      },\n      end: { node: nativeRange.endContainer, offset: nativeRange.endOffset },\n      native: nativeRange,\n    };\n    [range.start, range.end].forEach((position) => {\n      let { node, offset } = position;\n      while (!(node instanceof Text) && node.childNodes.length > 0) {\n        if (node.childNodes.length > offset) {\n          node = node.childNodes[offset];\n          offset = 0;\n        } else if (node.childNodes.length === offset) {\n          // @ts-expect-error Fix me later\n          node = node.lastChild;\n          if (node instanceof Text) {\n            offset = node.data.length;\n          } else if (node.childNodes.length > 0) {\n            // Container case\n            offset = node.childNodes.length;\n          } else {\n            // Embed case\n            offset = node.childNodes.length + 1;\n          }\n        } else {\n          break;\n        }\n      }\n      position.node = node;\n      position.offset = offset;\n    });\n    return range;\n  }\n\n  rangeToNative(range: Range): [Node | null, number, Node | null, number] {\n    const scrollLength = this.scroll.length();\n\n    const getPosition = (\n      index: number,\n      inclusive: boolean,\n    ): [Node | null, number] => {\n      index = Math.min(scrollLength - 1, index);\n      const [leaf, leafOffset] = this.scroll.leaf(index);\n      return leaf ? leaf.position(leafOffset, inclusive) : [null, -1];\n    };\n    return [\n      ...getPosition(range.index, false),\n      ...getPosition(range.index + range.length, true),\n    ];\n  }\n\n  setNativeRange(\n    startNode: Node | null,\n    startOffset?: number,\n    endNode = startNode,\n    endOffset = startOffset,\n    force = false,\n  ) {\n    debug.info('setNativeRange', startNode, startOffset, endNode, endOffset);\n    if (\n      startNode != null &&\n      (this.root.parentNode == null ||\n        startNode.parentNode == null ||\n        // @ts-expect-error Fix me later\n        endNode.parentNode == null)\n    ) {\n      return;\n    }\n    const selection = document.getSelection();\n    if (selection == null) return;\n    if (startNode != null) {\n      if (!this.hasFocus()) this.root.focus({ preventScroll: true });\n      const { native } = this.getNativeRange() || {};\n      if (\n        native == null ||\n        force ||\n        startNode !== native.startContainer ||\n        startOffset !== native.startOffset ||\n        endNode !== native.endContainer ||\n        endOffset !== native.endOffset\n      ) {\n        if (startNode instanceof Element && startNode.tagName === 'BR') {\n          // @ts-expect-error Fix me later\n          startOffset = Array.from(startNode.parentNode.childNodes).indexOf(\n            startNode,\n          );\n          startNode = startNode.parentNode;\n        }\n        if (endNode instanceof Element && endNode.tagName === 'BR') {\n          // @ts-expect-error Fix me later\n          endOffset = Array.from(endNode.parentNode.childNodes).indexOf(\n            endNode,\n          );\n          endNode = endNode.parentNode;\n        }\n        const range = document.createRange();\n        // @ts-expect-error Fix me later\n        range.setStart(startNode, startOffset);\n        // @ts-expect-error Fix me later\n        range.setEnd(endNode, endOffset);\n        selection.removeAllRanges();\n        selection.addRange(range);\n      }\n    } else {\n      selection.removeAllRanges();\n      this.root.blur();\n    }\n  }\n\n  setRange(range: Range | null, force: boolean, source?: EmitterSource): void;\n  setRange(range: Range | null, source?: EmitterSource): void;\n  setRange(\n    range: Range | null,\n    force: boolean | EmitterSource = false,\n    source: EmitterSource = Emitter.sources.API,\n  ): void {\n    if (typeof force === 'string') {\n      source = force;\n      force = false;\n    }\n    debug.info('setRange', range);\n    if (range != null) {\n      const args = this.rangeToNative(range);\n      this.setNativeRange(...args, force);\n    } else {\n      this.setNativeRange(null);\n    }\n    this.update(source);\n  }\n\n  update(source: EmitterSource = Emitter.sources.USER) {\n    const oldRange = this.lastRange;\n    const [lastRange, nativeRange] = this.getRange();\n    this.lastRange = lastRange;\n    this.lastNative = nativeRange;\n    if (this.lastRange != null) {\n      this.savedRange = this.lastRange;\n    }\n    if (!isEqual(oldRange, this.lastRange)) {\n      if (\n        !this.composing &&\n        nativeRange != null &&\n        nativeRange.native.collapsed &&\n        nativeRange.start.node !== this.cursor.textNode\n      ) {\n        const range = this.cursor.restore();\n        if (range) {\n          this.setNativeRange(\n            range.startNode,\n            range.startOffset,\n            range.endNode,\n            range.endOffset,\n          );\n        }\n      }\n      const args = [\n        Emitter.events.SELECTION_CHANGE,\n        cloneDeep(this.lastRange),\n        cloneDeep(oldRange),\n        source,\n      ];\n      this.emitter.emit(Emitter.events.EDITOR_CHANGE, ...args);\n      if (source !== Emitter.sources.SILENT) {\n        this.emitter.emit(...args);\n      }\n    }\n  }\n}\n\nfunction contains(parent: Node, descendant: Node) {\n  try {\n    // Firefox inserts inaccessible nodes around video elements\n    descendant.parentNode; // eslint-disable-line @typescript-eslint/no-unused-expressions\n  } catch (e) {\n    return false;\n  }\n  return parent.contains(descendant);\n}\n\nexport default Selection;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,QAAQ,EAAEC,KAAK,QAAQ,WAAW;AAC3C,SAASC,SAAS,EAAEC,OAAO,QAAQ,WAAW;AAC9C,OAAOC,OAAO,MAAM,cAAc;AAElC,OAAOC,MAAM,MAAM,aAAa;AAIhC,IAAMC,KAAK,GAAGD,MAAM,CAAC,iBAAiB,CAAC;AAsBvC,WAAaE,KAAK,gBAAAC,YAAA,CAChB,SAAAD,MACSE,KAAa,EAEpB;EAAAC,eAAA,OAAAH,KAAA;EAAA,IADOI,MAAM,GAAAC,SAAA,CAAAD,MAAA,QAAAC,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,CAAC;EAAA,KADVH,KAAa,GAAbA,KAAa;EAAA,KACbE,MAAM,GAANA,MAAM;AACZ;AACL,IAEMG,SAAS;EAYb,SAAAA,UAAYC,MAAc,EAAEC,OAAgB,EAAE;IAAA,IAAAC,KAAA;IAAAP,eAAA,OAAAI,SAAA;IAC5C,IAAI,CAACE,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACD,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACG,SAAS,GAAG,KAAK;IACtB,IAAI,CAACC,SAAS,GAAG,KAAK;IACtB,IAAI,CAACC,IAAI,GAAG,IAAI,CAACL,MAAM,CAACM,OAAO;IAC/B;IACA,IAAI,CAACC,MAAM,GAAG,IAAI,CAACP,MAAM,CAACQ,MAAM,CAAC,QAAQ,EAAE,IAAI,CAAC;IAChD;IACA,IAAI,CAACC,UAAU,GAAG,IAAIjB,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;IACjC,IAAI,CAACkB,SAAS,GAAG,IAAI,CAACD,UAAU;IAChC,IAAI,CAACE,UAAU,GAAG,IAAI;IACtB,IAAI,CAACC,iBAAiB,CAAC,CAAC;IACxB,IAAI,CAACC,cAAc,CAAC,CAAC;IACrB,IAAI,CAACZ,OAAO,CAACa,SAAS,CAAC,iBAAiB,EAAEC,QAAQ,EAAE,YAAM;MACxD,IAAI,CAACb,KAAI,CAACE,SAAS,IAAI,CAACF,KAAI,CAACC,SAAS,EAAE;QACtCa,UAAU,CAACd,KAAI,CAACe,MAAM,CAACC,IAAI,CAAChB,KAAI,EAAEb,OAAO,CAAC8B,OAAO,CAACC,IAAI,CAAC,EAAE,CAAC,CAAC;MAC7D;IACF,CAAC,CAAC;IACF,IAAI,CAACnB,OAAO,CAACoB,EAAE,CAAChC,OAAO,CAACiC,MAAM,CAACC,oBAAoB,EAAE,YAAM;MACzD,IAAI,CAACrB,KAAI,CAACsB,QAAQ,CAAC,CAAC,EAAE;MACtB,IAAMC,OAAM,GAAGvB,KAAI,CAACwB,cAAc,CAAC,CAAC;MACpC,IAAID,OAAM,IAAI,IAAI,EAAE;MACpB,IAAIA,OAAM,CAACE,KAAK,CAACC,IAAI,KAAK1B,KAAI,CAACK,MAAM,CAACsB,QAAQ,EAAE,OAAO,CAAC;MACxD3B,KAAI,CAACD,OAAO,CAAC6B,IAAI,CACfzC,OAAO,CAACiC,MAAM,CAACS,aAAa,EAC5B,UAACC,MAAM,EAAEC,SAA2B,EAAK;QACvC,IAAI;UACF,IACE/B,KAAI,CAACG,IAAI,CAAC6B,QAAQ,CAACT,OAAM,CAACE,KAAK,CAACC,IAAI,CAAC,IACrC1B,KAAI,CAACG,IAAI,CAAC6B,QAAQ,CAACT,OAAM,CAACU,GAAG,CAACP,IAAI,CAAC,EACnC;YACA1B,KAAI,CAACkC,cAAc,CACjBX,OAAM,CAACE,KAAK,CAACC,IAAI,EACjBH,OAAM,CAACE,KAAK,CAACU,MAAM,EACnBZ,OAAM,CAACU,GAAG,CAACP,IAAI,EACfH,OAAM,CAACU,GAAG,CAACE,MACb,CAAC;UACH;UACA,IAAMC,iBAAiB,GAAGL,SAAS,CAACM,IAAI,CACrC,UAAAC,QAAQ;YAAA,OACPA,QAAQ,CAACC,IAAI,KAAK,eAAe,IACjCD,QAAQ,CAACC,IAAI,KAAK,WAAW,IAC5BD,QAAQ,CAACC,IAAI,KAAK,YAAY,IAC7BD,QAAQ,CAACE,MAAM,KAAKxC,KAAI,CAACG,IAC/B;UAAA,EAAC;UACDH,KAAI,CAACe,MAAM,CAACqB,iBAAiB,GAAGjD,OAAO,CAAC8B,OAAO,CAACwB,MAAM,GAAGX,MAAM,CAAC;QAClE,CAAC,CAAC,OAAOY,OAAO,EAAE;UAChB;QAAA;MAEJ,CACF,CAAC;IACH,CAAC,CAAC;IACF,IAAI,CAAC3C,OAAO,CAACoB,EAAE,CAAChC,OAAO,CAACiC,MAAM,CAACuB,eAAe,EAAE,UAACZ,SAAS,EAAEa,OAAO,EAAK;MACtE,IAAIA,OAAO,CAACC,KAAK,EAAE;QACjB,IAAAC,cAAA,GAAuDF,OAAO,CAACC,KAAK;UAA5DE,SAAS,GAAAD,cAAA,CAATC,SAAS;UAAEC,WAAW,GAAAF,cAAA,CAAXE,WAAW;UAAEC,OAAO,GAAAH,cAAA,CAAPG,OAAO;UAAEC,SAAA,GAAAJ,cAAA,CAAAI,SAAA;QACzClD,KAAI,CAACkC,cAAc,CAACa,SAAS,EAAEC,WAAW,EAAEC,OAAO,EAAEC,SAAS,CAAC;QAC/DlD,KAAI,CAACe,MAAM,CAAC5B,OAAO,CAAC8B,OAAO,CAACwB,MAAM,CAAC;MACrC;IACF,CAAC,CAAC;IACF,IAAI,CAAC1B,MAAM,CAAC5B,OAAO,CAAC8B,OAAO,CAACwB,MAAM,CAAC;EACrC;EAAA,OAAAlD,YAAA,CAAAM,SAAA;IAAAsD,GAAA;IAAAC,KAAA,EAEA,SAAA1C,iBAAiBA,CAAA,EAAG;MAAA,IAAA2C,MAAA;MAClB,IAAI,CAACtD,OAAO,CAACoB,EAAE,CAAChC,OAAO,CAACiC,MAAM,CAACkC,wBAAwB,EAAE,YAAM;QAC7DD,MAAI,CAACpD,SAAS,GAAG,IAAI;MACvB,CAAC,CAAC;MACF,IAAI,CAACF,OAAO,CAACoB,EAAE,CAAChC,OAAO,CAACiC,MAAM,CAACmC,eAAe,EAAE,YAAM;QACpDF,MAAI,CAACpD,SAAS,GAAG,KAAK;QACtB,IAAIoD,MAAI,CAAChD,MAAM,CAACmD,MAAM,EAAE;UACtB,IAAMX,KAAK,GAAGQ,MAAI,CAAChD,MAAM,CAACoD,OAAO,CAAC,CAAC;UACnC,IAAI,CAACZ,KAAK,EAAE;UACZ/B,UAAU,CAAC,YAAM;YACfuC,MAAI,CAACnB,cAAc,CACjBW,KAAK,CAACE,SAAS,EACfF,KAAK,CAACG,WAAW,EACjBH,KAAK,CAACI,OAAO,EACbJ,KAAK,CAACK,SACR,CAAC;UACH,CAAC,EAAE,CAAC,CAAC;QACP;MACF,CAAC,CAAC;IACJ;EAAA;IAAAC,GAAA;IAAAC,KAAA,EAEA,SAAAzC,cAAcA,CAAA,EAAG;MAAA,IAAA+C,MAAA;MACf,IAAI,CAAC3D,OAAO,CAACa,SAAS,CAAC,WAAW,EAAEC,QAAQ,CAAC8C,IAAI,EAAE,YAAM;QACvDD,MAAI,CAACxD,SAAS,GAAG,IAAI;MACvB,CAAC,CAAC;MACF,IAAI,CAACH,OAAO,CAACa,SAAS,CAAC,SAAS,EAAEC,QAAQ,CAAC8C,IAAI,EAAE,YAAM;QACrDD,MAAI,CAACxD,SAAS,GAAG,KAAK;QACtBwD,MAAI,CAAC3C,MAAM,CAAC5B,OAAO,CAAC8B,OAAO,CAACC,IAAI,CAAC;MACnC,CAAC,CAAC;IACJ;EAAA;IAAAiC,GAAA;IAAAC,KAAA,EAEA,SAAAQ,KAAKA,CAAA,EAAG;MACN,IAAI,IAAI,CAACtC,QAAQ,CAAC,CAAC,EAAE;MACrB,IAAI,CAACnB,IAAI,CAACyD,KAAK,CAAC;QAAEC,aAAa,EAAE;MAAK,CAAC,CAAC;MACxC,IAAI,CAACC,QAAQ,CAAC,IAAI,CAACvD,UAAU,CAAC;IAChC;EAAA;IAAA4C,GAAA;IAAAC,KAAA,EAEA,SAAAW,MAAMA,CAACA,OAAc,EAAEX,KAAc,EAAE;MACrC,IAAI,CAACtD,MAAM,CAACiB,MAAM,CAAC,CAAC;MACpB,IAAMiD,WAAW,GAAG,IAAI,CAACxC,cAAc,CAAC,CAAC;MACzC,IACEwC,WAAW,IAAI,IAAI,IACnB,CAACA,WAAW,UAAO,CAACC,SAAS,IAC7B,IAAI,CAACnE,MAAM,CAACoE,KAAK,CAACH,OAAM,EAAE/E,KAAK,CAACmF,KAAK,CAAC,EAEtC;MACF,IAAIH,WAAW,CAACvC,KAAK,CAACC,IAAI,KAAK,IAAI,CAACrB,MAAM,CAACsB,QAAQ,EAAE;QACnD,IAAMyC,IAAI,GAAG,IAAI,CAACtE,MAAM,CAACuE,IAAI,CAACL,WAAW,CAACvC,KAAK,CAACC,IAAI,EAAE,KAAK,CAAC;QAC5D,IAAI0C,IAAI,IAAI,IAAI,EAAE;QAClB;QACA,IAAIA,IAAI,YAAYrF,QAAQ,EAAE;UAC5B,IAAMuF,KAAK,GAAGF,IAAI,CAACG,KAAK,CAACP,WAAW,CAACvC,KAAK,CAACU,MAAM,CAAC;UAClDiC,IAAI,CAACZ,MAAM,CAACgB,YAAY,CAAC,IAAI,CAACnE,MAAM,EAAEiE,KAAK,CAAC;QAC9C,CAAC,MAAM;UACL;UACAF,IAAI,CAACI,YAAY,CAAC,IAAI,CAACnE,MAAM,EAAE2D,WAAW,CAACvC,KAAK,CAACC,IAAI,CAAC,CAAC,CAAC;QAC1D;QACA,IAAI,CAACrB,MAAM,CAACoE,MAAM,CAAC,CAAC;MACtB;MACA,IAAI,CAACpE,MAAM,CAAC0D,MAAM,CAACA,OAAM,EAAEX,KAAK,CAAC;MACjC,IAAI,CAACtD,MAAM,CAAC4E,QAAQ,CAAC,CAAC;MACtB,IAAI,CAACxC,cAAc,CAAC,IAAI,CAAC7B,MAAM,CAACsB,QAAQ,EAAE,IAAI,CAACtB,MAAM,CAACsB,QAAQ,CAACgD,IAAI,CAACjF,MAAM,CAAC;MAC3E,IAAI,CAACqB,MAAM,CAAC,CAAC;IACf;EAAA;IAAAoC,GAAA;IAAAC,KAAA,EAEA,SAAAwB,SAASA,CAACpF,KAAa,EAAc;MAAA,IAAZE,MAAM,GAAAC,SAAA,CAAAD,MAAA,QAAAC,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,CAAC;MACjC,IAAMkF,YAAY,GAAG,IAAI,CAAC/E,MAAM,CAACJ,MAAM,CAAC,CAAC;MACzCF,KAAK,GAAGsF,IAAI,CAACC,GAAG,CAACvF,KAAK,EAAEqF,YAAY,GAAG,CAAC,CAAC;MACzCnF,MAAM,GAAGoF,IAAI,CAACC,GAAG,CAACvF,KAAK,GAAGE,MAAM,EAAEmF,YAAY,GAAG,CAAC,CAAC,GAAGrF,KAAK;MAC3D,IAAIkC,IAAU;MACd,IAAAsD,iBAAA,GAAqB,IAAI,CAAClF,MAAM,CAACmF,IAAI,CAACzF,KAAK,CAAC;QAAA0F,kBAAA,GAAAC,cAAA,CAAAH,iBAAA;QAAvCC,IAAI,GAAAC,kBAAA;QAAE/C,MAAM,GAAA+C,kBAAA;MACjB,IAAID,IAAI,IAAI,IAAI,EAAE,OAAO,IAAI;MAC7B,IAAIvF,MAAM,GAAG,CAAC,IAAIyC,MAAM,KAAK8C,IAAI,CAACvF,MAAM,CAAC,CAAC,EAAE;QAC1C,IAAA0F,kBAAA,GAAe,IAAI,CAACtF,MAAM,CAACmF,IAAI,CAACzF,KAAK,GAAG,CAAC,CAAC;UAAA6F,kBAAA,GAAAF,cAAA,CAAAC,kBAAA;UAAnCE,IAAI,GAAAD,kBAAA;QACX,IAAIC,IAAI,EAAE;UACR,IAAAC,iBAAA,GAAe,IAAI,CAACzF,MAAM,CAAC0F,IAAI,CAAChG,KAAK,CAAC;YAAAiG,kBAAA,GAAAN,cAAA,CAAAI,iBAAA;YAA/BC,IAAI,GAAAC,kBAAA;UACX,IAAAC,kBAAA,GAAmB,IAAI,CAAC5F,MAAM,CAAC0F,IAAI,CAAChG,KAAK,GAAG,CAAC,CAAC;YAAAmG,kBAAA,GAAAR,cAAA,CAAAO,kBAAA;YAAvCE,QAAQ,GAAAD,kBAAA;UACf,IAAIH,IAAI,KAAKI,QAAQ,EAAE;YACrBX,IAAI,GAAGK,IAAI;YACXnD,MAAM,GAAG,CAAC;UACZ;QACF;MACF;MAAA,IAAA0D,cAAA,GACiBZ,IAAI,CAACa,QAAQ,CAAC3D,MAAM,EAAE,IAAI,CAAC;MAAA,IAAA4D,eAAA,GAAAZ,cAAA,CAAAU,cAAA;MAA3CnE,IAAI,GAAAqE,eAAA;MAAE5D,MAAM,GAAA4D,eAAA;MACb,IAAMlD,KAAK,GAAGhC,QAAQ,CAACmF,WAAW,CAAC,CAAC;MACpC,IAAItG,MAAM,GAAG,CAAC,EAAE;QACdmD,KAAK,CAACoD,QAAQ,CAACvE,IAAI,EAAES,MAAM,CAAC;QAAA,IAAA+D,kBAAA,GACX,IAAI,CAACpG,MAAM,CAACmF,IAAI,CAACzF,KAAK,GAAGE,MAAM,CAAC;QAAA,IAAAyG,kBAAA,GAAAhB,cAAA,CAAAe,kBAAA;QAAhDjB,IAAI,GAAAkB,kBAAA;QAAEhE,MAAM,GAAAgE,kBAAA;QACb,IAAIlB,IAAI,IAAI,IAAI,EAAE,OAAO,IAAI;QAAA,IAAAmB,eAAA,GACZnB,IAAI,CAACa,QAAQ,CAAC3D,MAAM,EAAE,IAAI,CAAC;QAAA,IAAAkE,eAAA,GAAAlB,cAAA,CAAAiB,eAAA;QAA3C1E,IAAI,GAAA2E,eAAA;QAAElE,MAAM,GAAAkE,eAAA;QACbxD,KAAK,CAACyD,MAAM,CAAC5E,IAAI,EAAES,MAAM,CAAC;QAC1B,OAAOU,KAAK,CAAC0D,qBAAqB,CAAC,CAAC;MACtC;MACA,IAAIC,IAAsB,GAAG,MAAM;MACnC,IAAIC,IAAa;MACjB,IAAI/E,IAAI,YAAYgF,IAAI,EAAE;QACxB;QACA;QACA;QACA;QACA;QACA,IAAI,CAAChF,IAAI,CAACiD,IAAI,CAACjF,MAAM,EAAE;UACrB,OAAO,IAAI;QACb;QACA,IAAIyC,MAAM,GAAGT,IAAI,CAACiD,IAAI,CAACjF,MAAM,EAAE;UAC7BmD,KAAK,CAACoD,QAAQ,CAACvE,IAAI,EAAES,MAAM,CAAC;UAC5BU,KAAK,CAACyD,MAAM,CAAC5E,IAAI,EAAES,MAAM,GAAG,CAAC,CAAC;QAChC,CAAC,MAAM;UACLU,KAAK,CAACoD,QAAQ,CAACvE,IAAI,EAAES,MAAM,GAAG,CAAC,CAAC;UAChCU,KAAK,CAACyD,MAAM,CAAC5E,IAAI,EAAES,MAAM,CAAC;UAC1BqE,IAAI,GAAG,OAAO;QAChB;QACAC,IAAI,GAAG5D,KAAK,CAAC0D,qBAAqB,CAAC,CAAC;MACtC,CAAC,MAAM;QACL,IAAI,EAAEtB,IAAI,CAAC7E,OAAO,YAAYuG,OAAO,CAAC,EAAE,OAAO,IAAI;QACnDF,IAAI,GAAGxB,IAAI,CAAC7E,OAAO,CAACmG,qBAAqB,CAAC,CAAC;QAC3C,IAAIpE,MAAM,GAAG,CAAC,EAAEqE,IAAI,GAAG,OAAO;MAChC;MACA,OAAO;QACLI,MAAM,EAAEH,IAAI,CAACI,GAAG,GAAGJ,IAAI,CAACK,MAAM;QAC9BA,MAAM,EAAEL,IAAI,CAACK,MAAM;QACnBC,IAAI,EAAEN,IAAI,CAACD,IAAI,CAAC;QAChBQ,KAAK,EAAEP,IAAI,CAACD,IAAI,CAAC;QACjBK,GAAG,EAAEJ,IAAI,CAACI,GAAG;QACbI,KAAK,EAAE;MACT,CAAC;IACH;EAAA;IAAA9D,GAAA;IAAAC,KAAA,EAEA,SAAA5B,cAAcA,CAAA,EAA2B;MACvC,IAAM0F,SAAS,GAAGrG,QAAQ,CAACsG,YAAY,CAAC,CAAC;MACzC,IAAID,SAAS,IAAI,IAAI,IAAIA,SAAS,CAACE,UAAU,IAAI,CAAC,EAAE,OAAO,IAAI;MAC/D,IAAMpD,WAAW,GAAGkD,SAAS,CAACG,UAAU,CAAC,CAAC,CAAC;MAC3C,IAAIrD,WAAW,IAAI,IAAI,EAAE,OAAO,IAAI;MACpC,IAAMnB,KAAK,GAAG,IAAI,CAACyE,eAAe,CAACtD,WAAW,CAAC;MAC/C3E,KAAK,CAACkI,IAAI,CAAC,gBAAgB,EAAE1E,KAAK,CAAC;MACnC,OAAOA,KAAK;IACd;EAAA;IAAAM,GAAA;IAAAC,KAAA,EAEA,SAAAoE,QAAQA,CAAA,EAA4C;MAClD,IAAMrH,IAAI,GAAG,IAAI,CAACL,MAAM,CAACM,OAAO;MAChC,IAAI,aAAa,IAAID,IAAI,IAAI,CAACA,IAAI,CAACsH,WAAW,EAAE;QAC9C;QACA;QACA,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC;MACrB;MACA,IAAMC,UAAU,GAAG,IAAI,CAAClG,cAAc,CAAC,CAAC;MACxC,IAAIkG,UAAU,IAAI,IAAI,EAAE,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC;MAC3C,IAAM7E,KAAK,GAAG,IAAI,CAAC8E,iBAAiB,CAACD,UAAU,CAAC;MAChD,OAAO,CAAC7E,KAAK,EAAE6E,UAAU,CAAC;IAC5B;EAAA;IAAAvE,GAAA;IAAAC,KAAA,EAEA,SAAA9B,QAAQA,CAAA,EAAY;MAClB,OACET,QAAQ,CAAC+G,aAAa,KAAK,IAAI,CAACzH,IAAI,IACnCU,QAAQ,CAAC+G,aAAa,IAAI,IAAI,IAC7B5F,QAAQ,CAAC,IAAI,CAAC7B,IAAI,EAAEU,QAAQ,CAAC+G,aAAa,CAAE;IAElD;EAAA;IAAAzE,GAAA;IAAAC,KAAA,EAEA,SAAAuE,iBAAiBA,CAAC9E,KAAsB,EAAE;MAAA,IAAAgF,MAAA;MACxC,IAAMC,SAA2B,GAAG,CAClC,CAACjF,KAAK,CAACpB,KAAK,CAACC,IAAI,EAAEmB,KAAK,CAACpB,KAAK,CAACU,MAAM,CAAC,CACvC;MACD,IAAI,CAACU,KAAK,UAAO,CAACoB,SAAS,EAAE;QAC3B6D,SAAS,CAACC,IAAI,CAAC,CAAClF,KAAK,CAACZ,GAAG,CAACP,IAAI,EAAEmB,KAAK,CAACZ,GAAG,CAACE,MAAM,CAAC,CAAC;MACpD;MACA,IAAM6F,OAAO,GAAGF,SAAS,CAACG,GAAG,CAAE,UAAAnC,QAAQ,EAAK;QAC1C,IAAAoC,SAAA,GAAA/C,cAAA,CAAuBW,QAAQ;UAAxBpE,IAAI,GAAAwG,SAAA;UAAE/F,MAAM,GAAA+F,SAAA;QACnB,IAAM9D,IAAI,GAAGyD,MAAI,CAAC/H,MAAM,CAACuE,IAAI,CAAC3C,IAAI,EAAE,IAAI,CAAC;QACzC;QACA,IAAMlC,KAAK,GAAG4E,IAAI,CAACjC,MAAM,CAAC0F,MAAI,CAAC/H,MAAM,CAAC;QACtC,IAAIqC,MAAM,KAAK,CAAC,EAAE;UAChB,OAAO3C,KAAK;QACd;QACA,IAAI4E,IAAI,YAAYrF,QAAQ,EAAE;UAC5B,OAAOS,KAAK,GAAG4E,IAAI,CAAC5E,KAAK,CAACkC,IAAI,EAAES,MAAM,CAAC;QACzC;QACA;QACA,OAAO3C,KAAK,GAAG4E,IAAI,CAAC1E,MAAM,CAAC,CAAC;MAC9B,CAAC,CAAC;MACF,IAAMuC,GAAG,GAAG6C,IAAI,CAACC,GAAG,CAACD,IAAI,CAACqD,GAAG,CAAAC,KAAA,CAARtD,IAAI,EAAAuD,kBAAA,CAAQL,OAAO,EAAC,EAAE,IAAI,CAAClI,MAAM,CAACJ,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC;MACpE,IAAM+B,KAAK,GAAGqD,IAAI,CAACC,GAAG,CAAAqD,KAAA,CAARtD,IAAI,GAAK7C,GAAG,EAAAqG,MAAA,CAAAD,kBAAA,CAAKL,OAAO,GAAC;MACvC,OAAO,IAAI1I,KAAK,CAACmC,KAAK,EAAEQ,GAAG,GAAGR,KAAK,CAAC;IACtC;EAAA;IAAA0B,GAAA;IAAAC,KAAA,EAEA,SAAAkE,eAAeA,CAACtD,WAAwB,EAAE;MACxC,IACE,CAAChC,QAAQ,CAAC,IAAI,CAAC7B,IAAI,EAAE6D,WAAW,CAACuE,cAAc,CAAC,IAC/C,CAACvE,WAAW,CAACC,SAAS,IAAI,CAACjC,QAAQ,CAAC,IAAI,CAAC7B,IAAI,EAAE6D,WAAW,CAACwE,YAAY,CAAE,EAC1E;QACA,OAAO,IAAI;MACb;MACA,IAAM3F,KAAK,GAAG;QACZpB,KAAK,EAAE;UACLC,IAAI,EAAEsC,WAAW,CAACuE,cAAc;UAChCpG,MAAM,EAAE6B,WAAW,CAAChB;QACtB,CAAC;QACDf,GAAG,EAAE;UAAEP,IAAI,EAAEsC,WAAW,CAACwE,YAAY;UAAErG,MAAM,EAAE6B,WAAW,CAACd;QAAU,CAAC;QACtE,UAAQc;MACV,CAAC;MACD,CAACnB,KAAK,CAACpB,KAAK,EAAEoB,KAAK,CAACZ,GAAG,CAAC,CAACwG,OAAO,CAAE,UAAA3C,QAAQ,EAAK;QAC7C,IAAMpE,IAAI,GAAaoE,QAAQ,CAAzBpE,IAAI;UAAES,MAAA,GAAW2D,QAAQ,CAAnB3D,MAAA;QACZ,OAAO,EAAET,IAAI,YAAYgF,IAAI,CAAC,IAAIhF,IAAI,CAACgH,UAAU,CAAChJ,MAAM,GAAG,CAAC,EAAE;UAC5D,IAAIgC,IAAI,CAACgH,UAAU,CAAChJ,MAAM,GAAGyC,MAAM,EAAE;YACnCT,IAAI,GAAGA,IAAI,CAACgH,UAAU,CAACvG,MAAM,CAAC;YAC9BA,MAAM,GAAG,CAAC;UACZ,CAAC,MAAM,IAAIT,IAAI,CAACgH,UAAU,CAAChJ,MAAM,KAAKyC,MAAM,EAAE;YAC5C;YACAT,IAAI,GAAGA,IAAI,CAACiH,SAAS;YACrB,IAAIjH,IAAI,YAAYgF,IAAI,EAAE;cACxBvE,MAAM,GAAGT,IAAI,CAACiD,IAAI,CAACjF,MAAM;YAC3B,CAAC,MAAM,IAAIgC,IAAI,CAACgH,UAAU,CAAChJ,MAAM,GAAG,CAAC,EAAE;cACrC;cACAyC,MAAM,GAAGT,IAAI,CAACgH,UAAU,CAAChJ,MAAM;YACjC,CAAC,MAAM;cACL;cACAyC,MAAM,GAAGT,IAAI,CAACgH,UAAU,CAAChJ,MAAM,GAAG,CAAC;YACrC;UACF,CAAC,MAAM;YACL;UACF;QACF;QACAoG,QAAQ,CAACpE,IAAI,GAAGA,IAAI;QACpBoE,QAAQ,CAAC3D,MAAM,GAAGA,MAAM;MAC1B,CAAC,CAAC;MACF,OAAOU,KAAK;IACd;EAAA;IAAAM,GAAA;IAAAC,KAAA,EAEA,SAAAwF,aAAaA,CAAC/F,KAAY,EAA8C;MAAA,IAAAgG,MAAA;MACtE,IAAMhE,YAAY,GAAG,IAAI,CAAC/E,MAAM,CAACJ,MAAM,CAAC,CAAC;MAEzC,IAAMoJ,WAAW,GAAG,SAAdA,WAAWA,CACftJ,KAAa,EACbuJ,SAAkB,EACQ;QAC1BvJ,KAAK,GAAGsF,IAAI,CAACC,GAAG,CAACF,YAAY,GAAG,CAAC,EAAErF,KAAK,CAAC;QACzC,IAAAwJ,kBAAA,GAA2BH,MAAI,CAAC/I,MAAM,CAACmF,IAAI,CAACzF,KAAK,CAAC;UAAAyJ,mBAAA,GAAA9D,cAAA,CAAA6D,kBAAA;UAA3C/D,IAAI,GAAAgE,mBAAA;UAAEC,UAAU,GAAAD,mBAAA;QACvB,OAAOhE,IAAI,GAAGA,IAAI,CAACa,QAAQ,CAACoD,UAAU,EAAEH,SAAS,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;MACjE,CAAC;MACD,UAAAT,MAAA,CAAAD,kBAAA,CACKS,WAAW,CAACjG,KAAK,CAACrD,KAAK,EAAE,KAAK,CAAC,GAAA6I,kBAAA,CAC/BS,WAAW,CAACjG,KAAK,CAACrD,KAAK,GAAGqD,KAAK,CAACnD,MAAM,EAAE,IAAI,CAAC;IAEpD;EAAA;IAAAyD,GAAA;IAAAC,KAAA,EAEA,SAAAlB,cAAcA,CACZa,SAAsB,EACtBC,WAAoB,EAIpB;MAAA,IAHAC,OAAO,GAAAtD,SAAA,CAAAD,MAAA,QAAAC,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAGoD,SAAS;MAAA,IACnBG,SAAS,GAAAvD,SAAA,CAAAD,MAAA,QAAAC,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAGqD,WAAW;MAAA,IACvBmG,KAAK,GAAAxJ,SAAA,CAAAD,MAAA,QAAAC,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,KAAK;MAEbN,KAAK,CAACkI,IAAI,CAAC,gBAAgB,EAAExE,SAAS,EAAEC,WAAW,EAAEC,OAAO,EAAEC,SAAS,CAAC;MACxE,IACEH,SAAS,IAAI,IAAI,KAChB,IAAI,CAAC5C,IAAI,CAACiJ,UAAU,IAAI,IAAI,IAC3BrG,SAAS,CAACqG,UAAU,IAAI,IAAI;MAC5B;MACAnG,OAAO,CAACmG,UAAU,IAAI,IAAI,CAAC,EAC7B;QACA;MACF;MACA,IAAMlC,SAAS,GAAGrG,QAAQ,CAACsG,YAAY,CAAC,CAAC;MACzC,IAAID,SAAS,IAAI,IAAI,EAAE;MACvB,IAAInE,SAAS,IAAI,IAAI,EAAE;QACrB,IAAI,CAAC,IAAI,CAACzB,QAAQ,CAAC,CAAC,EAAE,IAAI,CAACnB,IAAI,CAACyD,KAAK,CAAC;UAAEC,aAAa,EAAE;QAAK,CAAC,CAAC;QAC9D,IAAAwF,IAAA,GAAmB,IAAI,CAAC7H,cAAc,CAAC,CAAC,IAAI,CAAC,CAAC;UAAtCD,QAAA,GAAA8H,IAAA;QACR,IACE9H,QAAM,IAAI,IAAI,IACd4H,KAAK,IACLpG,SAAS,KAAKxB,QAAM,CAACgH,cAAc,IACnCvF,WAAW,KAAKzB,QAAM,CAACyB,WAAW,IAClCC,OAAO,KAAK1B,QAAM,CAACiH,YAAY,IAC/BtF,SAAS,KAAK3B,QAAM,CAAC2B,SAAS,EAC9B;UACA,IAAIH,SAAS,YAAY4D,OAAO,IAAI5D,SAAS,CAACuG,OAAO,KAAK,IAAI,EAAE;YAC9D;YACAtG,WAAW,GAAGuG,KAAK,CAACC,IAAI,CAACzG,SAAS,CAACqG,UAAU,CAACV,UAAU,CAAC,CAACe,OAAO,CAC/D1G,SACF,CAAC;YACDA,SAAS,GAAGA,SAAS,CAACqG,UAAU;UAClC;UACA,IAAInG,OAAO,YAAY0D,OAAO,IAAI1D,OAAO,CAACqG,OAAO,KAAK,IAAI,EAAE;YAC1D;YACApG,SAAS,GAAGqG,KAAK,CAACC,IAAI,CAACvG,OAAO,CAACmG,UAAU,CAACV,UAAU,CAAC,CAACe,OAAO,CAC3DxG,OACF,CAAC;YACDA,OAAO,GAAGA,OAAO,CAACmG,UAAU;UAC9B;UACA,IAAMvG,KAAK,GAAGhC,QAAQ,CAACmF,WAAW,CAAC,CAAC;UACpC;UACAnD,KAAK,CAACoD,QAAQ,CAAClD,SAAS,EAAEC,WAAW,CAAC;UACtC;UACAH,KAAK,CAACyD,MAAM,CAACrD,OAAO,EAAEC,SAAS,CAAC;UAChCgE,SAAS,CAACwC,eAAe,CAAC,CAAC;UAC3BxC,SAAS,CAACyC,QAAQ,CAAC9G,KAAK,CAAC;QAC3B;MACF,CAAC,MAAM;QACLqE,SAAS,CAACwC,eAAe,CAAC,CAAC;QAC3B,IAAI,CAACvJ,IAAI,CAACyJ,IAAI,CAAC,CAAC;MAClB;IACF;EAAA;IAAAzG,GAAA;IAAAC,KAAA,EAIA,SAAAU,QAAQA,CACNjB,KAAmB,EAGb;MAAA,IAFNsG,KAA8B,GAAAxJ,SAAA,CAAAD,MAAA,QAAAC,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,KAAK;MAAA,IACtCmC,MAAqB,GAAAnC,SAAA,CAAAD,MAAA,QAAAC,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAGR,OAAO,CAAC8B,OAAO,CAAC4I,GAAG;MAE3C,IAAI,OAAOV,KAAK,KAAK,QAAQ,EAAE;QAC7BrH,MAAM,GAAGqH,KAAK;QACdA,KAAK,GAAG,KAAK;MACf;MACA9J,KAAK,CAACkI,IAAI,CAAC,UAAU,EAAE1E,KAAK,CAAC;MAC7B,IAAIA,KAAK,IAAI,IAAI,EAAE;QACjB,IAAMiH,IAAI,GAAG,IAAI,CAAClB,aAAa,CAAC/F,KAAK,CAAC;QACtC,IAAI,CAACX,cAAc,CAAAkG,KAAA,CAAnB,IAAI,EAAAC,kBAAA,CAAmByB,IAAI,EAAAxB,MAAA,EAAEa,KAAK,GAAC;MACrC,CAAC,MAAM;QACL,IAAI,CAACjH,cAAc,CAAC,IAAI,CAAC;MAC3B;MACA,IAAI,CAACnB,MAAM,CAACe,MAAM,CAAC;IACrB;EAAA;IAAAqB,GAAA;IAAAC,KAAA,EAEA,SAAArC,MAAMA,CAAA,EAA+C;MAAA,IAA9Ce,MAAqB,GAAAnC,SAAA,CAAAD,MAAA,QAAAC,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAGR,OAAO,CAAC8B,OAAO,CAACC,IAAI;MACjD,IAAM6I,QAAQ,GAAG,IAAI,CAACvJ,SAAS;MAC/B,IAAAwJ,cAAA,GAAiC,IAAI,CAACxC,QAAQ,CAAC,CAAC;QAAAyC,eAAA,GAAA9E,cAAA,CAAA6E,cAAA;QAAzCxJ,SAAS,GAAAyJ,eAAA;QAAEjG,WAAW,GAAAiG,eAAA;MAC7B,IAAI,CAACzJ,SAAS,GAAGA,SAAS;MAC1B,IAAI,CAACC,UAAU,GAAGuD,WAAW;MAC7B,IAAI,IAAI,CAACxD,SAAS,IAAI,IAAI,EAAE;QAC1B,IAAI,CAACD,UAAU,GAAG,IAAI,CAACC,SAAS;MAClC;MACA,IAAI,CAACtB,OAAO,CAAC6K,QAAQ,EAAE,IAAI,CAACvJ,SAAS,CAAC,EAAE;QAAA,IAAA0J,aAAA;QACtC,IACE,CAAC,IAAI,CAACjK,SAAS,IACf+D,WAAW,IAAI,IAAI,IACnBA,WAAW,UAAO,CAACC,SAAS,IAC5BD,WAAW,CAACvC,KAAK,CAACC,IAAI,KAAK,IAAI,CAACrB,MAAM,CAACsB,QAAQ,EAC/C;UACA,IAAMkB,KAAK,GAAG,IAAI,CAACxC,MAAM,CAACoD,OAAO,CAAC,CAAC;UACnC,IAAIZ,KAAK,EAAE;YACT,IAAI,CAACX,cAAc,CACjBW,KAAK,CAACE,SAAS,EACfF,KAAK,CAACG,WAAW,EACjBH,KAAK,CAACI,OAAO,EACbJ,KAAK,CAACK,SACR,CAAC;UACH;QACF;QACA,IAAM4G,IAAI,GAAG,CACX3K,OAAO,CAACiC,MAAM,CAAC+I,gBAAgB,EAC/BlL,SAAS,CAAC,IAAI,CAACuB,SAAS,CAAC,EACzBvB,SAAS,CAAC8K,QAAQ,CAAC,EACnBjI,MAAM,CACP;QACD,CAAAoI,aAAA,OAAI,CAACnK,OAAO,EAACqK,IAAI,CAAAhC,KAAA,CAAA8B,aAAA,GAAC/K,OAAO,CAACiC,MAAM,CAACiJ,aAAa,EAAA/B,MAAA,CAAKwB,IAAI,EAAC;QACxD,IAAIhI,MAAM,KAAK3C,OAAO,CAAC8B,OAAO,CAACwB,MAAM,EAAE;UAAA,IAAA6H,cAAA;UACrC,CAAAA,cAAA,OAAI,CAACvK,OAAO,EAACqK,IAAI,CAAAhC,KAAA,CAAAkC,cAAA,EAAIR,IAAI,CAAC;QAC5B;MACF;IACF;EAAA;AAAA;AAGF,SAAS9H,QAAQA,CAACwB,MAAY,EAAE+G,UAAgB,EAAE;EAChD,IAAI;IACF;IACAA,UAAU,CAACnB,UAAU,CAAC,CAAC;EACzB,CAAC,CAAC,OAAOoB,CAAC,EAAE;IACV,OAAO,KAAK;EACd;EACA,OAAOhH,MAAM,CAACxB,QAAQ,CAACuI,UAAU,CAAC;AACpC;AAEA,eAAe1K,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import _typeof from \"/home/esteban/2emeAnnee/S3/devWeb/QuanticGP10/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport _slicedToArray from \"/home/esteban/2emeAnnee/S3/devWeb/QuanticGP10/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/home/esteban/2emeAnnee/S3/devWeb/QuanticGP10/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/esteban/2emeAnnee/S3/devWeb/QuanticGP10/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _callSuper from \"/home/esteban/2emeAnnee/S3/devWeb/QuanticGP10/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _superPropGet from \"/home/esteban/2emeAnnee/S3/devWeb/QuanticGP10/node_modules/@babel/runtime/helpers/esm/superPropGet.js\";\nimport _inherits from \"/home/esteban/2emeAnnee/S3/devWeb/QuanticGP10/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _defineProperty from \"/home/esteban/2emeAnnee/S3/devWeb/QuanticGP10/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.find.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.entries.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.ends-with.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.filter.js\";\nimport \"core-js/modules/esnext.iterator.find.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.reduce.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { ContainerBlot, LeafBlot, Scope, ScrollBlot } from 'parchment';\nimport Delta, { AttributeMap, Op } from 'quill-delta';\nimport Emitter from '../core/emitter.js';\nimport Block, { BlockEmbed, bubbleFormats } from './block.js';\nimport Break from './break.js';\nimport Container from './container.js';\nfunction isLine(blot) {\n  return blot instanceof Block || blot instanceof BlockEmbed;\n}\nfunction isUpdatable(blot) {\n  return typeof blot.updateContent === 'function';\n}\nvar Scroll = /*#__PURE__*/function (_ScrollBlot) {\n  function Scroll(registry, domNode, _ref) {\n    var _this;\n    _classCallCheck(this, Scroll);\n    var emitter = _ref.emitter;\n    _this = _callSuper(this, Scroll, [registry, domNode]);\n    _this.emitter = emitter;\n    _this.batch = false;\n    _this.optimize();\n    _this.enable();\n    _this.domNode.addEventListener('dragstart', function (e) {\n      return _this.handleDragStart(e);\n    });\n    return _this;\n  }\n  _inherits(Scroll, _ScrollBlot);\n  return _createClass(Scroll, [{\n    key: \"batchStart\",\n    value: function batchStart() {\n      if (!Array.isArray(this.batch)) {\n        this.batch = [];\n      }\n    }\n  }, {\n    key: \"batchEnd\",\n    value: function batchEnd() {\n      if (!this.batch) return;\n      var mutations = this.batch;\n      this.batch = false;\n      this.update(mutations);\n    }\n  }, {\n    key: \"emitMount\",\n    value: function emitMount(blot) {\n      this.emitter.emit(Emitter.events.SCROLL_BLOT_MOUNT, blot);\n    }\n  }, {\n    key: \"emitUnmount\",\n    value: function emitUnmount(blot) {\n      this.emitter.emit(Emitter.events.SCROLL_BLOT_UNMOUNT, blot);\n    }\n  }, {\n    key: \"emitEmbedUpdate\",\n    value: function emitEmbedUpdate(blot, change) {\n      this.emitter.emit(Emitter.events.SCROLL_EMBED_UPDATE, blot, change);\n    }\n  }, {\n    key: \"deleteAt\",\n    value: function deleteAt(index, length) {\n      var _this$line = this.line(index),\n        _this$line2 = _slicedToArray(_this$line, 2),\n        first = _this$line2[0],\n        offset = _this$line2[1];\n      var _this$line3 = this.line(index + length),\n        _this$line4 = _slicedToArray(_this$line3, 1),\n        last = _this$line4[0];\n      _superPropGet(Scroll, \"deleteAt\", this, 3)([index, length]);\n      if (last != null && first !== last && offset > 0) {\n        if (first instanceof BlockEmbed || last instanceof BlockEmbed) {\n          this.optimize();\n          return;\n        }\n        var ref = last.children.head instanceof Break ? null : last.children.head;\n        // @ts-expect-error\n        first.moveChildren(last, ref);\n        // @ts-expect-error\n        first.remove();\n      }\n      this.optimize();\n    }\n  }, {\n    key: \"enable\",\n    value: function enable() {\n      var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      this.domNode.setAttribute('contenteditable', enabled ? 'true' : 'false');\n    }\n  }, {\n    key: \"formatAt\",\n    value: function formatAt(index, length, format, value) {\n      _superPropGet(Scroll, \"formatAt\", this, 3)([index, length, format, value]);\n      this.optimize();\n    }\n  }, {\n    key: \"insertAt\",\n    value: function insertAt(index, value, def) {\n      if (index >= this.length()) {\n        if (def == null || this.scroll.query(value, Scope.BLOCK) == null) {\n          var blot = this.scroll.create(this.statics.defaultChild.blotName);\n          this.appendChild(blot);\n          if (def == null && value.endsWith('\\n')) {\n            blot.insertAt(0, value.slice(0, -1), def);\n          } else {\n            blot.insertAt(0, value, def);\n          }\n        } else {\n          var embed = this.scroll.create(value, def);\n          this.appendChild(embed);\n        }\n      } else {\n        _superPropGet(Scroll, \"insertAt\", this, 3)([index, value, def]);\n      }\n      this.optimize();\n    }\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(blot, ref) {\n      if (blot.statics.scope === Scope.INLINE_BLOT) {\n        var wrapper = this.scroll.create(this.statics.defaultChild.blotName);\n        wrapper.appendChild(blot);\n        _superPropGet(Scroll, \"insertBefore\", this, 3)([wrapper, ref]);\n      } else {\n        _superPropGet(Scroll, \"insertBefore\", this, 3)([blot, ref]);\n      }\n    }\n  }, {\n    key: \"insertContents\",\n    value: function insertContents(index, delta) {\n      var _this2 = this;\n      var renderBlocks = this.deltaToRenderBlocks(delta.concat(new Delta().insert('\\n')));\n      var last = renderBlocks.pop();\n      if (last == null) return;\n      this.batchStart();\n      var first = renderBlocks.shift();\n      if (first) {\n        var shouldInsertNewlineChar = first.type === 'block' && (first.delta.length() === 0 || !this.descendant(BlockEmbed, index)[0] && index < this.length());\n        var _delta = first.type === 'block' ? first.delta : new Delta().insert(_defineProperty({}, first.key, first.value));\n        insertInlineContents(this, index, _delta);\n        var newlineCharLength = first.type === 'block' ? 1 : 0;\n        var lineEndIndex = index + _delta.length() + newlineCharLength;\n        if (shouldInsertNewlineChar) {\n          this.insertAt(lineEndIndex - 1, '\\n');\n        }\n        var formats = bubbleFormats(this.line(index)[0]);\n        var attributes = AttributeMap.diff(formats, first.attributes) || {};\n        Object.keys(attributes).forEach(function (name) {\n          _this2.formatAt(lineEndIndex - 1, 1, name, attributes[name]);\n        });\n        index = lineEndIndex;\n      }\n      var _this$children$find = this.children.find(index),\n        _this$children$find2 = _slicedToArray(_this$children$find, 2),\n        refBlot = _this$children$find2[0],\n        refBlotOffset = _this$children$find2[1];\n      if (renderBlocks.length) {\n        if (refBlot) {\n          refBlot = refBlot.split(refBlotOffset);\n          refBlotOffset = 0;\n        }\n        renderBlocks.forEach(function (renderBlock) {\n          if (renderBlock.type === 'block') {\n            var block = _this2.createBlock(renderBlock.attributes, refBlot || undefined);\n            insertInlineContents(block, 0, renderBlock.delta);\n          } else {\n            var blockEmbed = _this2.create(renderBlock.key, renderBlock.value);\n            _this2.insertBefore(blockEmbed, refBlot || undefined);\n            Object.keys(renderBlock.attributes).forEach(function (name) {\n              blockEmbed.format(name, renderBlock.attributes[name]);\n            });\n          }\n        });\n      }\n      if (last.type === 'block' && last.delta.length()) {\n        var offset = refBlot ? refBlot.offset(refBlot.scroll) + refBlotOffset : this.length();\n        insertInlineContents(this, offset, last.delta);\n      }\n      this.batchEnd();\n      this.optimize();\n    }\n  }, {\n    key: \"isEnabled\",\n    value: function isEnabled() {\n      return this.domNode.getAttribute('contenteditable') === 'true';\n    }\n  }, {\n    key: \"leaf\",\n    value: function leaf(index) {\n      var last = this.path(index).pop();\n      if (!last) {\n        return [null, -1];\n      }\n      var _last = _slicedToArray(last, 2),\n        blot = _last[0],\n        offset = _last[1];\n      return blot instanceof LeafBlot ? [blot, offset] : [null, -1];\n    }\n  }, {\n    key: \"line\",\n    value: function line(index) {\n      if (index === this.length()) {\n        return this.line(index - 1);\n      }\n      // @ts-expect-error TODO: make descendant() generic\n      return this.descendant(isLine, index);\n    }\n  }, {\n    key: \"lines\",\n    value: function lines() {\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;\n      var _getLines = function getLines(blot, blotIndex, blotLength) {\n        var lines = [];\n        var lengthLeft = blotLength;\n        blot.children.forEachAt(blotIndex, blotLength, function (child, childIndex, childLength) {\n          if (isLine(child)) {\n            lines.push(child);\n          } else if (child instanceof ContainerBlot) {\n            lines = lines.concat(_getLines(child, childIndex, lengthLeft));\n          }\n          lengthLeft -= childLength;\n        });\n        return lines;\n      };\n      return _getLines(this, index, length);\n    }\n  }, {\n    key: \"optimize\",\n    value: function optimize() {\n      var mutations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (this.batch) return;\n      _superPropGet(Scroll, \"optimize\", this, 3)([mutations, context]);\n      if (mutations.length > 0) {\n        this.emitter.emit(Emitter.events.SCROLL_OPTIMIZE, mutations, context);\n      }\n    }\n  }, {\n    key: \"path\",\n    value: function path(index) {\n      return _superPropGet(Scroll, \"path\", this, 3)([index]).slice(1); // Exclude self\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      // Never remove self\n    }\n  }, {\n    key: \"update\",\n    value: function update(mutations) {\n      var _this3 = this;\n      if (this.batch) {\n        if (Array.isArray(mutations)) {\n          this.batch = this.batch.concat(mutations);\n        }\n        return;\n      }\n      var source = Emitter.sources.USER;\n      if (typeof mutations === 'string') {\n        source = mutations;\n      }\n      if (!Array.isArray(mutations)) {\n        mutations = this.observer.takeRecords();\n      }\n      mutations = mutations.filter(function (_ref2) {\n        var target = _ref2.target;\n        var blot = _this3.find(target, true);\n        return blot && !isUpdatable(blot);\n      });\n      if (mutations.length > 0) {\n        this.emitter.emit(Emitter.events.SCROLL_BEFORE_UPDATE, source, mutations);\n      }\n      _superPropGet(Scroll, \"update\", this, 3)([mutations.concat([])]); // pass copy\n      if (mutations.length > 0) {\n        this.emitter.emit(Emitter.events.SCROLL_UPDATE, source, mutations);\n      }\n    }\n  }, {\n    key: \"updateEmbedAt\",\n    value: function updateEmbedAt(index, key, change) {\n      // Currently it only supports top-level embeds (BlockEmbed).\n      // We can update `ParentBlot` in parchment to support inline embeds.\n      var _this$descendant = this.descendant(function (b) {\n          return b instanceof BlockEmbed;\n        }, index),\n        _this$descendant2 = _slicedToArray(_this$descendant, 1),\n        blot = _this$descendant2[0];\n      if (blot && blot.statics.blotName === key && isUpdatable(blot)) {\n        blot.updateContent(change);\n      }\n    }\n  }, {\n    key: \"handleDragStart\",\n    value: function handleDragStart(event) {\n      event.preventDefault();\n    }\n  }, {\n    key: \"deltaToRenderBlocks\",\n    value: function deltaToRenderBlocks(delta) {\n      var _this4 = this;\n      var renderBlocks = [];\n      var currentBlockDelta = new Delta();\n      delta.forEach(function (op) {\n        var insert = op === null || op === void 0 ? void 0 : op.insert;\n        if (!insert) return;\n        if (typeof insert === 'string') {\n          var splitted = insert.split('\\n');\n          splitted.slice(0, -1).forEach(function (text) {\n            var _op$attributes;\n            currentBlockDelta.insert(text, op.attributes);\n            renderBlocks.push({\n              type: 'block',\n              delta: currentBlockDelta,\n              attributes: (_op$attributes = op.attributes) !== null && _op$attributes !== void 0 ? _op$attributes : {}\n            });\n            currentBlockDelta = new Delta();\n          });\n          var last = splitted[splitted.length - 1];\n          if (last) {\n            currentBlockDelta.insert(last, op.attributes);\n          }\n        } else {\n          var key = Object.keys(insert)[0];\n          if (!key) return;\n          if (_this4.query(key, Scope.INLINE)) {\n            currentBlockDelta.push(op);\n          } else {\n            var _op$attributes2;\n            if (currentBlockDelta.length()) {\n              renderBlocks.push({\n                type: 'block',\n                delta: currentBlockDelta,\n                attributes: {}\n              });\n            }\n            currentBlockDelta = new Delta();\n            renderBlocks.push({\n              type: 'blockEmbed',\n              key: key,\n              value: insert[key],\n              attributes: (_op$attributes2 = op.attributes) !== null && _op$attributes2 !== void 0 ? _op$attributes2 : {}\n            });\n          }\n        }\n      });\n      if (currentBlockDelta.length()) {\n        renderBlocks.push({\n          type: 'block',\n          delta: currentBlockDelta,\n          attributes: {}\n        });\n      }\n      return renderBlocks;\n    }\n  }, {\n    key: \"createBlock\",\n    value: function createBlock(attributes, refBlot) {\n      var _this5 = this;\n      var blotName;\n      var formats = {};\n      Object.entries(attributes).forEach(function (_ref3) {\n        var _ref5 = _slicedToArray(_ref3, 2),\n          key = _ref5[0],\n          value = _ref5[1];\n        var isBlockBlot = _this5.query(key, Scope.BLOCK & Scope.BLOT) != null;\n        if (isBlockBlot) {\n          blotName = key;\n        } else {\n          formats[key] = value;\n        }\n      });\n      var block = this.create(blotName || this.statics.defaultChild.blotName, blotName ? attributes[blotName] : undefined);\n      this.insertBefore(block, refBlot || undefined);\n      var length = block.length();\n      Object.entries(formats).forEach(function (_ref4) {\n        var _ref6 = _slicedToArray(_ref4, 2),\n          key = _ref6[0],\n          value = _ref6[1];\n        block.formatAt(0, length, key, value);\n      });\n      return block;\n    }\n  }]);\n}(ScrollBlot);\n_defineProperty(Scroll, \"blotName\", 'scroll');\n_defineProperty(Scroll, \"className\", 'ql-editor');\n_defineProperty(Scroll, \"tagName\", 'DIV');\n_defineProperty(Scroll, \"defaultChild\", Block);\n_defineProperty(Scroll, \"allowedChildren\", [Block, BlockEmbed, Container]);\nfunction insertInlineContents(parent, index, inlineContents) {\n  inlineContents.reduce(function (index, op) {\n    var length = Op.length(op);\n    var attributes = op.attributes || {};\n    if (op.insert != null) {\n      if (typeof op.insert === 'string') {\n        var text = op.insert;\n        parent.insertAt(index, text);\n        var _parent$descendant = parent.descendant(LeafBlot, index),\n          _parent$descendant2 = _slicedToArray(_parent$descendant, 1),\n          leaf = _parent$descendant2[0];\n        var formats = bubbleFormats(leaf);\n        attributes = AttributeMap.diff(formats, attributes) || {};\n      } else if (_typeof(op.insert) === 'object') {\n        var key = Object.keys(op.insert)[0]; // There should only be one key\n        if (key == null) return index;\n        parent.insertAt(index, key, op.insert[key]);\n        var isInlineEmbed = parent.scroll.query(key, Scope.INLINE) != null;\n        if (isInlineEmbed) {\n          var _parent$descendant3 = parent.descendant(LeafBlot, index),\n            _parent$descendant4 = _slicedToArray(_parent$descendant3, 1),\n            _leaf = _parent$descendant4[0];\n          var _formats = bubbleFormats(_leaf);\n          attributes = AttributeMap.diff(_formats, attributes) || {};\n        }\n      }\n    }\n    Object.keys(attributes).forEach(function (key) {\n      parent.formatAt(index, length, key, attributes[key]);\n    });\n    return index + length;\n  }, index);\n}\nexport default Scroll;","map":{"version":3,"names":["ContainerBlot","LeafBlot","Scope","ScrollBlot","Delta","AttributeMap","Op","Emitter","Block","BlockEmbed","bubbleFormats","Break","Container","isLine","blot","isUpdatable","updateContent","Scroll","_ScrollBlot","registry","domNode","_ref","_this","_classCallCheck","emitter","_callSuper","batch","optimize","enable","addEventListener","e","handleDragStart","_inherits","_createClass","key","value","batchStart","Array","isArray","batchEnd","mutations","update","emitMount","emit","events","SCROLL_BLOT_MOUNT","emitUnmount","SCROLL_BLOT_UNMOUNT","emitEmbedUpdate","change","SCROLL_EMBED_UPDATE","deleteAt","index","length","_this$line","line","_this$line2","_slicedToArray","first","offset","_this$line3","_this$line4","last","_superPropGet","ref","children","head","moveChildren","remove","enabled","arguments","undefined","setAttribute","formatAt","format","insertAt","def","scroll","query","BLOCK","create","statics","defaultChild","blotName","appendChild","endsWith","slice","embed","insertBefore","scope","INLINE_BLOT","wrapper","insertContents","delta","_this2","renderBlocks","deltaToRenderBlocks","concat","insert","pop","shift","shouldInsertNewlineChar","type","descendant","_defineProperty","insertInlineContents","newlineCharLength","lineEndIndex","formats","attributes","diff","Object","keys","forEach","name","_this$children$find","find","_this$children$find2","refBlot","refBlotOffset","split","renderBlock","block","createBlock","blockEmbed","isEnabled","getAttribute","leaf","path","_last","lines","Number","MAX_VALUE","getLines","blotIndex","blotLength","lengthLeft","forEachAt","child","childIndex","childLength","push","context","SCROLL_OPTIMIZE","_this3","source","sources","USER","observer","takeRecords","filter","_ref2","target","SCROLL_BEFORE_UPDATE","SCROLL_UPDATE","updateEmbedAt","_this$descendant","b","_this$descendant2","event","preventDefault","_this4","currentBlockDelta","op","splitted","text","_op$attributes","INLINE","_op$attributes2","_this5","entries","_ref3","_ref5","isBlockBlot","BLOT","_ref4","_ref6","parent","inlineContents","reduce","_parent$descendant","_parent$descendant2","_typeof","isInlineEmbed","_parent$descendant3","_parent$descendant4"],"sources":["../../src/blots/scroll.ts"],"sourcesContent":["import { ContainerBlot, LeafBlot, Scope, ScrollBlot } from 'parchment';\nimport type { Blot, Parent, EmbedBlot, ParentBlot, Registry } from 'parchment';\nimport Delta, { AttributeMap, Op } from 'quill-delta';\nimport Emitter from '../core/emitter.js';\nimport type { EmitterSource } from '../core/emitter.js';\nimport Block, { BlockEmbed, bubbleFormats } from './block.js';\nimport Break from './break.js';\nimport Container from './container.js';\n\ntype RenderBlock =\n  | {\n      type: 'blockEmbed';\n      attributes: AttributeMap;\n      key: string;\n      value: unknown;\n    }\n  | { type: 'block'; attributes: AttributeMap; delta: Delta };\n\nfunction isLine(blot: unknown): blot is Block | BlockEmbed {\n  return blot instanceof Block || blot instanceof BlockEmbed;\n}\n\ninterface UpdatableEmbed {\n  updateContent(change: unknown): void;\n}\n\nfunction isUpdatable(blot: Blot): blot is Blot & UpdatableEmbed {\n  return typeof (blot as unknown as any).updateContent === 'function';\n}\n\nclass Scroll extends ScrollBlot {\n  static blotName = 'scroll';\n  static className = 'ql-editor';\n  static tagName = 'DIV';\n  static defaultChild = Block;\n  static allowedChildren = [Block, BlockEmbed, Container];\n\n  emitter: Emitter;\n  batch: false | MutationRecord[];\n\n  constructor(\n    registry: Registry,\n    domNode: HTMLDivElement,\n    { emitter }: { emitter: Emitter },\n  ) {\n    super(registry, domNode);\n    this.emitter = emitter;\n    this.batch = false;\n    this.optimize();\n    this.enable();\n    this.domNode.addEventListener('dragstart', (e) => this.handleDragStart(e));\n  }\n\n  batchStart() {\n    if (!Array.isArray(this.batch)) {\n      this.batch = [];\n    }\n  }\n\n  batchEnd() {\n    if (!this.batch) return;\n    const mutations = this.batch;\n    this.batch = false;\n    this.update(mutations);\n  }\n\n  emitMount(blot: Blot) {\n    this.emitter.emit(Emitter.events.SCROLL_BLOT_MOUNT, blot);\n  }\n\n  emitUnmount(blot: Blot) {\n    this.emitter.emit(Emitter.events.SCROLL_BLOT_UNMOUNT, blot);\n  }\n\n  emitEmbedUpdate(blot: Blot, change: unknown) {\n    this.emitter.emit(Emitter.events.SCROLL_EMBED_UPDATE, blot, change);\n  }\n\n  deleteAt(index: number, length: number) {\n    const [first, offset] = this.line(index);\n    const [last] = this.line(index + length);\n    super.deleteAt(index, length);\n    if (last != null && first !== last && offset > 0) {\n      if (first instanceof BlockEmbed || last instanceof BlockEmbed) {\n        this.optimize();\n        return;\n      }\n      const ref =\n        last.children.head instanceof Break ? null : last.children.head;\n      // @ts-expect-error\n      first.moveChildren(last, ref);\n      // @ts-expect-error\n      first.remove();\n    }\n    this.optimize();\n  }\n\n  enable(enabled = true) {\n    this.domNode.setAttribute('contenteditable', enabled ? 'true' : 'false');\n  }\n\n  formatAt(index: number, length: number, format: string, value: unknown) {\n    super.formatAt(index, length, format, value);\n    this.optimize();\n  }\n\n  insertAt(index: number, value: string, def?: unknown) {\n    if (index >= this.length()) {\n      if (def == null || this.scroll.query(value, Scope.BLOCK) == null) {\n        const blot = this.scroll.create(this.statics.defaultChild.blotName);\n        this.appendChild(blot);\n        if (def == null && value.endsWith('\\n')) {\n          blot.insertAt(0, value.slice(0, -1), def);\n        } else {\n          blot.insertAt(0, value, def);\n        }\n      } else {\n        const embed = this.scroll.create(value, def);\n        this.appendChild(embed);\n      }\n    } else {\n      super.insertAt(index, value, def);\n    }\n    this.optimize();\n  }\n\n  insertBefore(blot: Blot, ref?: Blot | null) {\n    if (blot.statics.scope === Scope.INLINE_BLOT) {\n      const wrapper = this.scroll.create(\n        this.statics.defaultChild.blotName,\n      ) as Parent;\n      wrapper.appendChild(blot);\n      super.insertBefore(wrapper, ref);\n    } else {\n      super.insertBefore(blot, ref);\n    }\n  }\n\n  insertContents(index: number, delta: Delta) {\n    const renderBlocks = this.deltaToRenderBlocks(\n      delta.concat(new Delta().insert('\\n')),\n    );\n    const last = renderBlocks.pop();\n    if (last == null) return;\n\n    this.batchStart();\n\n    const first = renderBlocks.shift();\n    if (first) {\n      const shouldInsertNewlineChar =\n        first.type === 'block' &&\n        (first.delta.length() === 0 ||\n          (!this.descendant(BlockEmbed, index)[0] && index < this.length()));\n      const delta =\n        first.type === 'block'\n          ? first.delta\n          : new Delta().insert({ [first.key]: first.value });\n      insertInlineContents(this, index, delta);\n      const newlineCharLength = first.type === 'block' ? 1 : 0;\n      const lineEndIndex = index + delta.length() + newlineCharLength;\n      if (shouldInsertNewlineChar) {\n        this.insertAt(lineEndIndex - 1, '\\n');\n      }\n\n      const formats = bubbleFormats(this.line(index)[0]);\n      const attributes = AttributeMap.diff(formats, first.attributes) || {};\n      Object.keys(attributes).forEach((name) => {\n        this.formatAt(lineEndIndex - 1, 1, name, attributes[name]);\n      });\n\n      index = lineEndIndex;\n    }\n\n    let [refBlot, refBlotOffset] = this.children.find(index);\n    if (renderBlocks.length) {\n      if (refBlot) {\n        refBlot = refBlot.split(refBlotOffset);\n        refBlotOffset = 0;\n      }\n\n      renderBlocks.forEach((renderBlock) => {\n        if (renderBlock.type === 'block') {\n          const block = this.createBlock(\n            renderBlock.attributes,\n            refBlot || undefined,\n          );\n          insertInlineContents(block, 0, renderBlock.delta);\n        } else {\n          const blockEmbed = this.create(\n            renderBlock.key,\n            renderBlock.value,\n          ) as EmbedBlot;\n          this.insertBefore(blockEmbed, refBlot || undefined);\n          Object.keys(renderBlock.attributes).forEach((name) => {\n            blockEmbed.format(name, renderBlock.attributes[name]);\n          });\n        }\n      });\n    }\n\n    if (last.type === 'block' && last.delta.length()) {\n      const offset = refBlot\n        ? refBlot.offset(refBlot.scroll) + refBlotOffset\n        : this.length();\n      insertInlineContents(this, offset, last.delta);\n    }\n\n    this.batchEnd();\n    this.optimize();\n  }\n\n  isEnabled() {\n    return this.domNode.getAttribute('contenteditable') === 'true';\n  }\n\n  leaf(index: number): [LeafBlot | null, number] {\n    const last = this.path(index).pop();\n    if (!last) {\n      return [null, -1];\n    }\n\n    const [blot, offset] = last;\n    return blot instanceof LeafBlot ? [blot, offset] : [null, -1];\n  }\n\n  line(index: number): [Block | BlockEmbed | null, number] {\n    if (index === this.length()) {\n      return this.line(index - 1);\n    }\n    // @ts-expect-error TODO: make descendant() generic\n    return this.descendant(isLine, index);\n  }\n\n  lines(index = 0, length = Number.MAX_VALUE): (Block | BlockEmbed)[] {\n    const getLines = (\n      blot: ParentBlot,\n      blotIndex: number,\n      blotLength: number,\n    ) => {\n      let lines: (Block | BlockEmbed)[] = [];\n      let lengthLeft = blotLength;\n      blot.children.forEachAt(\n        blotIndex,\n        blotLength,\n        (child, childIndex, childLength) => {\n          if (isLine(child)) {\n            lines.push(child);\n          } else if (child instanceof ContainerBlot) {\n            lines = lines.concat(getLines(child, childIndex, lengthLeft));\n          }\n          lengthLeft -= childLength;\n        },\n      );\n      return lines;\n    };\n    return getLines(this, index, length);\n  }\n\n  optimize(context?: { [key: string]: any }): void;\n  optimize(\n    mutations?: MutationRecord[],\n    context?: { [key: string]: any },\n  ): void;\n  optimize(mutations = [], context = {}) {\n    if (this.batch) return;\n    super.optimize(mutations, context);\n    if (mutations.length > 0) {\n      this.emitter.emit(Emitter.events.SCROLL_OPTIMIZE, mutations, context);\n    }\n  }\n\n  path(index: number) {\n    return super.path(index).slice(1); // Exclude self\n  }\n\n  remove() {\n    // Never remove self\n  }\n\n  update(source?: EmitterSource): void;\n  update(mutations?: MutationRecord[]): void;\n  update(mutations?: MutationRecord[] | EmitterSource): void {\n    if (this.batch) {\n      if (Array.isArray(mutations)) {\n        this.batch = this.batch.concat(mutations);\n      }\n      return;\n    }\n    let source: EmitterSource = Emitter.sources.USER;\n    if (typeof mutations === 'string') {\n      source = mutations;\n    }\n    if (!Array.isArray(mutations)) {\n      mutations = this.observer.takeRecords();\n    }\n    mutations = mutations.filter(({ target }) => {\n      const blot = this.find(target, true);\n      return blot && !isUpdatable(blot);\n    });\n    if (mutations.length > 0) {\n      this.emitter.emit(Emitter.events.SCROLL_BEFORE_UPDATE, source, mutations);\n    }\n    super.update(mutations.concat([])); // pass copy\n    if (mutations.length > 0) {\n      this.emitter.emit(Emitter.events.SCROLL_UPDATE, source, mutations);\n    }\n  }\n\n  updateEmbedAt(index: number, key: string, change: unknown) {\n    // Currently it only supports top-level embeds (BlockEmbed).\n    // We can update `ParentBlot` in parchment to support inline embeds.\n    const [blot] = this.descendant((b: Blot) => b instanceof BlockEmbed, index);\n    if (blot && blot.statics.blotName === key && isUpdatable(blot)) {\n      blot.updateContent(change);\n    }\n  }\n\n  protected handleDragStart(event: DragEvent) {\n    event.preventDefault();\n  }\n\n  private deltaToRenderBlocks(delta: Delta) {\n    const renderBlocks: RenderBlock[] = [];\n\n    let currentBlockDelta = new Delta();\n    delta.forEach((op) => {\n      const insert = op?.insert;\n      if (!insert) return;\n      if (typeof insert === 'string') {\n        const splitted = insert.split('\\n');\n        splitted.slice(0, -1).forEach((text) => {\n          currentBlockDelta.insert(text, op.attributes);\n          renderBlocks.push({\n            type: 'block',\n            delta: currentBlockDelta,\n            attributes: op.attributes ?? {},\n          });\n          currentBlockDelta = new Delta();\n        });\n        const last = splitted[splitted.length - 1];\n        if (last) {\n          currentBlockDelta.insert(last, op.attributes);\n        }\n      } else {\n        const key = Object.keys(insert)[0];\n        if (!key) return;\n        if (this.query(key, Scope.INLINE)) {\n          currentBlockDelta.push(op);\n        } else {\n          if (currentBlockDelta.length()) {\n            renderBlocks.push({\n              type: 'block',\n              delta: currentBlockDelta,\n              attributes: {},\n            });\n          }\n          currentBlockDelta = new Delta();\n          renderBlocks.push({\n            type: 'blockEmbed',\n            key,\n            value: insert[key],\n            attributes: op.attributes ?? {},\n          });\n        }\n      }\n    });\n\n    if (currentBlockDelta.length()) {\n      renderBlocks.push({\n        type: 'block',\n        delta: currentBlockDelta,\n        attributes: {},\n      });\n    }\n\n    return renderBlocks;\n  }\n\n  private createBlock(attributes: AttributeMap, refBlot?: Blot) {\n    let blotName: string | undefined;\n    const formats: AttributeMap = {};\n\n    Object.entries(attributes).forEach(([key, value]) => {\n      const isBlockBlot = this.query(key, Scope.BLOCK & Scope.BLOT) != null;\n      if (isBlockBlot) {\n        blotName = key;\n      } else {\n        formats[key] = value;\n      }\n    });\n\n    const block = this.create(\n      blotName || this.statics.defaultChild.blotName,\n      blotName ? attributes[blotName] : undefined,\n    ) as ParentBlot;\n\n    this.insertBefore(block, refBlot || undefined);\n\n    const length = block.length();\n    Object.entries(formats).forEach(([key, value]) => {\n      block.formatAt(0, length, key, value);\n    });\n\n    return block;\n  }\n}\n\nfunction insertInlineContents(\n  parent: ParentBlot,\n  index: number,\n  inlineContents: Delta,\n) {\n  inlineContents.reduce((index, op) => {\n    const length = Op.length(op);\n    let attributes = op.attributes || {};\n    if (op.insert != null) {\n      if (typeof op.insert === 'string') {\n        const text = op.insert;\n        parent.insertAt(index, text);\n        const [leaf] = parent.descendant(LeafBlot, index);\n        const formats = bubbleFormats(leaf);\n        attributes = AttributeMap.diff(formats, attributes) || {};\n      } else if (typeof op.insert === 'object') {\n        const key = Object.keys(op.insert)[0]; // There should only be one key\n        if (key == null) return index;\n        parent.insertAt(index, key, op.insert[key]);\n        const isInlineEmbed = parent.scroll.query(key, Scope.INLINE) != null;\n        if (isInlineEmbed) {\n          const [leaf] = parent.descendant(LeafBlot, index);\n          const formats = bubbleFormats(leaf);\n          attributes = AttributeMap.diff(formats, attributes) || {};\n        }\n      }\n    }\n    Object.keys(attributes).forEach((key) => {\n      parent.formatAt(index, length, key, attributes[key]);\n    });\n    return index + length;\n  }, index);\n}\n\nexport default Scroll;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
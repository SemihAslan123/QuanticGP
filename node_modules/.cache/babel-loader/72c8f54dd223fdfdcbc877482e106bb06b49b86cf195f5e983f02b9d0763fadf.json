{"ast":null,"code":"import _toArray from \"/home/esteban/2emeAnnee/S3/devWeb/QuanticGP10/node_modules/@babel/runtime/helpers/esm/toArray.js\";\nimport _defineProperty from \"/home/esteban/2emeAnnee/S3/devWeb/QuanticGP10/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"/home/esteban/2emeAnnee/S3/devWeb/QuanticGP10/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _typeof from \"/home/esteban/2emeAnnee/S3/devWeb/QuanticGP10/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport _slicedToArray from \"/home/esteban/2emeAnnee/S3/devWeb/QuanticGP10/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/home/esteban/2emeAnnee/S3/devWeb/QuanticGP10/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/esteban/2emeAnnee/S3/devWeb/QuanticGP10/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.find.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.ends-with.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.replace-all.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.filter.js\";\nimport \"core-js/modules/esnext.iterator.find.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/esnext.iterator.reduce.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { cloneDeep, isEqual, merge } from 'lodash-es';\nimport { LeafBlot, EmbedBlot, Scope, ParentBlot } from 'parchment';\nimport Delta, { AttributeMap, Op } from 'quill-delta';\nimport Block, { BlockEmbed, bubbleFormats } from '../blots/block.js';\nimport Break from '../blots/break.js';\nimport CursorBlot from '../blots/cursor.js';\nimport TextBlot, { escapeText } from '../blots/text.js';\nimport { Range } from './selection.js';\nvar ASCII = /^[ -~]*$/;\nvar Editor = /*#__PURE__*/function () {\n  function Editor(scroll) {\n    _classCallCheck(this, Editor);\n    this.scroll = scroll;\n    this.delta = this.getDelta();\n  }\n  return _createClass(Editor, [{\n    key: \"applyDelta\",\n    value: function applyDelta(delta) {\n      var _this = this;\n      this.scroll.update();\n      var scrollLength = this.scroll.length();\n      this.scroll.batchStart();\n      var normalizedDelta = normalizeDelta(delta);\n      var deleteDelta = new Delta();\n      var normalizedOps = splitOpLines(normalizedDelta.ops.slice());\n      normalizedOps.reduce(function (index, op) {\n        var length = Op.length(op);\n        var attributes = op.attributes || {};\n        var isImplicitNewlinePrepended = false;\n        var isImplicitNewlineAppended = false;\n        if (op.insert != null) {\n          deleteDelta.retain(length);\n          if (typeof op.insert === 'string') {\n            var text = op.insert;\n            isImplicitNewlineAppended = !text.endsWith('\\n') && (scrollLength <= index || !!_this.scroll.descendant(BlockEmbed, index)[0]);\n            _this.scroll.insertAt(index, text);\n            var _this$scroll$line = _this.scroll.line(index),\n              _this$scroll$line2 = _slicedToArray(_this$scroll$line, 2),\n              line = _this$scroll$line2[0],\n              offset = _this$scroll$line2[1];\n            var formats = merge({}, bubbleFormats(line));\n            if (line instanceof Block) {\n              var _line$descendant = line.descendant(LeafBlot, offset),\n                _line$descendant2 = _slicedToArray(_line$descendant, 1),\n                leaf = _line$descendant2[0];\n              if (leaf) {\n                formats = merge(formats, bubbleFormats(leaf));\n              }\n            }\n            attributes = AttributeMap.diff(formats, attributes) || {};\n          } else if (_typeof(op.insert) === 'object') {\n            var key = Object.keys(op.insert)[0]; // There should only be one key\n            if (key == null) return index;\n            var isInlineEmbed = _this.scroll.query(key, Scope.INLINE) != null;\n            if (isInlineEmbed) {\n              if (scrollLength <= index || !!_this.scroll.descendant(BlockEmbed, index)[0]) {\n                isImplicitNewlineAppended = true;\n              }\n            } else if (index > 0) {\n              var _this$scroll$descenda = _this.scroll.descendant(LeafBlot, index - 1),\n                _this$scroll$descenda2 = _slicedToArray(_this$scroll$descenda, 2),\n                _leaf = _this$scroll$descenda2[0],\n                _offset = _this$scroll$descenda2[1];\n              if (_leaf instanceof TextBlot) {\n                var _text = _leaf.value();\n                if (_text[_offset] !== '\\n') {\n                  isImplicitNewlinePrepended = true;\n                }\n              } else if (_leaf instanceof EmbedBlot && _leaf.statics.scope === Scope.INLINE_BLOT) {\n                isImplicitNewlinePrepended = true;\n              }\n            }\n            _this.scroll.insertAt(index, key, op.insert[key]);\n            if (isInlineEmbed) {\n              var _this$scroll$descenda3 = _this.scroll.descendant(LeafBlot, index),\n                _this$scroll$descenda4 = _slicedToArray(_this$scroll$descenda3, 1),\n                _leaf2 = _this$scroll$descenda4[0];\n              if (_leaf2) {\n                var _formats = merge({}, bubbleFormats(_leaf2));\n                attributes = AttributeMap.diff(_formats, attributes) || {};\n              }\n            }\n          }\n          scrollLength += length;\n        } else {\n          deleteDelta.push(op);\n          if (op.retain !== null && _typeof(op.retain) === 'object') {\n            var _key = Object.keys(op.retain)[0];\n            if (_key == null) return index;\n            _this.scroll.updateEmbedAt(index, _key, op.retain[_key]);\n          }\n        }\n        Object.keys(attributes).forEach(function (name) {\n          _this.scroll.formatAt(index, length, name, attributes[name]);\n        });\n        var prependedLength = isImplicitNewlinePrepended ? 1 : 0;\n        var addedLength = isImplicitNewlineAppended ? 1 : 0;\n        scrollLength += prependedLength + addedLength;\n        deleteDelta.retain(prependedLength);\n        deleteDelta[\"delete\"](addedLength);\n        return index + length + prependedLength + addedLength;\n      }, 0);\n      deleteDelta.reduce(function (index, op) {\n        if (typeof op[\"delete\"] === 'number') {\n          _this.scroll.deleteAt(index, op[\"delete\"]);\n          return index;\n        }\n        return index + Op.length(op);\n      }, 0);\n      this.scroll.batchEnd();\n      this.scroll.optimize();\n      return this.update(normalizedDelta);\n    }\n  }, {\n    key: \"deleteText\",\n    value: function deleteText(index, length) {\n      this.scroll.deleteAt(index, length);\n      return this.update(new Delta().retain(index)[\"delete\"](length));\n    }\n  }, {\n    key: \"formatLine\",\n    value: function formatLine(index, length) {\n      var _this2 = this;\n      var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      this.scroll.update();\n      Object.keys(formats).forEach(function (format) {\n        _this2.scroll.lines(index, Math.max(length, 1)).forEach(function (line) {\n          line.format(format, formats[format]);\n        });\n      });\n      this.scroll.optimize();\n      var delta = new Delta().retain(index).retain(length, cloneDeep(formats));\n      return this.update(delta);\n    }\n  }, {\n    key: \"formatText\",\n    value: function formatText(index, length) {\n      var _this3 = this;\n      var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      Object.keys(formats).forEach(function (format) {\n        _this3.scroll.formatAt(index, length, format, formats[format]);\n      });\n      var delta = new Delta().retain(index).retain(length, cloneDeep(formats));\n      return this.update(delta);\n    }\n  }, {\n    key: \"getContents\",\n    value: function getContents(index, length) {\n      return this.delta.slice(index, index + length);\n    }\n  }, {\n    key: \"getDelta\",\n    value: function getDelta() {\n      return this.scroll.lines().reduce(function (delta, line) {\n        return delta.concat(line.delta());\n      }, new Delta());\n    }\n  }, {\n    key: \"getFormat\",\n    value: function getFormat(index) {\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var lines = [];\n      var leaves = [];\n      if (length === 0) {\n        this.scroll.path(index).forEach(function (path) {\n          var _path = _slicedToArray(path, 1),\n            blot = _path[0];\n          if (blot instanceof Block) {\n            lines.push(blot);\n          } else if (blot instanceof LeafBlot) {\n            leaves.push(blot);\n          }\n        });\n      } else {\n        lines = this.scroll.lines(index, length);\n        leaves = this.scroll.descendants(LeafBlot, index, length);\n      }\n      var _map = [lines, leaves].map(function (blots) {\n          var blot = blots.shift();\n          if (blot == null) return {};\n          var formats = bubbleFormats(blot);\n          while (Object.keys(formats).length > 0) {\n            var _blot = blots.shift();\n            if (_blot == null) return formats;\n            formats = combineFormats(bubbleFormats(_blot), formats);\n          }\n          return formats;\n        }),\n        _map2 = _slicedToArray(_map, 2),\n        lineFormats = _map2[0],\n        leafFormats = _map2[1];\n      return _objectSpread(_objectSpread({}, lineFormats), leafFormats);\n    }\n  }, {\n    key: \"getHTML\",\n    value: function getHTML(index, length) {\n      var _this$scroll$line3 = this.scroll.line(index),\n        _this$scroll$line4 = _slicedToArray(_this$scroll$line3, 2),\n        line = _this$scroll$line4[0],\n        lineOffset = _this$scroll$line4[1];\n      if (line) {\n        var lineLength = line.length();\n        var isWithinLine = line.length() >= lineOffset + length;\n        if (isWithinLine && !(lineOffset === 0 && length === lineLength)) {\n          return convertHTML(line, lineOffset, length, true);\n        }\n        return convertHTML(this.scroll, index, length, true);\n      }\n      return '';\n    }\n  }, {\n    key: \"getText\",\n    value: function getText(index, length) {\n      return this.getContents(index, length).filter(function (op) {\n        return typeof op.insert === 'string';\n      }).map(function (op) {\n        return op.insert;\n      }).join('');\n    }\n  }, {\n    key: \"insertContents\",\n    value: function insertContents(index, contents) {\n      var normalizedDelta = normalizeDelta(contents);\n      var change = new Delta().retain(index).concat(normalizedDelta);\n      this.scroll.insertContents(index, normalizedDelta);\n      return this.update(change);\n    }\n  }, {\n    key: \"insertEmbed\",\n    value: function insertEmbed(index, embed, value) {\n      this.scroll.insertAt(index, embed, value);\n      return this.update(new Delta().retain(index).insert(_defineProperty({}, embed, value)));\n    }\n  }, {\n    key: \"insertText\",\n    value: function insertText(index, text) {\n      var _this4 = this;\n      var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      text = text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n      this.scroll.insertAt(index, text);\n      Object.keys(formats).forEach(function (format) {\n        _this4.scroll.formatAt(index, text.length, format, formats[format]);\n      });\n      return this.update(new Delta().retain(index).insert(text, cloneDeep(formats)));\n    }\n  }, {\n    key: \"isBlank\",\n    value: function isBlank() {\n      if (this.scroll.children.length === 0) return true;\n      if (this.scroll.children.length > 1) return false;\n      var blot = this.scroll.children.head;\n      if ((blot === null || blot === void 0 ? void 0 : blot.statics.blotName) !== Block.blotName) return false;\n      var block = blot;\n      if (block.children.length > 1) return false;\n      return block.children.head instanceof Break;\n    }\n  }, {\n    key: \"removeFormat\",\n    value: function removeFormat(index, length) {\n      var text = this.getText(index, length);\n      var _this$scroll$line5 = this.scroll.line(index + length),\n        _this$scroll$line6 = _slicedToArray(_this$scroll$line5, 2),\n        line = _this$scroll$line6[0],\n        offset = _this$scroll$line6[1];\n      var suffixLength = 0;\n      var suffix = new Delta();\n      if (line != null) {\n        suffixLength = line.length() - offset;\n        suffix = line.delta().slice(offset, offset + suffixLength - 1).insert('\\n');\n      }\n      var contents = this.getContents(index, length + suffixLength);\n      var diff = contents.diff(new Delta().insert(text).concat(suffix));\n      var delta = new Delta().retain(index).concat(diff);\n      return this.applyDelta(delta);\n    }\n  }, {\n    key: \"update\",\n    value: function update(change) {\n      var mutations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var selectionInfo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n      var oldDelta = this.delta;\n      if (mutations.length === 1 && mutations[0].type === 'characterData' &&\n      // @ts-expect-error Fix me later\n      mutations[0].target.data.match(ASCII) && this.scroll.find(mutations[0].target)) {\n        // Optimization for character changes\n        var textBlot = this.scroll.find(mutations[0].target);\n        var formats = bubbleFormats(textBlot);\n        var index = textBlot.offset(this.scroll);\n        // @ts-expect-error Fix me later\n        var oldValue = mutations[0].oldValue.replace(CursorBlot.CONTENTS, '');\n        var oldText = new Delta().insert(oldValue);\n        // @ts-expect-error\n        var newText = new Delta().insert(textBlot.value());\n        var relativeSelectionInfo = selectionInfo && {\n          oldRange: shiftRange(selectionInfo.oldRange, -index),\n          newRange: shiftRange(selectionInfo.newRange, -index)\n        };\n        var diffDelta = new Delta().retain(index).concat(oldText.diff(newText, relativeSelectionInfo));\n        change = diffDelta.reduce(function (delta, op) {\n          if (op.insert) {\n            return delta.insert(op.insert, formats);\n          }\n          return delta.push(op);\n        }, new Delta());\n        this.delta = oldDelta.compose(change);\n      } else {\n        this.delta = this.getDelta();\n        if (!change || !isEqual(oldDelta.compose(change), this.delta)) {\n          change = oldDelta.diff(this.delta, selectionInfo);\n        }\n      }\n      return change;\n    }\n  }]);\n}();\nfunction convertListHTML(items, lastIndent, types) {\n  if (items.length === 0) {\n    var _getListType = getListType(types.pop()),\n      _getListType2 = _slicedToArray(_getListType, 1),\n      _endTag = _getListType2[0];\n    if (lastIndent <= 0) {\n      return \"</li></\".concat(_endTag, \">\");\n    }\n    return \"</li></\".concat(_endTag, \">\").concat(convertListHTML([], lastIndent - 1, types));\n  }\n  var _items = _toArray(items),\n    _items$ = _items[0],\n    child = _items$.child,\n    offset = _items$.offset,\n    length = _items$.length,\n    indent = _items$.indent,\n    type = _items$.type,\n    rest = _items.slice(1);\n  var _getListType3 = getListType(type),\n    _getListType4 = _slicedToArray(_getListType3, 2),\n    tag = _getListType4[0],\n    attribute = _getListType4[1];\n  if (indent > lastIndent) {\n    types.push(type);\n    if (indent === lastIndent + 1) {\n      return \"<\".concat(tag, \"><li\").concat(attribute, \">\").concat(convertHTML(child, offset, length)).concat(convertListHTML(rest, indent, types));\n    }\n    return \"<\".concat(tag, \"><li>\").concat(convertListHTML(items, lastIndent + 1, types));\n  }\n  var previousType = types[types.length - 1];\n  if (indent === lastIndent && type === previousType) {\n    return \"</li><li\".concat(attribute, \">\").concat(convertHTML(child, offset, length)).concat(convertListHTML(rest, indent, types));\n  }\n  var _getListType5 = getListType(types.pop()),\n    _getListType6 = _slicedToArray(_getListType5, 1),\n    endTag = _getListType6[0];\n  return \"</li></\".concat(endTag, \">\").concat(convertListHTML(items, lastIndent - 1, types));\n}\nfunction convertHTML(blot, index, length) {\n  var isRoot = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  if ('html' in blot && typeof blot.html === 'function') {\n    return blot.html(index, length);\n  }\n  if (blot instanceof TextBlot) {\n    var escapedText = escapeText(blot.value().slice(index, index + length));\n    return escapedText.replaceAll(' ', '&nbsp;');\n  }\n  if (blot instanceof ParentBlot) {\n    // TODO fix API\n    if (blot.statics.blotName === 'list-container') {\n      var items = [];\n      blot.children.forEachAt(index, length, function (child, offset, childLength) {\n        var formats = 'formats' in child && typeof child.formats === 'function' ? child.formats() : {};\n        items.push({\n          child: child,\n          offset: offset,\n          length: childLength,\n          indent: formats.indent || 0,\n          type: formats.list\n        });\n      });\n      return convertListHTML(items, -1, []);\n    }\n    var parts = [];\n    blot.children.forEachAt(index, length, function (child, offset, childLength) {\n      parts.push(convertHTML(child, offset, childLength));\n    });\n    if (isRoot || blot.statics.blotName === 'list') {\n      return parts.join('');\n    }\n    var _blot$domNode = blot.domNode,\n      outerHTML = _blot$domNode.outerHTML,\n      innerHTML = _blot$domNode.innerHTML;\n    var _outerHTML$split = outerHTML.split(\">\".concat(innerHTML, \"<\")),\n      _outerHTML$split2 = _slicedToArray(_outerHTML$split, 2),\n      start = _outerHTML$split2[0],\n      end = _outerHTML$split2[1];\n    // TODO cleanup\n    if (start === '<table') {\n      return \"<table style=\\\"border: 1px solid #000;\\\">\".concat(parts.join(''), \"<\").concat(end);\n    }\n    return \"\".concat(start, \">\").concat(parts.join(''), \"<\").concat(end);\n  }\n  return blot.domNode instanceof Element ? blot.domNode.outerHTML : '';\n}\nfunction combineFormats(formats, combined) {\n  return Object.keys(combined).reduce(function (merged, name) {\n    if (formats[name] == null) return merged;\n    var combinedValue = combined[name];\n    if (combinedValue === formats[name]) {\n      merged[name] = combinedValue;\n    } else if (Array.isArray(combinedValue)) {\n      if (combinedValue.indexOf(formats[name]) < 0) {\n        merged[name] = combinedValue.concat([formats[name]]);\n      } else {\n        // If style already exists, don't add to an array, but don't lose other styles\n        merged[name] = combinedValue;\n      }\n    } else {\n      merged[name] = [combinedValue, formats[name]];\n    }\n    return merged;\n  }, {});\n}\nfunction getListType(type) {\n  var tag = type === 'ordered' ? 'ol' : 'ul';\n  switch (type) {\n    case 'checked':\n      return [tag, ' data-list=\"checked\"'];\n    case 'unchecked':\n      return [tag, ' data-list=\"unchecked\"'];\n    default:\n      return [tag, ''];\n  }\n}\nfunction normalizeDelta(delta) {\n  return delta.reduce(function (normalizedDelta, op) {\n    if (typeof op.insert === 'string') {\n      var text = op.insert.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n      return normalizedDelta.insert(text, op.attributes);\n    }\n    return normalizedDelta.push(op);\n  }, new Delta());\n}\nfunction shiftRange(_ref, amount) {\n  var index = _ref.index,\n    length = _ref.length;\n  return new Range(index + amount, length);\n}\nfunction splitOpLines(ops) {\n  var split = [];\n  ops.forEach(function (op) {\n    if (typeof op.insert === 'string') {\n      var lines = op.insert.split('\\n');\n      lines.forEach(function (line, index) {\n        if (index) split.push({\n          insert: '\\n',\n          attributes: op.attributes\n        });\n        if (line) split.push({\n          insert: line,\n          attributes: op.attributes\n        });\n      });\n    } else {\n      split.push(op);\n    }\n  });\n  return split;\n}\nexport default Editor;","map":{"version":3,"names":["cloneDeep","isEqual","merge","LeafBlot","EmbedBlot","Scope","ParentBlot","Delta","AttributeMap","Op","Block","BlockEmbed","bubbleFormats","Break","CursorBlot","TextBlot","escapeText","Range","ASCII","Editor","scroll","_classCallCheck","delta","getDelta","_createClass","key","value","applyDelta","_this","update","scrollLength","length","batchStart","normalizedDelta","normalizeDelta","deleteDelta","normalizedOps","splitOpLines","ops","slice","reduce","index","op","attributes","isImplicitNewlinePrepended","isImplicitNewlineAppended","insert","retain","text","endsWith","descendant","insertAt","_this$scroll$line","line","_this$scroll$line2","_slicedToArray","offset","formats","_line$descendant","_line$descendant2","leaf","diff","_typeof","Object","keys","isInlineEmbed","query","INLINE","_this$scroll$descenda","_this$scroll$descenda2","statics","scope","INLINE_BLOT","_this$scroll$descenda3","_this$scroll$descenda4","push","updateEmbedAt","forEach","name","formatAt","prependedLength","addedLength","deleteAt","batchEnd","optimize","deleteText","formatLine","_this2","arguments","undefined","format","lines","Math","max","formatText","_this3","getContents","concat","getFormat","leaves","path","_path","blot","descendants","_map","map","blots","shift","combineFormats","_map2","lineFormats","leafFormats","_objectSpread","getHTML","_this$scroll$line3","_this$scroll$line4","lineOffset","lineLength","isWithinLine","convertHTML","getText","filter","join","insertContents","contents","change","insertEmbed","embed","_defineProperty","insertText","_this4","replace","isBlank","children","head","blotName","block","removeFormat","_this$scroll$line5","_this$scroll$line6","suffixLength","suffix","mutations","selectionInfo","oldDelta","type","target","data","match","find","textBlot","oldValue","CONTENTS","oldText","newText","relativeSelectionInfo","oldRange","shiftRange","newRange","diffDelta","compose","convertListHTML","items","lastIndent","types","_getListType","getListType","pop","_getListType2","endTag","_items","_toArray","_items$","child","indent","rest","_getListType3","_getListType4","tag","attribute","previousType","_getListType5","_getListType6","isRoot","html","escapedText","replaceAll","forEachAt","childLength","list","parts","_blot$domNode","domNode","outerHTML","innerHTML","_outerHTML$split","split","_outerHTML$split2","start","end","Element","combined","merged","combinedValue","Array","isArray","indexOf","_ref","amount"],"sources":["../../src/core/editor.ts"],"sourcesContent":["import { cloneDeep, isEqual, merge } from 'lodash-es';\nimport { LeafBlot, EmbedBlot, Scope, ParentBlot } from 'parchment';\nimport type { Blot } from 'parchment';\nimport Delta, { AttributeMap, Op } from 'quill-delta';\nimport Block, { BlockEmbed, bubbleFormats } from '../blots/block.js';\nimport Break from '../blots/break.js';\nimport CursorBlot from '../blots/cursor.js';\nimport type Scroll from '../blots/scroll.js';\nimport TextBlot, { escapeText } from '../blots/text.js';\nimport { Range } from './selection.js';\n\nconst ASCII = /^[ -~]*$/;\n\ntype SelectionInfo = {\n  newRange: Range;\n  oldRange: Range;\n};\n\nclass Editor {\n  scroll: Scroll;\n  delta: Delta;\n\n  constructor(scroll: Scroll) {\n    this.scroll = scroll;\n    this.delta = this.getDelta();\n  }\n\n  applyDelta(delta: Delta): Delta {\n    this.scroll.update();\n    let scrollLength = this.scroll.length();\n    this.scroll.batchStart();\n    const normalizedDelta = normalizeDelta(delta);\n    const deleteDelta = new Delta();\n    const normalizedOps = splitOpLines(normalizedDelta.ops.slice());\n    normalizedOps.reduce((index, op) => {\n      const length = Op.length(op);\n      let attributes = op.attributes || {};\n      let isImplicitNewlinePrepended = false;\n      let isImplicitNewlineAppended = false;\n      if (op.insert != null) {\n        deleteDelta.retain(length);\n        if (typeof op.insert === 'string') {\n          const text = op.insert;\n          isImplicitNewlineAppended =\n            !text.endsWith('\\n') &&\n            (scrollLength <= index ||\n              !!this.scroll.descendant(BlockEmbed, index)[0]);\n          this.scroll.insertAt(index, text);\n          const [line, offset] = this.scroll.line(index);\n          let formats = merge({}, bubbleFormats(line));\n          if (line instanceof Block) {\n            const [leaf] = line.descendant(LeafBlot, offset);\n            if (leaf) {\n              formats = merge(formats, bubbleFormats(leaf));\n            }\n          }\n          attributes = AttributeMap.diff(formats, attributes) || {};\n        } else if (typeof op.insert === 'object') {\n          const key = Object.keys(op.insert)[0]; // There should only be one key\n          if (key == null) return index;\n          const isInlineEmbed = this.scroll.query(key, Scope.INLINE) != null;\n          if (isInlineEmbed) {\n            if (\n              scrollLength <= index ||\n              !!this.scroll.descendant(BlockEmbed, index)[0]\n            ) {\n              isImplicitNewlineAppended = true;\n            }\n          } else if (index > 0) {\n            const [leaf, offset] = this.scroll.descendant(LeafBlot, index - 1);\n            if (leaf instanceof TextBlot) {\n              const text = leaf.value();\n              if (text[offset] !== '\\n') {\n                isImplicitNewlinePrepended = true;\n              }\n            } else if (\n              leaf instanceof EmbedBlot &&\n              leaf.statics.scope === Scope.INLINE_BLOT\n            ) {\n              isImplicitNewlinePrepended = true;\n            }\n          }\n          this.scroll.insertAt(index, key, op.insert[key]);\n\n          if (isInlineEmbed) {\n            const [leaf] = this.scroll.descendant(LeafBlot, index);\n            if (leaf) {\n              const formats = merge({}, bubbleFormats(leaf));\n              attributes = AttributeMap.diff(formats, attributes) || {};\n            }\n          }\n        }\n        scrollLength += length;\n      } else {\n        deleteDelta.push(op);\n\n        if (op.retain !== null && typeof op.retain === 'object') {\n          const key = Object.keys(op.retain)[0];\n          if (key == null) return index;\n          this.scroll.updateEmbedAt(index, key, op.retain[key]);\n        }\n      }\n      Object.keys(attributes).forEach((name) => {\n        this.scroll.formatAt(index, length, name, attributes[name]);\n      });\n      const prependedLength = isImplicitNewlinePrepended ? 1 : 0;\n      const addedLength = isImplicitNewlineAppended ? 1 : 0;\n      scrollLength += prependedLength + addedLength;\n      deleteDelta.retain(prependedLength);\n      deleteDelta.delete(addedLength);\n      return index + length + prependedLength + addedLength;\n    }, 0);\n    deleteDelta.reduce((index, op) => {\n      if (typeof op.delete === 'number') {\n        this.scroll.deleteAt(index, op.delete);\n        return index;\n      }\n      return index + Op.length(op);\n    }, 0);\n    this.scroll.batchEnd();\n    this.scroll.optimize();\n    return this.update(normalizedDelta);\n  }\n\n  deleteText(index: number, length: number): Delta {\n    this.scroll.deleteAt(index, length);\n    return this.update(new Delta().retain(index).delete(length));\n  }\n\n  formatLine(\n    index: number,\n    length: number,\n    formats: Record<string, unknown> = {},\n  ): Delta {\n    this.scroll.update();\n    Object.keys(formats).forEach((format) => {\n      this.scroll.lines(index, Math.max(length, 1)).forEach((line) => {\n        line.format(format, formats[format]);\n      });\n    });\n    this.scroll.optimize();\n    const delta = new Delta().retain(index).retain(length, cloneDeep(formats));\n    return this.update(delta);\n  }\n\n  formatText(\n    index: number,\n    length: number,\n    formats: Record<string, unknown> = {},\n  ): Delta {\n    Object.keys(formats).forEach((format) => {\n      this.scroll.formatAt(index, length, format, formats[format]);\n    });\n    const delta = new Delta().retain(index).retain(length, cloneDeep(formats));\n    return this.update(delta);\n  }\n\n  getContents(index: number, length: number): Delta {\n    return this.delta.slice(index, index + length);\n  }\n\n  getDelta(): Delta {\n    return this.scroll.lines().reduce((delta, line) => {\n      return delta.concat(line.delta());\n    }, new Delta());\n  }\n\n  getFormat(index: number, length = 0): Record<string, unknown> {\n    let lines: (Block | BlockEmbed)[] = [];\n    let leaves: LeafBlot[] = [];\n    if (length === 0) {\n      this.scroll.path(index).forEach((path) => {\n        const [blot] = path;\n        if (blot instanceof Block) {\n          lines.push(blot);\n        } else if (blot instanceof LeafBlot) {\n          leaves.push(blot);\n        }\n      });\n    } else {\n      lines = this.scroll.lines(index, length);\n      leaves = this.scroll.descendants(LeafBlot, index, length);\n    }\n    const [lineFormats, leafFormats] = [lines, leaves].map((blots) => {\n      const blot = blots.shift();\n      if (blot == null) return {};\n      let formats = bubbleFormats(blot);\n      while (Object.keys(formats).length > 0) {\n        const blot = blots.shift();\n        if (blot == null) return formats;\n        formats = combineFormats(bubbleFormats(blot), formats);\n      }\n      return formats;\n    });\n    return { ...lineFormats, ...leafFormats };\n  }\n\n  getHTML(index: number, length: number): string {\n    const [line, lineOffset] = this.scroll.line(index);\n    if (line) {\n      const lineLength = line.length();\n      const isWithinLine = line.length() >= lineOffset + length;\n      if (isWithinLine && !(lineOffset === 0 && length === lineLength)) {\n        return convertHTML(line, lineOffset, length, true);\n      }\n      return convertHTML(this.scroll, index, length, true);\n    }\n    return '';\n  }\n\n  getText(index: number, length: number): string {\n    return this.getContents(index, length)\n      .filter((op) => typeof op.insert === 'string')\n      .map((op) => op.insert)\n      .join('');\n  }\n\n  insertContents(index: number, contents: Delta): Delta {\n    const normalizedDelta = normalizeDelta(contents);\n    const change = new Delta().retain(index).concat(normalizedDelta);\n    this.scroll.insertContents(index, normalizedDelta);\n    return this.update(change);\n  }\n\n  insertEmbed(index: number, embed: string, value: unknown): Delta {\n    this.scroll.insertAt(index, embed, value);\n    return this.update(new Delta().retain(index).insert({ [embed]: value }));\n  }\n\n  insertText(\n    index: number,\n    text: string,\n    formats: Record<string, unknown> = {},\n  ): Delta {\n    text = text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n    this.scroll.insertAt(index, text);\n    Object.keys(formats).forEach((format) => {\n      this.scroll.formatAt(index, text.length, format, formats[format]);\n    });\n    return this.update(\n      new Delta().retain(index).insert(text, cloneDeep(formats)),\n    );\n  }\n\n  isBlank(): boolean {\n    if (this.scroll.children.length === 0) return true;\n    if (this.scroll.children.length > 1) return false;\n    const blot = this.scroll.children.head;\n    if (blot?.statics.blotName !== Block.blotName) return false;\n    const block = blot as Block;\n    if (block.children.length > 1) return false;\n    return block.children.head instanceof Break;\n  }\n\n  removeFormat(index: number, length: number): Delta {\n    const text = this.getText(index, length);\n    const [line, offset] = this.scroll.line(index + length);\n    let suffixLength = 0;\n    let suffix = new Delta();\n    if (line != null) {\n      suffixLength = line.length() - offset;\n      suffix = line\n        .delta()\n        .slice(offset, offset + suffixLength - 1)\n        .insert('\\n');\n    }\n    const contents = this.getContents(index, length + suffixLength);\n    const diff = contents.diff(new Delta().insert(text).concat(suffix));\n    const delta = new Delta().retain(index).concat(diff);\n    return this.applyDelta(delta);\n  }\n\n  update(\n    change: Delta | null,\n    mutations: MutationRecord[] = [],\n    selectionInfo: SelectionInfo | undefined = undefined,\n  ): Delta {\n    const oldDelta = this.delta;\n    if (\n      mutations.length === 1 &&\n      mutations[0].type === 'characterData' &&\n      // @ts-expect-error Fix me later\n      mutations[0].target.data.match(ASCII) &&\n      this.scroll.find(mutations[0].target)\n    ) {\n      // Optimization for character changes\n      const textBlot = this.scroll.find(mutations[0].target) as Blot;\n      const formats = bubbleFormats(textBlot);\n      const index = textBlot.offset(this.scroll);\n      // @ts-expect-error Fix me later\n      const oldValue = mutations[0].oldValue.replace(CursorBlot.CONTENTS, '');\n      const oldText = new Delta().insert(oldValue);\n      // @ts-expect-error\n      const newText = new Delta().insert(textBlot.value());\n      const relativeSelectionInfo = selectionInfo && {\n        oldRange: shiftRange(selectionInfo.oldRange, -index),\n        newRange: shiftRange(selectionInfo.newRange, -index),\n      };\n      const diffDelta = new Delta()\n        .retain(index)\n        .concat(oldText.diff(newText, relativeSelectionInfo));\n      change = diffDelta.reduce((delta, op) => {\n        if (op.insert) {\n          return delta.insert(op.insert, formats);\n        }\n        return delta.push(op);\n      }, new Delta());\n      this.delta = oldDelta.compose(change);\n    } else {\n      this.delta = this.getDelta();\n      if (!change || !isEqual(oldDelta.compose(change), this.delta)) {\n        change = oldDelta.diff(this.delta, selectionInfo);\n      }\n    }\n    return change;\n  }\n}\n\ninterface ListItem {\n  child: Blot;\n  offset: number;\n  length: number;\n  indent: number;\n  type: string;\n}\nfunction convertListHTML(\n  items: ListItem[],\n  lastIndent: number,\n  types: string[],\n): string {\n  if (items.length === 0) {\n    const [endTag] = getListType(types.pop());\n    if (lastIndent <= 0) {\n      return `</li></${endTag}>`;\n    }\n    return `</li></${endTag}>${convertListHTML([], lastIndent - 1, types)}`;\n  }\n  const [{ child, offset, length, indent, type }, ...rest] = items;\n  const [tag, attribute] = getListType(type);\n  if (indent > lastIndent) {\n    types.push(type);\n    if (indent === lastIndent + 1) {\n      return `<${tag}><li${attribute}>${convertHTML(\n        child,\n        offset,\n        length,\n      )}${convertListHTML(rest, indent, types)}`;\n    }\n    return `<${tag}><li>${convertListHTML(items, lastIndent + 1, types)}`;\n  }\n  const previousType = types[types.length - 1];\n  if (indent === lastIndent && type === previousType) {\n    return `</li><li${attribute}>${convertHTML(\n      child,\n      offset,\n      length,\n    )}${convertListHTML(rest, indent, types)}`;\n  }\n  const [endTag] = getListType(types.pop());\n  return `</li></${endTag}>${convertListHTML(items, lastIndent - 1, types)}`;\n}\n\nfunction convertHTML(\n  blot: Blot,\n  index: number,\n  length: number,\n  isRoot = false,\n): string {\n  if ('html' in blot && typeof blot.html === 'function') {\n    return blot.html(index, length);\n  }\n  if (blot instanceof TextBlot) {\n    const escapedText = escapeText(blot.value().slice(index, index + length));\n    return escapedText.replaceAll(' ', '&nbsp;');\n  }\n  if (blot instanceof ParentBlot) {\n    // TODO fix API\n    if (blot.statics.blotName === 'list-container') {\n      const items: any[] = [];\n      blot.children.forEachAt(index, length, (child, offset, childLength) => {\n        const formats =\n          'formats' in child && typeof child.formats === 'function'\n            ? child.formats()\n            : {};\n        items.push({\n          child,\n          offset,\n          length: childLength,\n          indent: formats.indent || 0,\n          type: formats.list,\n        });\n      });\n      return convertListHTML(items, -1, []);\n    }\n    const parts: string[] = [];\n    blot.children.forEachAt(index, length, (child, offset, childLength) => {\n      parts.push(convertHTML(child, offset, childLength));\n    });\n    if (isRoot || blot.statics.blotName === 'list') {\n      return parts.join('');\n    }\n    const { outerHTML, innerHTML } = blot.domNode as Element;\n    const [start, end] = outerHTML.split(`>${innerHTML}<`);\n    // TODO cleanup\n    if (start === '<table') {\n      return `<table style=\"border: 1px solid #000;\">${parts.join('')}<${end}`;\n    }\n    return `${start}>${parts.join('')}<${end}`;\n  }\n  return blot.domNode instanceof Element ? blot.domNode.outerHTML : '';\n}\n\nfunction combineFormats(\n  formats: Record<string, unknown>,\n  combined: Record<string, unknown>,\n): Record<string, unknown> {\n  return Object.keys(combined).reduce(\n    (merged, name) => {\n      if (formats[name] == null) return merged;\n      const combinedValue = combined[name];\n      if (combinedValue === formats[name]) {\n        merged[name] = combinedValue;\n      } else if (Array.isArray(combinedValue)) {\n        if (combinedValue.indexOf(formats[name]) < 0) {\n          merged[name] = combinedValue.concat([formats[name]]);\n        } else {\n          // If style already exists, don't add to an array, but don't lose other styles\n          merged[name] = combinedValue;\n        }\n      } else {\n        merged[name] = [combinedValue, formats[name]];\n      }\n      return merged;\n    },\n    {} as Record<string, unknown>,\n  );\n}\n\nfunction getListType(type: string | undefined) {\n  const tag = type === 'ordered' ? 'ol' : 'ul';\n  switch (type) {\n    case 'checked':\n      return [tag, ' data-list=\"checked\"'];\n    case 'unchecked':\n      return [tag, ' data-list=\"unchecked\"'];\n    default:\n      return [tag, ''];\n  }\n}\n\nfunction normalizeDelta(delta: Delta) {\n  return delta.reduce((normalizedDelta, op) => {\n    if (typeof op.insert === 'string') {\n      const text = op.insert.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n      return normalizedDelta.insert(text, op.attributes);\n    }\n    return normalizedDelta.push(op);\n  }, new Delta());\n}\n\nfunction shiftRange({ index, length }: Range, amount: number) {\n  return new Range(index + amount, length);\n}\n\nfunction splitOpLines(ops: Op[]) {\n  const split: Op[] = [];\n  ops.forEach((op) => {\n    if (typeof op.insert === 'string') {\n      const lines = op.insert.split('\\n');\n      lines.forEach((line, index) => {\n        if (index) split.push({ insert: '\\n', attributes: op.attributes });\n        if (line) split.push({ insert: line, attributes: op.attributes });\n      });\n    } else {\n      split.push(op);\n    }\n  });\n\n  return split;\n}\n\nexport default Editor;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
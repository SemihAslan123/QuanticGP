{"ast":null,"code":"import _assertThisInitialized from \"/home/esteban/2emeAnnee/S3/devWeb/QuanticGP10/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _superPropGet from \"/home/esteban/2emeAnnee/S3/devWeb/QuanticGP10/node_modules/@babel/runtime/helpers/esm/superPropGet.js\";\nimport _slicedToArray from \"/home/esteban/2emeAnnee/S3/devWeb/QuanticGP10/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"/home/esteban/2emeAnnee/S3/devWeb/QuanticGP10/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _defineProperty from \"/home/esteban/2emeAnnee/S3/devWeb/QuanticGP10/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _callSuper from \"/home/esteban/2emeAnnee/S3/devWeb/QuanticGP10/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/home/esteban/2emeAnnee/S3/devWeb/QuanticGP10/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _wrapNativeSuper from \"/home/esteban/2emeAnnee/S3/devWeb/QuanticGP10/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\nimport _readOnlyError from \"/home/esteban/2emeAnnee/S3/devWeb/QuanticGP10/node_modules/@babel/runtime/helpers/esm/readOnlyError.js\";\nimport _classCallCheck from \"/home/esteban/2emeAnnee/S3/devWeb/QuanticGP10/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/esteban/2emeAnnee/S3/devWeb/QuanticGP10/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.find.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.array.reverse.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.parse-int.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.string.trim.js\";\nimport \"core-js/modules/es.weak-map.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.filter.js\";\nimport \"core-js/modules/esnext.iterator.find.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/esnext.iterator.reduce.js\";\nimport \"core-js/modules/esnext.iterator.some.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nvar Scope = /* @__PURE__ */function (Scope2) {\n  return Scope2[Scope2.TYPE = 3] = \"TYPE\", Scope2[Scope2.LEVEL = 12] = \"LEVEL\", Scope2[Scope2.ATTRIBUTE = 13] = \"ATTRIBUTE\", Scope2[Scope2.BLOT = 14] = \"BLOT\", Scope2[Scope2.INLINE = 7] = \"INLINE\", Scope2[Scope2.BLOCK = 11] = \"BLOCK\", Scope2[Scope2.BLOCK_BLOT = 10] = \"BLOCK_BLOT\", Scope2[Scope2.INLINE_BLOT = 6] = \"INLINE_BLOT\", Scope2[Scope2.BLOCK_ATTRIBUTE = 9] = \"BLOCK_ATTRIBUTE\", Scope2[Scope2.INLINE_ATTRIBUTE = 5] = \"INLINE_ATTRIBUTE\", Scope2[Scope2.ANY = 15] = \"ANY\", Scope2;\n}(Scope || {});\nvar Attributor = /*#__PURE__*/function () {\n  function Attributor(attrName, keyName) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    _classCallCheck(this, Attributor);\n    this.attrName = attrName, this.keyName = keyName;\n    var attributeBit = Scope.TYPE & Scope.ATTRIBUTE;\n    this.scope = options.scope != null ?\n    // Ignore type bits, force attribute bit\n    options.scope & Scope.LEVEL | attributeBit : Scope.ATTRIBUTE, options.whitelist != null && (this.whitelist = options.whitelist);\n  }\n  return _createClass(Attributor, [{\n    key: \"add\",\n    value: function add(node, value) {\n      return this.canAdd(node, value) ? (node.setAttribute(this.keyName, value), !0) : !1;\n    }\n  }, {\n    key: \"canAdd\",\n    value: function canAdd(_node, value) {\n      return this.whitelist == null ? !0 : typeof value == \"string\" ? this.whitelist.indexOf(value.replace(/[\"']/g, \"\")) > -1 : this.whitelist.indexOf(value) > -1;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(node) {\n      node.removeAttribute(this.keyName);\n    }\n  }, {\n    key: \"value\",\n    value: function value(node) {\n      var value = node.getAttribute(this.keyName);\n      return this.canAdd(node, value) && value ? value : \"\";\n    }\n  }], [{\n    key: \"keys\",\n    value: function keys(node) {\n      return Array.from(node.attributes).map(function (item) {\n        return item.name;\n      });\n    }\n  }]);\n}();\nvar ParchmentError = /*#__PURE__*/function (_Error) {\n  function ParchmentError(message) {\n    var _this;\n    _classCallCheck(this, ParchmentError);\n    message = \"[Parchment] \" + message, _this = _callSuper(this, ParchmentError, [message]), _this.message = message, _this.name = _this.constructor.name;\n    return _this;\n  }\n  _inherits(ParchmentError, _Error);\n  return _createClass(ParchmentError);\n}(/*#__PURE__*/_wrapNativeSuper(Error));\nvar _Registry = /*#__PURE__*/function () {\n  function _Registry() {\n    _classCallCheck(this, _Registry);\n    this.attributes = {}, this.classes = {}, this.tags = {}, this.types = {};\n  }\n  return _createClass(_Registry, [{\n    key: \"create\",\n    value: function create(scroll, input, value) {\n      var match2 = this.query(input);\n      if (match2 == null) throw new ParchmentError(\"Unable to create \".concat(input, \" blot\"));\n      var blotClass = match2,\n        node =\n        // @ts-expect-error Fix me later\n        input instanceof Node || input.nodeType === Node.TEXT_NODE ? input : blotClass.create(value),\n        blot = new blotClass(scroll, node, value);\n      return _Registry.blots.set(blot.domNode, blot), blot;\n    }\n  }, {\n    key: \"find\",\n    value: function find(node) {\n      var bubble = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n      return _Registry.find(node, bubble);\n    }\n  }, {\n    key: \"query\",\n    value: function query(_query) {\n      var _this2 = this;\n      var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Scope.ANY;\n      var match2;\n      return typeof _query == \"string\" ? match2 = this.types[_query] || this.attributes[_query] : _query instanceof Text || _query.nodeType === Node.TEXT_NODE ? match2 = this.types.text : typeof _query == \"number\" ? _query & Scope.LEVEL & Scope.BLOCK ? match2 = this.types.block : _query & Scope.LEVEL & Scope.INLINE && (match2 = this.types.inline) : _query instanceof Element && ((_query.getAttribute(\"class\") || \"\").split(/\\s+/).some(function (name) {\n        return match2 = _this2.classes[name], !!match2;\n      }), match2 = match2 || this.tags[_query.tagName]), match2 == null ? null : \"scope\" in match2 && scope & Scope.LEVEL & match2.scope && scope & Scope.TYPE & match2.scope ? match2 : null;\n    }\n  }, {\n    key: \"register\",\n    value: function register() {\n      var _this3 = this;\n      for (var _len = arguments.length, definitions = new Array(_len), _key = 0; _key < _len; _key++) {\n        definitions[_key] = arguments[_key];\n      }\n      return definitions.map(function (definition) {\n        var isBlot = \"blotName\" in definition,\n          isAttr = \"attrName\" in definition;\n        if (!isBlot && !isAttr) throw new ParchmentError(\"Invalid definition\");\n        if (isBlot && definition.blotName === \"abstract\") throw new ParchmentError(\"Cannot register abstract class\");\n        var key = isBlot ? definition.blotName : isAttr ? definition.attrName : void 0;\n        return _this3.types[key] = definition, isAttr ? typeof definition.keyName == \"string\" && (_this3.attributes[definition.keyName] = definition) : isBlot && (definition.className && (_this3.classes[definition.className] = definition), definition.tagName && (Array.isArray(definition.tagName) ? definition.tagName = definition.tagName.map(function (tagName) {\n          return tagName.toUpperCase();\n        }) : definition.tagName = definition.tagName.toUpperCase(), (Array.isArray(definition.tagName) ? definition.tagName : [definition.tagName]).forEach(function (tag) {\n          (_this3.tags[tag] == null || definition.className == null) && (_this3.tags[tag] = definition);\n        }))), definition;\n      });\n    }\n  }], [{\n    key: \"find\",\n    value: function find(node) {\n      var bubble = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n      if (node == null) return null;\n      if (this.blots.has(node)) return this.blots.get(node) || null;\n      if (bubble) {\n        var parentNode = null;\n        try {\n          parentNode = node.parentNode;\n        } catch (_unused) {\n          return null;\n        }\n        return this.find(parentNode, bubble);\n      }\n      return null;\n    }\n  }]);\n}();\n_Registry.blots = /* @__PURE__ */new WeakMap();\nvar Registry = _Registry;\nfunction match(node, prefix) {\n  return (node.getAttribute(\"class\") || \"\").split(/\\s+/).filter(function (name) {\n    return name.indexOf(\"\".concat(prefix, \"-\")) === 0;\n  });\n}\nvar ClassAttributor = /*#__PURE__*/function (_Attributor) {\n  function ClassAttributor() {\n    _classCallCheck(this, ClassAttributor);\n    return _callSuper(this, ClassAttributor, arguments);\n  }\n  _inherits(ClassAttributor, _Attributor);\n  return _createClass(ClassAttributor, [{\n    key: \"add\",\n    value: function add(node, value) {\n      return this.canAdd(node, value) ? (this.remove(node), node.classList.add(\"\".concat(this.keyName, \"-\").concat(value)), !0) : !1;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(node) {\n      match(node, this.keyName).forEach(function (name) {\n        node.classList.remove(name);\n      }), node.classList.length === 0 && node.removeAttribute(\"class\");\n    }\n  }, {\n    key: \"value\",\n    value: function value(node) {\n      var value = (match(node, this.keyName)[0] || \"\").slice(this.keyName.length + 1);\n      return this.canAdd(node, value) ? value : \"\";\n    }\n  }], [{\n    key: \"keys\",\n    value: function keys(node) {\n      return (node.getAttribute(\"class\") || \"\").split(/\\s+/).map(function (name) {\n        return name.split(\"-\").slice(0, -1).join(\"-\");\n      });\n    }\n  }]);\n}(Attributor);\nvar ClassAttributor$1 = ClassAttributor;\nfunction camelize(name) {\n  var parts = name.split(\"-\"),\n    rest = parts.slice(1).map(function (part) {\n      return part[0].toUpperCase() + part.slice(1);\n    }).join(\"\");\n  return parts[0] + rest;\n}\nvar StyleAttributor = /*#__PURE__*/function (_Attributor2) {\n  function StyleAttributor() {\n    _classCallCheck(this, StyleAttributor);\n    return _callSuper(this, StyleAttributor, arguments);\n  }\n  _inherits(StyleAttributor, _Attributor2);\n  return _createClass(StyleAttributor, [{\n    key: \"add\",\n    value: function add(node, value) {\n      return this.canAdd(node, value) ? (node.style[camelize(this.keyName)] = value, !0) : !1;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(node) {\n      node.style[camelize(this.keyName)] = \"\", node.getAttribute(\"style\") || node.removeAttribute(\"style\");\n    }\n  }, {\n    key: \"value\",\n    value: function value(node) {\n      var value = node.style[camelize(this.keyName)];\n      return this.canAdd(node, value) ? value : \"\";\n    }\n  }], [{\n    key: \"keys\",\n    value: function keys(node) {\n      return (node.getAttribute(\"style\") || \"\").split(\";\").map(function (value) {\n        return value.split(\":\")[0].trim();\n      });\n    }\n  }]);\n}(Attributor);\nvar StyleAttributor$1 = StyleAttributor;\nvar AttributorStore = /*#__PURE__*/function () {\n  function AttributorStore(domNode) {\n    _classCallCheck(this, AttributorStore);\n    this.attributes = {}, this.domNode = domNode, this.build();\n  }\n  return _createClass(AttributorStore, [{\n    key: \"attribute\",\n    value: function attribute(_attribute, value) {\n      value ? _attribute.add(this.domNode, value) && (_attribute.value(this.domNode) != null ? this.attributes[_attribute.attrName] = _attribute : delete this.attributes[_attribute.attrName]) : (_attribute.remove(this.domNode), delete this.attributes[_attribute.attrName]);\n    }\n  }, {\n    key: \"build\",\n    value: function build() {\n      var _this4 = this;\n      this.attributes = {};\n      var blot = Registry.find(this.domNode);\n      if (blot == null) return;\n      var attributes = Attributor.keys(this.domNode),\n        classes = ClassAttributor$1.keys(this.domNode),\n        styles = StyleAttributor$1.keys(this.domNode);\n      attributes.concat(classes).concat(styles).forEach(function (name) {\n        var attr = blot.scroll.query(name, Scope.ATTRIBUTE);\n        attr instanceof Attributor && (_this4.attributes[attr.attrName] = attr);\n      });\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(target) {\n      var _this5 = this;\n      Object.keys(this.attributes).forEach(function (key) {\n        var value = _this5.attributes[key].value(_this5.domNode);\n        target.format(key, value);\n      });\n    }\n  }, {\n    key: \"move\",\n    value: function move(target) {\n      var _this6 = this;\n      this.copy(target), Object.keys(this.attributes).forEach(function (key) {\n        _this6.attributes[key].remove(_this6.domNode);\n      }), this.attributes = {};\n    }\n  }, {\n    key: \"values\",\n    value: function values() {\n      var _this7 = this;\n      return Object.keys(this.attributes).reduce(function (attributes, name) {\n        return attributes[name] = _this7.attributes[name].value(_this7.domNode), attributes;\n      }, {});\n    }\n  }]);\n}();\nvar AttributorStore$1 = AttributorStore,\n  _ShadowBlot = /*#__PURE__*/function () {\n    function _ShadowBlot(scroll, domNode) {\n      _classCallCheck(this, _ShadowBlot);\n      this.scroll = scroll, this.domNode = domNode, Registry.blots.set(domNode, this), this.prev = null, this.next = null;\n    }\n    return _createClass(_ShadowBlot, [{\n      key: \"statics\",\n      get:\n      // Hack for accessing inherited static methods\n      function get() {\n        return this.constructor;\n      }\n    }, {\n      key: \"attach\",\n      value: function attach() {}\n    }, {\n      key: \"clone\",\n      value: function clone() {\n        var domNode = this.domNode.cloneNode(!1);\n        return this.scroll.create(domNode);\n      }\n    }, {\n      key: \"detach\",\n      value: function detach() {\n        this.parent != null && this.parent.removeChild(this), Registry.blots[\"delete\"](this.domNode);\n      }\n    }, {\n      key: \"deleteAt\",\n      value: function deleteAt(index, length) {\n        this.isolate(index, length).remove();\n      }\n    }, {\n      key: \"formatAt\",\n      value: function formatAt(index, length, name, value) {\n        var blot = this.isolate(index, length);\n        if (this.scroll.query(name, Scope.BLOT) != null && value) blot.wrap(name, value);else if (this.scroll.query(name, Scope.ATTRIBUTE) != null) {\n          var parent = this.scroll.create(this.statics.scope);\n          blot.wrap(parent), parent.format(name, value);\n        }\n      }\n    }, {\n      key: \"insertAt\",\n      value: function insertAt(index, value, def) {\n        var blot = def == null ? this.scroll.create(\"text\", value) : this.scroll.create(value, def),\n          ref = this.split(index);\n        this.parent.insertBefore(blot, ref || void 0);\n      }\n    }, {\n      key: \"isolate\",\n      value: function isolate(index, length) {\n        var target = this.split(index);\n        if (target == null) throw new Error(\"Attempt to isolate at end\");\n        return target.split(length), target;\n      }\n    }, {\n      key: \"length\",\n      value: function length() {\n        return 1;\n      }\n    }, {\n      key: \"offset\",\n      value: function offset() {\n        var root = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.parent;\n        return this.parent == null || this === root ? 0 : this.parent.children.offset(this) + this.parent.offset(root);\n      }\n    }, {\n      key: \"optimize\",\n      value: function optimize(_context) {\n        this.statics.requiredContainer && !(this.parent instanceof this.statics.requiredContainer) && this.wrap(this.statics.requiredContainer.blotName);\n      }\n    }, {\n      key: \"remove\",\n      value: function remove() {\n        this.domNode.parentNode != null && this.domNode.parentNode.removeChild(this.domNode), this.detach();\n      }\n    }, {\n      key: \"replaceWith\",\n      value: function replaceWith(name, value) {\n        var replacement = typeof name == \"string\" ? this.scroll.create(name, value) : name;\n        return this.parent != null && (this.parent.insertBefore(replacement, this.next || void 0), this.remove()), replacement;\n      }\n    }, {\n      key: \"split\",\n      value: function split(index, _force) {\n        return index === 0 ? this : this.next;\n      }\n    }, {\n      key: \"update\",\n      value: function update(_mutations, _context) {}\n    }, {\n      key: \"wrap\",\n      value: function wrap(name, value) {\n        var wrapper = typeof name == \"string\" ? this.scroll.create(name, value) : name;\n        if (this.parent != null && this.parent.insertBefore(wrapper, this.next || void 0), typeof wrapper.appendChild != \"function\") throw new ParchmentError(\"Cannot wrap \".concat(name));\n        return wrapper.appendChild(this), wrapper;\n      }\n    }], [{\n      key: \"create\",\n      value: function create(rawValue) {\n        if (this.tagName == null) throw new ParchmentError(\"Blot definition missing tagName\");\n        var node, value;\n        return Array.isArray(this.tagName) ? (typeof rawValue == \"string\" ? (value = rawValue.toUpperCase(), parseInt(value, 10).toString() === value && (value = parseInt(value, 10))) : typeof rawValue == \"number\" && (value = rawValue), typeof value == \"number\" ? node = document.createElement(this.tagName[value - 1]) : value && this.tagName.indexOf(value) > -1 ? node = document.createElement(value) : node = document.createElement(this.tagName[0])) : node = document.createElement(this.tagName), this.className && node.classList.add(this.className), node;\n      }\n    }]);\n  }();\n_ShadowBlot.blotName = \"abstract\";\nvar ShadowBlot = _ShadowBlot;\nvar _LeafBlot = /*#__PURE__*/function (_ShadowBlot2) {\n  function _LeafBlot() {\n    _classCallCheck(this, _LeafBlot);\n    return _callSuper(this, _LeafBlot, arguments);\n  }\n  _inherits(_LeafBlot, _ShadowBlot2);\n  return _createClass(_LeafBlot, [{\n    key: \"index\",\n    value:\n    /**\n     * Given location represented by node and offset from DOM Selection Range,\n     * return index to that location.\n     */\n    function index(node, offset) {\n      return this.domNode === node || this.domNode.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY ? Math.min(offset, 1) : -1;\n    }\n    /**\n     * Given index to location within blot, return node and offset representing\n     * that location, consumable by DOM Selection Range\n     */\n  }, {\n    key: \"position\",\n    value: function position(index, _inclusive) {\n      var offset = Array.from(this.parent.domNode.childNodes).indexOf(this.domNode);\n      return index > 0 && (offset += 1), [this.parent.domNode, offset];\n    }\n    /**\n     * Return value represented by this blot\n     * Should not change without interaction from API or\n     * user change detectable by update()\n     */\n  }, {\n    key: \"value\",\n    value: function value() {\n      return _defineProperty({}, this.statics.blotName, this.statics.value(this.domNode) || !0);\n    }\n  }], [{\n    key: \"value\",\n    value:\n    /**\n     * Returns the value represented by domNode if it is this Blot's type\n     * No checking that domNode can represent this Blot type is required so\n     * applications needing it should check externally before calling.\n     */\n    function value(_domNode) {\n      return !0;\n    }\n  }]);\n}(ShadowBlot);\n_LeafBlot.scope = Scope.INLINE_BLOT;\nvar LeafBlot = _LeafBlot;\nvar LeafBlot$1 = LeafBlot;\nvar LinkedList = /*#__PURE__*/function () {\n  function LinkedList() {\n    _classCallCheck(this, LinkedList);\n    this.head = null, this.tail = null, this.length = 0;\n  }\n  return _createClass(LinkedList, [{\n    key: \"append\",\n    value: function append() {\n      for (var _len2 = arguments.length, nodes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        nodes[_key2] = arguments[_key2];\n      }\n      if (this.insertBefore(nodes[0], null), nodes.length > 1) {\n        var rest = nodes.slice(1);\n        this.append.apply(this, _toConsumableArray(rest));\n      }\n    }\n  }, {\n    key: \"at\",\n    value: function at(index) {\n      var next = this.iterator();\n      var cur = next();\n      for (; cur && index > 0;) index -= 1, cur = next();\n      return cur;\n    }\n  }, {\n    key: \"contains\",\n    value: function contains(node) {\n      var next = this.iterator();\n      var cur = next();\n      for (; cur;) {\n        if (cur === node) return !0;\n        cur = next();\n      }\n      return !1;\n    }\n  }, {\n    key: \"indexOf\",\n    value: function indexOf(node) {\n      var next = this.iterator();\n      var cur = next(),\n        index = 0;\n      for (; cur;) {\n        if (cur === node) return index;\n        index += 1, cur = next();\n      }\n      return -1;\n    }\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(node, refNode) {\n      node != null && (this.remove(node), node.next = refNode, refNode != null ? (node.prev = refNode.prev, refNode.prev != null && (refNode.prev.next = node), refNode.prev = node, refNode === this.head && (this.head = node)) : this.tail != null ? (this.tail.next = node, node.prev = this.tail, this.tail = node) : (node.prev = null, this.head = this.tail = node), this.length += 1);\n    }\n  }, {\n    key: \"offset\",\n    value: function offset(target) {\n      var index = 0,\n        cur = this.head;\n      for (; cur != null;) {\n        if (cur === target) return index;\n        index += cur.length(), cur = cur.next;\n      }\n      return -1;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(node) {\n      this.contains(node) && (node.prev != null && (node.prev.next = node.next), node.next != null && (node.next.prev = node.prev), node === this.head && (this.head = node.next), node === this.tail && (this.tail = node.prev), this.length -= 1);\n    }\n  }, {\n    key: \"iterator\",\n    value: function iterator() {\n      var curNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.head;\n      return function () {\n        var ret = curNode;\n        return curNode != null && (curNode = curNode.next), ret;\n      };\n    }\n  }, {\n    key: \"find\",\n    value: function find(index) {\n      var inclusive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n      var next = this.iterator();\n      var cur = next();\n      for (; cur;) {\n        var length = cur.length();\n        if (index < length || inclusive && index === length && (cur.next == null || cur.next.length() !== 0)) return [cur, index];\n        index -= length, cur = next();\n      }\n      return [null, 0];\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(callback) {\n      var next = this.iterator();\n      var cur = next();\n      for (; cur;) callback(cur), cur = next();\n    }\n  }, {\n    key: \"forEachAt\",\n    value: function forEachAt(index, length, callback) {\n      if (length <= 0) return;\n      var _this$find = this.find(index),\n        _this$find2 = _slicedToArray(_this$find, 2),\n        startNode = _this$find2[0],\n        offset = _this$find2[1];\n      var curIndex = index - offset;\n      var next = this.iterator(startNode);\n      var cur = next();\n      for (; cur && curIndex < index + length;) {\n        var curLength = cur.length();\n        index > curIndex ? callback(cur, index - curIndex, Math.min(length, curIndex + curLength - index)) : callback(cur, 0, Math.min(curLength, index + length - curIndex)), curIndex += curLength, cur = next();\n      }\n    }\n  }, {\n    key: \"map\",\n    value: function map(callback) {\n      return this.reduce(function (memo, cur) {\n        return memo.push(callback(cur)), memo;\n      }, []);\n    }\n  }, {\n    key: \"reduce\",\n    value: function reduce(callback, memo) {\n      var next = this.iterator();\n      var cur = next();\n      for (; cur;) memo = callback(memo, cur), cur = next();\n      return memo;\n    }\n  }]);\n}();\nfunction makeAttachedBlot(node, scroll) {\n  var found = scroll.find(node);\n  if (found) return found;\n  try {\n    return scroll.create(node);\n  } catch (_unused2) {\n    var blot = scroll.create(Scope.INLINE);\n    return Array.from(node.childNodes).forEach(function (child) {\n      blot.domNode.appendChild(child);\n    }), node.parentNode && node.parentNode.replaceChild(blot.domNode, node), blot.attach(), blot;\n  }\n}\nvar _ParentBlot = /*#__PURE__*/function (_ShadowBlot3) {\n  function _ParentBlot(scroll, domNode) {\n    var _this8;\n    _classCallCheck(this, _ParentBlot);\n    _this8 = _callSuper(this, _ParentBlot, [scroll, domNode]), _this8.uiNode = null, _this8.build();\n    return _this8;\n  }\n  _inherits(_ParentBlot, _ShadowBlot3);\n  return _createClass(_ParentBlot, [{\n    key: \"appendChild\",\n    value: function appendChild(other) {\n      this.insertBefore(other);\n    }\n  }, {\n    key: \"attach\",\n    value: function attach() {\n      _superPropGet(_ParentBlot, \"attach\", this, 3)([]), this.children.forEach(function (child) {\n        child.attach();\n      });\n    }\n  }, {\n    key: \"attachUI\",\n    value: function attachUI(node) {\n      this.uiNode != null && this.uiNode.remove(), this.uiNode = node, _ParentBlot.uiClass && this.uiNode.classList.add(_ParentBlot.uiClass), this.uiNode.setAttribute(\"contenteditable\", \"false\"), this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);\n    }\n    /**\n     * Called during construction, should fill its own children LinkedList.\n     */\n  }, {\n    key: \"build\",\n    value: function build() {\n      var _this9 = this;\n      this.children = new LinkedList(), Array.from(this.domNode.childNodes).filter(function (node) {\n        return node !== _this9.uiNode;\n      }).reverse().forEach(function (node) {\n        try {\n          var child = makeAttachedBlot(node, _this9.scroll);\n          _this9.insertBefore(child, _this9.children.head || void 0);\n        } catch (err) {\n          if (err instanceof ParchmentError) return;\n          throw err;\n        }\n      });\n    }\n  }, {\n    key: \"deleteAt\",\n    value: function deleteAt(index, length) {\n      if (index === 0 && length === this.length()) return this.remove();\n      this.children.forEachAt(index, length, function (child, offset, childLength) {\n        child.deleteAt(offset, childLength);\n      });\n    }\n  }, {\n    key: \"descendant\",\n    value: function descendant(criteria) {\n      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var _this$children$find = this.children.find(index),\n        _this$children$find2 = _slicedToArray(_this$children$find, 2),\n        child = _this$children$find2[0],\n        offset = _this$children$find2[1];\n      return criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria ? [child, offset] : child instanceof _ParentBlot ? child.descendant(criteria, offset) : [null, -1];\n    }\n  }, {\n    key: \"descendants\",\n    value: function descendants(criteria) {\n      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.MAX_VALUE;\n      var descendants = [],\n        lengthLeft = length;\n      return this.children.forEachAt(index, length, function (child, childIndex, childLength) {\n        (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) && descendants.push(child), child instanceof _ParentBlot && (descendants = descendants.concat(child.descendants(criteria, childIndex, lengthLeft))), lengthLeft -= childLength;\n      }), descendants;\n    }\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      this.children.forEach(function (child) {\n        child.detach();\n      }), _superPropGet(_ParentBlot, \"detach\", this, 3)([]);\n    }\n  }, {\n    key: \"enforceAllowedChildren\",\n    value: function enforceAllowedChildren() {\n      var _this10 = this;\n      var done = !1;\n      this.children.forEach(function (child) {\n        done || _this10.statics.allowedChildren.some(function (def) {\n          return child instanceof def;\n        }) || (child.statics.scope === Scope.BLOCK_BLOT ? (child.next != null && _this10.splitAfter(child), child.prev != null && _this10.splitAfter(child.prev), child.parent.unwrap(), done = !0) : child instanceof _ParentBlot ? child.unwrap() : child.remove());\n      });\n    }\n  }, {\n    key: \"formatAt\",\n    value: function formatAt(index, length, name, value) {\n      this.children.forEachAt(index, length, function (child, offset, childLength) {\n        child.formatAt(offset, childLength, name, value);\n      });\n    }\n  }, {\n    key: \"insertAt\",\n    value: function insertAt(index, value, def) {\n      var _this$children$find3 = this.children.find(index),\n        _this$children$find4 = _slicedToArray(_this$children$find3, 2),\n        child = _this$children$find4[0],\n        offset = _this$children$find4[1];\n      if (child) child.insertAt(offset, value, def);else {\n        var blot = def == null ? this.scroll.create(\"text\", value) : this.scroll.create(value, def);\n        this.appendChild(blot);\n      }\n    }\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(childBlot, refBlot) {\n      childBlot.parent != null && childBlot.parent.children.remove(childBlot);\n      var refDomNode = null;\n      this.children.insertBefore(childBlot, refBlot || null), childBlot.parent = this, refBlot != null && (refDomNode = refBlot.domNode), (this.domNode.parentNode !== childBlot.domNode || this.domNode.nextSibling !== refDomNode) && this.domNode.insertBefore(childBlot.domNode, refDomNode), childBlot.attach();\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      return this.children.reduce(function (memo, child) {\n        return memo + child.length();\n      }, 0);\n    }\n  }, {\n    key: \"moveChildren\",\n    value: function moveChildren(targetParent, refNode) {\n      this.children.forEach(function (child) {\n        targetParent.insertBefore(child, refNode);\n      });\n    }\n  }, {\n    key: \"optimize\",\n    value: function optimize(context) {\n      if (_superPropGet(_ParentBlot, \"optimize\", this, 3)([context]), this.enforceAllowedChildren(), this.uiNode != null && this.uiNode !== this.domNode.firstChild && this.domNode.insertBefore(this.uiNode, this.domNode.firstChild), this.children.length === 0) if (this.statics.defaultChild != null) {\n        var child = this.scroll.create(this.statics.defaultChild.blotName);\n        this.appendChild(child);\n      } else this.remove();\n    }\n  }, {\n    key: \"path\",\n    value: function path(index) {\n      var inclusive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n      var _this$children$find5 = this.children.find(index, inclusive),\n        _this$children$find6 = _slicedToArray(_this$children$find5, 2),\n        child = _this$children$find6[0],\n        offset = _this$children$find6[1],\n        position = [[this, index]];\n      return child instanceof _ParentBlot ? position.concat(child.path(offset, inclusive)) : (child != null && position.push([child, offset]), position);\n    }\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(child) {\n      this.children.remove(child);\n    }\n  }, {\n    key: \"replaceWith\",\n    value: function replaceWith(name, value) {\n      var replacement = typeof name == \"string\" ? this.scroll.create(name, value) : name;\n      return replacement instanceof _ParentBlot && this.moveChildren(replacement), _superPropGet(_ParentBlot, \"replaceWith\", this, 3)([replacement]);\n    }\n  }, {\n    key: \"split\",\n    value: function split(index) {\n      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n      if (!force) {\n        if (index === 0) return this;\n        if (index === this.length()) return this.next;\n      }\n      var after = this.clone();\n      return this.parent && this.parent.insertBefore(after, this.next || void 0), this.children.forEachAt(index, this.length(), function (child, offset, _length) {\n        var split = child.split(offset, force);\n        split != null && after.appendChild(split);\n      }), after;\n    }\n  }, {\n    key: \"splitAfter\",\n    value: function splitAfter(child) {\n      var after = this.clone();\n      for (; child.next != null;) after.appendChild(child.next);\n      return this.parent && this.parent.insertBefore(after, this.next || void 0), after;\n    }\n  }, {\n    key: \"unwrap\",\n    value: function unwrap() {\n      this.parent && this.moveChildren(this.parent, this.next || void 0), this.remove();\n    }\n  }, {\n    key: \"update\",\n    value: function update(mutations, _context) {\n      var _this11 = this;\n      var addedNodes = [],\n        removedNodes = [];\n      mutations.forEach(function (mutation) {\n        mutation.target === _this11.domNode && mutation.type === \"childList\" && (addedNodes.push.apply(addedNodes, _toConsumableArray(mutation.addedNodes)), removedNodes.push.apply(removedNodes, _toConsumableArray(mutation.removedNodes)));\n      }), removedNodes.forEach(function (node) {\n        if (node.parentNode != null &&\n        // @ts-expect-error Fix me later\n        node.tagName !== \"IFRAME\" && document.body.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) return;\n        var blot = _this11.scroll.find(node);\n        blot != null && (blot.domNode.parentNode == null || blot.domNode.parentNode === _this11.domNode) && blot.detach();\n      }), addedNodes.filter(function (node) {\n        return node.parentNode === _this11.domNode && node !== _this11.uiNode;\n      }).sort(function (a, b) {\n        return a === b ? 0 : a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING ? 1 : -1;\n      }).forEach(function (node) {\n        var refBlot = null;\n        node.nextSibling != null && (refBlot = _this11.scroll.find(node.nextSibling));\n        var blot = makeAttachedBlot(node, _this11.scroll);\n        (blot.next !== refBlot || blot.next == null) && (blot.parent != null && blot.parent.removeChild(_this11), _this11.insertBefore(blot, refBlot || void 0));\n      }), this.enforceAllowedChildren();\n    }\n  }]);\n}(ShadowBlot);\n_ParentBlot.uiClass = \"\";\nvar ParentBlot = _ParentBlot;\nvar ParentBlot$1 = ParentBlot;\nfunction isEqual(obj1, obj2) {\n  if (Object.keys(obj1).length !== Object.keys(obj2).length) return !1;\n  for (var prop in obj1) if (obj1[prop] !== obj2[prop]) return !1;\n  return !0;\n}\nvar _InlineBlot = /*#__PURE__*/function (_ParentBlot$) {\n  function _InlineBlot(scroll, domNode) {\n    var _this12;\n    _classCallCheck(this, _InlineBlot);\n    _this12 = _callSuper(this, _InlineBlot, [scroll, domNode]), _this12.attributes = new AttributorStore$1(_this12.domNode);\n    return _this12;\n  }\n  _inherits(_InlineBlot, _ParentBlot$);\n  return _createClass(_InlineBlot, [{\n    key: \"format\",\n    value: function format(name, value) {\n      var _this13 = this;\n      if (name === this.statics.blotName && !value) this.children.forEach(function (child) {\n        child instanceof _InlineBlot || (child = child.wrap(_InlineBlot.blotName, !0)), _this13.attributes.copy(child);\n      }), this.unwrap();else {\n        var _format = this.scroll.query(name, Scope.INLINE);\n        if (_format == null) return;\n        _format instanceof Attributor ? this.attributes.attribute(_format, value) : value && (name !== this.statics.blotName || this.formats()[name] !== value) && this.replaceWith(name, value);\n      }\n    }\n  }, {\n    key: \"formats\",\n    value: function formats() {\n      var formats = this.attributes.values(),\n        format = this.statics.formats(this.domNode, this.scroll);\n      return format != null && (formats[this.statics.blotName] = format), formats;\n    }\n  }, {\n    key: \"formatAt\",\n    value: function formatAt(index, length, name, value) {\n      this.formats()[name] != null || this.scroll.query(name, Scope.ATTRIBUTE) ? this.isolate(index, length).format(name, value) : _superPropGet(_InlineBlot, \"formatAt\", this, 3)([index, length, name, value]);\n    }\n  }, {\n    key: \"optimize\",\n    value: function optimize(context) {\n      _superPropGet(_InlineBlot, \"optimize\", this, 3)([context]);\n      var formats = this.formats();\n      if (Object.keys(formats).length === 0) return this.unwrap();\n      var next = this.next;\n      next instanceof _InlineBlot && next.prev === this && isEqual(formats, next.formats()) && (next.moveChildren(this), next.remove());\n    }\n  }, {\n    key: \"replaceWith\",\n    value: function replaceWith(name, value) {\n      var replacement = _superPropGet(_InlineBlot, \"replaceWith\", this, 3)([name, value]);\n      return this.attributes.copy(replacement), replacement;\n    }\n  }, {\n    key: \"update\",\n    value: function update(mutations, context) {\n      var _this14 = this;\n      _superPropGet(_InlineBlot, \"update\", this, 3)([mutations, context]), mutations.some(function (mutation) {\n        return mutation.target === _this14.domNode && mutation.type === \"attributes\";\n      }) && this.attributes.build();\n    }\n  }, {\n    key: \"wrap\",\n    value: function wrap(name, value) {\n      var wrapper = _superPropGet(_InlineBlot, \"wrap\", this, 3)([name, value]);\n      return wrapper instanceof _InlineBlot && this.attributes.move(wrapper), wrapper;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(value) {\n      return _superPropGet(_InlineBlot, \"create\", this, 2)([value]);\n    }\n  }, {\n    key: \"formats\",\n    value: function formats(domNode, scroll) {\n      var match2 = scroll.query(_InlineBlot.blotName);\n      if (!(match2 != null && domNode.tagName === match2.tagName)) {\n        if (typeof this.tagName == \"string\") return !0;\n        if (Array.isArray(this.tagName)) return domNode.tagName.toLowerCase();\n      }\n    }\n  }]);\n}(ParentBlot$1);\n_InlineBlot.allowedChildren = [_InlineBlot, LeafBlot$1], _InlineBlot.blotName = \"inline\", _InlineBlot.scope = Scope.INLINE_BLOT, _InlineBlot.tagName = \"SPAN\";\nvar InlineBlot = _InlineBlot;\nvar InlineBlot$1 = InlineBlot,\n  _BlockBlot = /*#__PURE__*/function (_ParentBlot$2) {\n    function _BlockBlot(scroll, domNode) {\n      var _this15;\n      _classCallCheck(this, _BlockBlot);\n      _this15 = _callSuper(this, _BlockBlot, [scroll, domNode]), _this15.attributes = new AttributorStore$1(_this15.domNode);\n      return _this15;\n    }\n    _inherits(_BlockBlot, _ParentBlot$2);\n    return _createClass(_BlockBlot, [{\n      key: \"format\",\n      value: function format(name, value) {\n        var format = this.scroll.query(name, Scope.BLOCK);\n        format != null && (format instanceof Attributor ? this.attributes.attribute(format, value) : name === this.statics.blotName && !value ? this.replaceWith(_BlockBlot.blotName) : value && (name !== this.statics.blotName || this.formats()[name] !== value) && this.replaceWith(name, value));\n      }\n    }, {\n      key: \"formats\",\n      value: function formats() {\n        var formats = this.attributes.values(),\n          format = this.statics.formats(this.domNode, this.scroll);\n        return format != null && (formats[this.statics.blotName] = format), formats;\n      }\n    }, {\n      key: \"formatAt\",\n      value: function formatAt(index, length, name, value) {\n        this.scroll.query(name, Scope.BLOCK) != null ? this.format(name, value) : _superPropGet(_BlockBlot, \"formatAt\", this, 3)([index, length, name, value]);\n      }\n    }, {\n      key: \"insertAt\",\n      value: function insertAt(index, value, def) {\n        if (def == null || this.scroll.query(value, Scope.INLINE) != null) _superPropGet(_BlockBlot, \"insertAt\", this, 3)([index, value, def]);else {\n          var after = this.split(index);\n          if (after != null) {\n            var blot = this.scroll.create(value, def);\n            after.parent.insertBefore(blot, after);\n          } else throw new Error(\"Attempt to insertAt after block boundaries\");\n        }\n      }\n    }, {\n      key: \"replaceWith\",\n      value: function replaceWith(name, value) {\n        var replacement = _superPropGet(_BlockBlot, \"replaceWith\", this, 3)([name, value]);\n        return this.attributes.copy(replacement), replacement;\n      }\n    }, {\n      key: \"update\",\n      value: function update(mutations, context) {\n        var _this16 = this;\n        _superPropGet(_BlockBlot, \"update\", this, 3)([mutations, context]), mutations.some(function (mutation) {\n          return mutation.target === _this16.domNode && mutation.type === \"attributes\";\n        }) && this.attributes.build();\n      }\n    }], [{\n      key: \"create\",\n      value: function create(value) {\n        return _superPropGet(_BlockBlot, \"create\", this, 2)([value]);\n      }\n    }, {\n      key: \"formats\",\n      value: function formats(domNode, scroll) {\n        var match2 = scroll.query(_BlockBlot.blotName);\n        if (!(match2 != null && domNode.tagName === match2.tagName)) {\n          if (typeof this.tagName == \"string\") return !0;\n          if (Array.isArray(this.tagName)) return domNode.tagName.toLowerCase();\n        }\n      }\n    }]);\n  }(ParentBlot$1);\n_BlockBlot.blotName = \"block\", _BlockBlot.scope = Scope.BLOCK_BLOT, _BlockBlot.tagName = \"P\", _BlockBlot.allowedChildren = [InlineBlot$1, _BlockBlot, LeafBlot$1];\nvar BlockBlot = _BlockBlot;\nvar BlockBlot$1 = BlockBlot,\n  _ContainerBlot = /*#__PURE__*/function (_ParentBlot$3) {\n    function _ContainerBlot() {\n      _classCallCheck(this, _ContainerBlot);\n      return _callSuper(this, _ContainerBlot, arguments);\n    }\n    _inherits(_ContainerBlot, _ParentBlot$3);\n    return _createClass(_ContainerBlot, [{\n      key: \"checkMerge\",\n      value: function checkMerge() {\n        return this.next !== null && this.next.statics.blotName === this.statics.blotName;\n      }\n    }, {\n      key: \"deleteAt\",\n      value: function deleteAt(index, length) {\n        _superPropGet(_ContainerBlot, \"deleteAt\", this, 3)([index, length]), this.enforceAllowedChildren();\n      }\n    }, {\n      key: \"formatAt\",\n      value: function formatAt(index, length, name, value) {\n        _superPropGet(_ContainerBlot, \"formatAt\", this, 3)([index, length, name, value]), this.enforceAllowedChildren();\n      }\n    }, {\n      key: \"insertAt\",\n      value: function insertAt(index, value, def) {\n        _superPropGet(_ContainerBlot, \"insertAt\", this, 3)([index, value, def]), this.enforceAllowedChildren();\n      }\n    }, {\n      key: \"optimize\",\n      value: function optimize(context) {\n        _superPropGet(_ContainerBlot, \"optimize\", this, 3)([context]), this.children.length > 0 && this.next != null && this.checkMerge() && (this.next.moveChildren(this), this.next.remove());\n      }\n    }]);\n  }(ParentBlot$1);\n_ContainerBlot.blotName = \"container\", _ContainerBlot.scope = Scope.BLOCK_BLOT;\nvar ContainerBlot = _ContainerBlot;\nvar ContainerBlot$1 = ContainerBlot;\nvar EmbedBlot = /*#__PURE__*/function (_LeafBlot$) {\n  function EmbedBlot() {\n    _classCallCheck(this, EmbedBlot);\n    return _callSuper(this, EmbedBlot, arguments);\n  }\n  _inherits(EmbedBlot, _LeafBlot$);\n  return _createClass(EmbedBlot, [{\n    key: \"format\",\n    value: function format(name, value) {\n      _superPropGet(EmbedBlot, \"formatAt\", this, 3)([0, this.length(), name, value]);\n    }\n  }, {\n    key: \"formatAt\",\n    value: function formatAt(index, length, name, value) {\n      index === 0 && length === this.length() ? this.format(name, value) : _superPropGet(EmbedBlot, \"formatAt\", this, 3)([index, length, name, value]);\n    }\n  }, {\n    key: \"formats\",\n    value: function formats() {\n      return this.statics.formats(this.domNode, this.scroll);\n    }\n  }], [{\n    key: \"formats\",\n    value: function formats(_domNode, _scroll) {}\n  }]);\n}(LeafBlot$1);\nvar EmbedBlot$1 = EmbedBlot,\n  OBSERVER_CONFIG = {\n    attributes: !0,\n    characterData: !0,\n    characterDataOldValue: !0,\n    childList: !0,\n    subtree: !0\n  },\n  MAX_OPTIMIZE_ITERATIONS = 100,\n  _ScrollBlot = /*#__PURE__*/function (_ParentBlot$4) {\n    function _ScrollBlot(registry, node) {\n      var _this17;\n      _classCallCheck(this, _ScrollBlot);\n      _this17 = _callSuper(this, _ScrollBlot, [null, node]), _this17.registry = registry, _this17.scroll = _assertThisInitialized(_this17), _this17.build(), _this17.observer = new MutationObserver(function (mutations) {\n        _this17.update(mutations);\n      }), _this17.observer.observe(_this17.domNode, OBSERVER_CONFIG), _this17.attach();\n      return _this17;\n    }\n    _inherits(_ScrollBlot, _ParentBlot$4);\n    return _createClass(_ScrollBlot, [{\n      key: \"create\",\n      value: function create(input, value) {\n        return this.registry.create(this, input, value);\n      }\n    }, {\n      key: \"find\",\n      value: function find(node) {\n        var bubble = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n        var blot = this.registry.find(node, bubble);\n        return blot ? blot.scroll === this ? blot : bubble ? this.find(blot.scroll.domNode.parentNode, !0) : null : null;\n      }\n    }, {\n      key: \"query\",\n      value: function query(_query2) {\n        var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Scope.ANY;\n        return this.registry.query(_query2, scope);\n      }\n    }, {\n      key: \"register\",\n      value: function register() {\n        var _this$registry;\n        return (_this$registry = this.registry).register.apply(_this$registry, arguments);\n      }\n    }, {\n      key: \"build\",\n      value: function build() {\n        this.scroll != null && _superPropGet(_ScrollBlot, \"build\", this, 3)([]);\n      }\n    }, {\n      key: \"detach\",\n      value: function detach() {\n        _superPropGet(_ScrollBlot, \"detach\", this, 3)([]), this.observer.disconnect();\n      }\n    }, {\n      key: \"deleteAt\",\n      value: function deleteAt(index, length) {\n        this.update(), index === 0 && length === this.length() ? this.children.forEach(function (child) {\n          child.remove();\n        }) : _superPropGet(_ScrollBlot, \"deleteAt\", this, 3)([index, length]);\n      }\n    }, {\n      key: \"formatAt\",\n      value: function formatAt(index, length, name, value) {\n        this.update(), _superPropGet(_ScrollBlot, \"formatAt\", this, 3)([index, length, name, value]);\n      }\n    }, {\n      key: \"insertAt\",\n      value: function insertAt(index, value, def) {\n        this.update(), _superPropGet(_ScrollBlot, \"insertAt\", this, 3)([index, value, def]);\n      }\n    }, {\n      key: \"optimize\",\n      value: function _optimize() {\n        var _this18 = this;\n        var mutations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        _superPropGet(_ScrollBlot, \"optimize\", this, 3)([context]);\n        var mutationsMap = context.mutationsMap || /* @__PURE__ */new WeakMap();\n        var records = Array.from(this.observer.takeRecords());\n        for (; records.length > 0;) mutations.push(records.pop());\n        var _mark = function mark(blot) {\n            var markParent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;\n            blot == null || blot === _this18 || blot.domNode.parentNode != null && (mutationsMap.has(blot.domNode) || mutationsMap.set(blot.domNode, []), markParent && _mark(blot.parent));\n          },\n          _optimize = function optimize(blot) {\n            mutationsMap.has(blot.domNode) && (blot instanceof ParentBlot$1 && blot.children.forEach(_optimize), mutationsMap[\"delete\"](blot.domNode), blot.optimize(context));\n          };\n        var remaining = mutations;\n        for (var i = 0; remaining.length > 0; i += 1) {\n          if (i >= MAX_OPTIMIZE_ITERATIONS) throw new Error(\"[Parchment] Maximum optimize iterations reached\");\n          for (remaining.forEach(function (mutation) {\n            var blot = _this18.find(mutation.target, !0);\n            blot != null && (blot.domNode === mutation.target && (mutation.type === \"childList\" ? (_mark(_this18.find(mutation.previousSibling, !1)), Array.from(mutation.addedNodes).forEach(function (node) {\n              var child = _this18.find(node, !1);\n              _mark(child, !1), child instanceof ParentBlot$1 && child.children.forEach(function (grandChild) {\n                _mark(grandChild, !1);\n              });\n            })) : mutation.type === \"attributes\" && _mark(blot.prev)), _mark(blot));\n          }), this.children.forEach(_optimize), remaining = Array.from(this.observer.takeRecords()), records = remaining.slice(); records.length > 0;) mutations.push(records.pop());\n        }\n      }\n    }, {\n      key: \"update\",\n      value: function update(mutations) {\n        var _this19 = this;\n        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        mutations = mutations || this.observer.takeRecords();\n        var mutationsMap = /* @__PURE__ */new WeakMap();\n        mutations.map(function (mutation) {\n          var blot = _this19.find(mutation.target, !0);\n          return blot == null ? null : mutationsMap.has(blot.domNode) ? (mutationsMap.get(blot.domNode).push(mutation), null) : (mutationsMap.set(blot.domNode, [mutation]), blot);\n        }).forEach(function (blot) {\n          blot != null && blot !== _this19 && mutationsMap.has(blot.domNode) && blot.update(mutationsMap.get(blot.domNode) || [], context);\n        }), context.mutationsMap = mutationsMap, mutationsMap.has(this.domNode) && _superPropGet(_ScrollBlot, \"update\", this, 3)([mutationsMap.get(this.domNode), context]), this.optimize(mutations, context);\n      }\n    }]);\n  }(ParentBlot$1);\n_ScrollBlot.blotName = \"scroll\", _ScrollBlot.defaultChild = BlockBlot$1, _ScrollBlot.allowedChildren = [BlockBlot$1, ContainerBlot$1], _ScrollBlot.scope = Scope.BLOCK_BLOT, _ScrollBlot.tagName = \"DIV\";\nvar ScrollBlot = _ScrollBlot;\nvar ScrollBlot$1 = ScrollBlot,\n  _TextBlot = /*#__PURE__*/function (_LeafBlot$2) {\n    function _TextBlot(scroll, node) {\n      var _this20;\n      _classCallCheck(this, _TextBlot);\n      _this20 = _callSuper(this, _TextBlot, [scroll, node]), _this20.text = _this20.statics.value(_this20.domNode);\n      return _this20;\n    }\n    _inherits(_TextBlot, _LeafBlot$2);\n    return _createClass(_TextBlot, [{\n      key: \"deleteAt\",\n      value: function deleteAt(index, length) {\n        this.domNode.data = this.text = this.text.slice(0, index) + this.text.slice(index + length);\n      }\n    }, {\n      key: \"index\",\n      value: function index(node, offset) {\n        return this.domNode === node ? offset : -1;\n      }\n    }, {\n      key: \"insertAt\",\n      value: function insertAt(index, value, def) {\n        def == null ? (this.text = this.text.slice(0, index) + value + this.text.slice(index), this.domNode.data = this.text) : _superPropGet(_TextBlot, \"insertAt\", this, 3)([index, value, def]);\n      }\n    }, {\n      key: \"length\",\n      value: function length() {\n        return this.text.length;\n      }\n    }, {\n      key: \"optimize\",\n      value: function optimize(context) {\n        _superPropGet(_TextBlot, \"optimize\", this, 3)([context]), this.text = this.statics.value(this.domNode), this.text.length === 0 ? this.remove() : this.next instanceof _TextBlot && this.next.prev === this && (this.insertAt(this.length(), this.next.value()), this.next.remove());\n      }\n    }, {\n      key: \"position\",\n      value: function position(index) {\n        var _inclusive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n        return [this.domNode, index];\n      }\n    }, {\n      key: \"split\",\n      value: function split(index) {\n        var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n        if (!force) {\n          if (index === 0) return this;\n          if (index === this.length()) return this.next;\n        }\n        var after = this.scroll.create(this.domNode.splitText(index));\n        return this.parent.insertBefore(after, this.next || void 0), this.text = this.statics.value(this.domNode), after;\n      }\n    }, {\n      key: \"update\",\n      value: function update(mutations, _context) {\n        var _this21 = this;\n        mutations.some(function (mutation) {\n          return mutation.type === \"characterData\" && mutation.target === _this21.domNode;\n        }) && (this.text = this.statics.value(this.domNode));\n      }\n    }, {\n      key: \"value\",\n      value: function value() {\n        return this.text;\n      }\n    }], [{\n      key: \"create\",\n      value: function create(value) {\n        return document.createTextNode(value);\n      }\n    }, {\n      key: \"value\",\n      value: function value(domNode) {\n        return domNode.data;\n      }\n    }]);\n  }(LeafBlot$1);\n_TextBlot.blotName = \"text\", _TextBlot.scope = Scope.INLINE_BLOT;\nvar TextBlot = _TextBlot;\nvar TextBlot$1 = TextBlot;\nexport { Attributor, AttributorStore$1 as AttributorStore, BlockBlot$1 as BlockBlot, ClassAttributor$1 as ClassAttributor, ContainerBlot$1 as ContainerBlot, EmbedBlot$1 as EmbedBlot, InlineBlot$1 as InlineBlot, LeafBlot$1 as LeafBlot, ParentBlot$1 as ParentBlot, Registry, Scope, ScrollBlot$1 as ScrollBlot, StyleAttributor$1 as StyleAttributor, TextBlot$1 as TextBlot };","map":{"version":3,"names":["Scope","Scope2","TYPE","LEVEL","ATTRIBUTE","BLOT","INLINE","BLOCK","BLOCK_BLOT","INLINE_BLOT","BLOCK_ATTRIBUTE","INLINE_ATTRIBUTE","ANY","Attributor","attrName","keyName","options","arguments","length","undefined","_classCallCheck","attributeBit","scope","whitelist","_createClass","key","value","add","node","canAdd","setAttribute","_node","indexOf","replace","remove","removeAttribute","getAttribute","keys","Array","from","attributes","map","item","name","ParchmentError","_Error","message","_this","_callSuper","constructor","_inherits","_wrapNativeSuper","Error","_Registry","classes","tags","types","create","scroll","input","match2","query","concat","blotClass","Node","nodeType","TEXT_NODE","blot","blots","set","domNode","find","bubble","_this2","Text","text","block","inline","Element","split","some","tagName","register","_this3","_len","definitions","_key","definition","isBlot","isAttr","blotName","className","isArray","toUpperCase","forEach","tag","has","get","parentNode","_unused","WeakMap","Registry","match","prefix","filter","ClassAttributor","_Attributor","classList","slice","join","ClassAttributor$1","camelize","parts","rest","part","StyleAttributor","_Attributor2","style","trim","StyleAttributor$1","AttributorStore","build","attribute","_this4","styles","attr","copy","target","_this5","Object","format","move","_this6","values","_this7","reduce","AttributorStore$1","_ShadowBlot","prev","next","attach","clone","cloneNode","detach","parent","removeChild","deleteAt","index","isolate","formatAt","wrap","statics","insertAt","def","ref","insertBefore","offset","root","children","optimize","_context","requiredContainer","replaceWith","replacement","_force","update","_mutations","wrapper","appendChild","rawValue","parseInt","toString","document","createElement","ShadowBlot","_LeafBlot","_ShadowBlot2","compareDocumentPosition","DOCUMENT_POSITION_CONTAINED_BY","Math","min","position","_inclusive","childNodes","_defineProperty","_domNode","LeafBlot","LeafBlot$1","LinkedList","head","tail","append","_len2","nodes","_key2","apply","_toConsumableArray","at","iterator","cur","contains","refNode","curNode","ret","inclusive","callback","forEachAt","_this$find","_this$find2","_slicedToArray","startNode","curIndex","curLength","memo","push","makeAttachedBlot","found","_unused2","child","replaceChild","_ParentBlot","_ShadowBlot3","_this8","uiNode","other","_superPropGet","attachUI","uiClass","firstChild","_this9","reverse","err","childLength","descendant","criteria","_this$children$find","_this$children$find2","descendants","Number","MAX_VALUE","lengthLeft","childIndex","enforceAllowedChildren","_this10","done","allowedChildren","splitAfter","unwrap","_this$children$find3","_this$children$find4","childBlot","refBlot","refDomNode","nextSibling","moveChildren","targetParent","context","defaultChild","path","_this$children$find5","_this$children$find6","force","after","_length","mutations","_this11","addedNodes","removedNodes","mutation","type","body","sort","a","b","DOCUMENT_POSITION_FOLLOWING","ParentBlot","ParentBlot$1","isEqual","obj1","obj2","prop","_InlineBlot","_ParentBlot$","_this12","_this13","formats","_this14","toLowerCase","InlineBlot","InlineBlot$1","_BlockBlot","_ParentBlot$2","_this15","_this16","BlockBlot","BlockBlot$1","_ContainerBlot","_ParentBlot$3","checkMerge","ContainerBlot","ContainerBlot$1","EmbedBlot","_LeafBlot$","_scroll","EmbedBlot$1","OBSERVER_CONFIG","characterData","characterDataOldValue","childList","subtree","MAX_OPTIMIZE_ITERATIONS","_ScrollBlot","_ParentBlot$4","registry","_this17","_assertThisInitialized","observer","MutationObserver","observe","_this$registry","disconnect","_this18","mutationsMap","records","takeRecords","pop","mark","markParent","remaining","i","previousSibling","grandChild","_this19","ScrollBlot","ScrollBlot$1","_TextBlot","_LeafBlot$2","_this20","data","splitText","_this21","createTextNode","TextBlot","TextBlot$1"],"sources":["../src/scope.ts","../src/attributor/attributor.ts","../src/error.ts","../src/registry.ts","../src/attributor/class.ts","../src/attributor/style.ts","../src/attributor/store.ts","../src/blot/abstract/shadow.ts","../src/blot/abstract/leaf.ts","../src/collection/linked-list.ts","../src/blot/abstract/parent.ts","../src/blot/inline.ts","../src/blot/block.ts","../src/blot/abstract/container.ts","../src/blot/embed.ts","../src/blot/scroll.ts","../src/blot/text.ts"],"sourcesContent":["enum Scope {\n  TYPE = (1 << 2) - 1, // 0011 Lower two bits\n  LEVEL = ((1 << 2) - 1) << 2, // 1100 Higher two bits\n\n  ATTRIBUTE = (1 << 0) | LEVEL, // 1101\n  BLOT = (1 << 1) | LEVEL, // 1110\n  INLINE = (1 << 2) | TYPE, // 0111\n  BLOCK = (1 << 3) | TYPE, // 1011\n\n  BLOCK_BLOT = BLOCK & BLOT, // 1010\n  INLINE_BLOT = INLINE & BLOT, // 0110\n  BLOCK_ATTRIBUTE = BLOCK & ATTRIBUTE, // 1001\n  INLINE_ATTRIBUTE = INLINE & ATTRIBUTE, // 0101\n\n  ANY = TYPE | LEVEL,\n}\n\nexport default Scope;\n","import Scope from '../scope.js';\n\nexport interface AttributorOptions {\n  scope?: Scope;\n  whitelist?: string[];\n}\n\nexport default class Attributor {\n  public static keys(node: HTMLElement): string[] {\n    return Array.from(node.attributes).map((item: Attr) => item.name);\n  }\n\n  public scope: Scope;\n  public whitelist: string[] | undefined;\n\n  constructor(\n    public readonly attrName: string,\n    public readonly keyName: string,\n    options: AttributorOptions = {},\n  ) {\n    const attributeBit = Scope.TYPE & Scope.ATTRIBUTE;\n    this.scope =\n      options.scope != null\n        ? // Ignore type bits, force attribute bit\n          (options.scope & Scope.LEVEL) | attributeBit\n        : Scope.ATTRIBUTE;\n    if (options.whitelist != null) {\n      this.whitelist = options.whitelist;\n    }\n  }\n\n  public add(node: HTMLElement, value: any): boolean {\n    if (!this.canAdd(node, value)) {\n      return false;\n    }\n    node.setAttribute(this.keyName, value);\n    return true;\n  }\n\n  public canAdd(_node: HTMLElement, value: any): boolean {\n    if (this.whitelist == null) {\n      return true;\n    }\n    if (typeof value === 'string') {\n      return this.whitelist.indexOf(value.replace(/[\"']/g, '')) > -1;\n    } else {\n      return this.whitelist.indexOf(value) > -1;\n    }\n  }\n\n  public remove(node: HTMLElement): void {\n    node.removeAttribute(this.keyName);\n  }\n\n  public value(node: HTMLElement): any {\n    const value = node.getAttribute(this.keyName);\n    if (this.canAdd(node, value) && value) {\n      return value;\n    }\n    return '';\n  }\n}\n","export default class ParchmentError extends Error {\n  public message: string;\n  public name: string;\n  public stack!: string;\n\n  constructor(message: string) {\n    message = '[Parchment] ' + message;\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n  }\n}\n","import Attributor from './attributor/attributor.js';\nimport {\n  type Blot,\n  type BlotConstructor,\n  type Root,\n} from './blot/abstract/blot.js';\nimport ParchmentError from './error.js';\nimport Scope from './scope.js';\n\nexport type RegistryDefinition = Attributor | BlotConstructor;\n\nexport interface RegistryInterface {\n  create(scroll: Root, input: Node | string | Scope, value?: any): Blot;\n  query(query: string | Node | Scope, scope: Scope): RegistryDefinition | null;\n  register(...definitions: any[]): any;\n}\n\nexport default class Registry implements RegistryInterface {\n  public static blots = new WeakMap<Node, Blot>();\n\n  public static find(node?: Node | null, bubble = false): Blot | null {\n    if (node == null) {\n      return null;\n    }\n    if (this.blots.has(node)) {\n      return this.blots.get(node) || null;\n    }\n    if (bubble) {\n      let parentNode: Node | null = null;\n      try {\n        parentNode = node.parentNode;\n      } catch (err) {\n        // Probably hit a permission denied error.\n        // A known case is in Firefox, event targets can be anonymous DIVs\n        // inside an input element.\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=208427\n        return null;\n      }\n      return this.find(parentNode, bubble);\n    }\n    return null;\n  }\n\n  private attributes: { [key: string]: Attributor } = {};\n  private classes: { [key: string]: BlotConstructor } = {};\n  private tags: { [key: string]: BlotConstructor } = {};\n  private types: { [key: string]: RegistryDefinition } = {};\n\n  public create(scroll: Root, input: Node | string | Scope, value?: any): Blot {\n    const match = this.query(input);\n    if (match == null) {\n      throw new ParchmentError(`Unable to create ${input} blot`);\n    }\n    const blotClass = match as BlotConstructor;\n    const node =\n      // @ts-expect-error Fix me later\n      input instanceof Node || input.nodeType === Node.TEXT_NODE\n        ? input\n        : blotClass.create(value);\n\n    const blot = new blotClass(scroll, node as Node, value);\n    Registry.blots.set(blot.domNode, blot);\n    return blot;\n  }\n\n  public find(node: Node | null, bubble = false): Blot | null {\n    return Registry.find(node, bubble);\n  }\n\n  public query(\n    query: string | Node | Scope,\n    scope: Scope = Scope.ANY,\n  ): RegistryDefinition | null {\n    let match;\n    if (typeof query === 'string') {\n      match = this.types[query] || this.attributes[query];\n      // @ts-expect-error Fix me later\n    } else if (query instanceof Text || query.nodeType === Node.TEXT_NODE) {\n      match = this.types.text;\n    } else if (typeof query === 'number') {\n      if (query & Scope.LEVEL & Scope.BLOCK) {\n        match = this.types.block;\n      } else if (query & Scope.LEVEL & Scope.INLINE) {\n        match = this.types.inline;\n      }\n    } else if (query instanceof Element) {\n      const names = (query.getAttribute('class') || '').split(/\\s+/);\n      names.some((name) => {\n        match = this.classes[name];\n        if (match) {\n          return true;\n        }\n        return false;\n      });\n      match = match || this.tags[query.tagName];\n    }\n    if (match == null) {\n      return null;\n    }\n    if (\n      'scope' in match &&\n      scope & Scope.LEVEL & match.scope &&\n      scope & Scope.TYPE & match.scope\n    ) {\n      return match;\n    }\n    return null;\n  }\n\n  public register(...definitions: RegistryDefinition[]): RegistryDefinition[] {\n    return definitions.map((definition) => {\n      const isBlot = 'blotName' in definition;\n      const isAttr = 'attrName' in definition;\n      if (!isBlot && !isAttr) {\n        throw new ParchmentError('Invalid definition');\n      } else if (isBlot && definition.blotName === 'abstract') {\n        throw new ParchmentError('Cannot register abstract class');\n      }\n      const key = isBlot\n        ? definition.blotName\n        : isAttr\n          ? definition.attrName\n          : (undefined as never); // already handled by above checks\n      this.types[key] = definition;\n\n      if (isAttr) {\n        if (typeof definition.keyName === 'string') {\n          this.attributes[definition.keyName] = definition;\n        }\n      } else if (isBlot) {\n        if (definition.className) {\n          this.classes[definition.className] = definition;\n        }\n        if (definition.tagName) {\n          if (Array.isArray(definition.tagName)) {\n            definition.tagName = definition.tagName.map((tagName: string) => {\n              return tagName.toUpperCase();\n            });\n          } else {\n            definition.tagName = definition.tagName.toUpperCase();\n          }\n          const tagNames = Array.isArray(definition.tagName)\n            ? definition.tagName\n            : [definition.tagName];\n          tagNames.forEach((tag: string) => {\n            if (this.tags[tag] == null || definition.className == null) {\n              this.tags[tag] = definition;\n            }\n          });\n        }\n      }\n      return definition;\n    });\n  }\n}\n","import Attributor from './attributor.js';\n\nfunction match(node: HTMLElement, prefix: string): string[] {\n  const className = node.getAttribute('class') || '';\n  return className\n    .split(/\\s+/)\n    .filter((name) => name.indexOf(`${prefix}-`) === 0);\n}\n\nclass ClassAttributor extends Attributor {\n  public static keys(node: HTMLElement): string[] {\n    return (node.getAttribute('class') || '')\n      .split(/\\s+/)\n      .map((name) => name.split('-').slice(0, -1).join('-'));\n  }\n\n  public add(node: HTMLElement, value: any): boolean {\n    if (!this.canAdd(node, value)) {\n      return false;\n    }\n    this.remove(node);\n    node.classList.add(`${this.keyName}-${value}`);\n    return true;\n  }\n\n  public remove(node: HTMLElement): void {\n    const matches = match(node, this.keyName);\n    matches.forEach((name) => {\n      node.classList.remove(name);\n    });\n    if (node.classList.length === 0) {\n      node.removeAttribute('class');\n    }\n  }\n\n  public value(node: HTMLElement): any {\n    const result = match(node, this.keyName)[0] || '';\n    const value = result.slice(this.keyName.length + 1); // +1 for hyphen\n    return this.canAdd(node, value) ? value : '';\n  }\n}\n\nexport default ClassAttributor;\n","import Attributor from './attributor.js';\n\nfunction camelize(name: string): string {\n  const parts = name.split('-');\n  const rest = parts\n    .slice(1)\n    .map((part: string) => part[0].toUpperCase() + part.slice(1))\n    .join('');\n  return parts[0] + rest;\n}\n\nclass StyleAttributor extends Attributor {\n  public static keys(node: HTMLElement): string[] {\n    return (node.getAttribute('style') || '').split(';').map((value) => {\n      const arr = value.split(':');\n      return arr[0].trim();\n    });\n  }\n\n  public add(node: HTMLElement, value: any): boolean {\n    if (!this.canAdd(node, value)) {\n      return false;\n    }\n    // @ts-expect-error Fix me later\n    node.style[camelize(this.keyName)] = value;\n    return true;\n  }\n\n  public remove(node: HTMLElement): void {\n    // @ts-expect-error Fix me later\n    node.style[camelize(this.keyName)] = '';\n    if (!node.getAttribute('style')) {\n      node.removeAttribute('style');\n    }\n  }\n\n  public value(node: HTMLElement): any {\n    // @ts-expect-error Fix me later\n    const value = node.style[camelize(this.keyName)];\n    return this.canAdd(node, value) ? value : '';\n  }\n}\n\nexport default StyleAttributor;\n","import type { Formattable } from '../blot/abstract/blot.js';\nimport Registry from '../registry.js';\nimport Scope from '../scope.js';\nimport Attributor from './attributor.js';\nimport ClassAttributor from './class.js';\nimport StyleAttributor from './style.js';\n\nclass AttributorStore {\n  private attributes: { [key: string]: Attributor } = {};\n  private domNode: HTMLElement;\n\n  constructor(domNode: HTMLElement) {\n    this.domNode = domNode;\n    this.build();\n  }\n\n  public attribute(attribute: Attributor, value: any): void {\n    // verb\n    if (value) {\n      if (attribute.add(this.domNode, value)) {\n        if (attribute.value(this.domNode) != null) {\n          this.attributes[attribute.attrName] = attribute;\n        } else {\n          delete this.attributes[attribute.attrName];\n        }\n      }\n    } else {\n      attribute.remove(this.domNode);\n      delete this.attributes[attribute.attrName];\n    }\n  }\n\n  public build(): void {\n    this.attributes = {};\n    const blot = Registry.find(this.domNode);\n    if (blot == null) {\n      return;\n    }\n    const attributes = Attributor.keys(this.domNode);\n    const classes = ClassAttributor.keys(this.domNode);\n    const styles = StyleAttributor.keys(this.domNode);\n    attributes\n      .concat(classes)\n      .concat(styles)\n      .forEach((name) => {\n        const attr = blot.scroll.query(name, Scope.ATTRIBUTE);\n        if (attr instanceof Attributor) {\n          this.attributes[attr.attrName] = attr;\n        }\n      });\n  }\n\n  public copy(target: Formattable): void {\n    Object.keys(this.attributes).forEach((key) => {\n      const value = this.attributes[key].value(this.domNode);\n      target.format(key, value);\n    });\n  }\n\n  public move(target: Formattable): void {\n    this.copy(target);\n    Object.keys(this.attributes).forEach((key) => {\n      this.attributes[key].remove(this.domNode);\n    });\n    this.attributes = {};\n  }\n\n  public values(): { [key: string]: any } {\n    return Object.keys(this.attributes).reduce(\n      (attributes: { [key: string]: any }, name: string) => {\n        attributes[name] = this.attributes[name].value(this.domNode);\n        return attributes;\n      },\n      {},\n    );\n  }\n}\n\nexport default AttributorStore;\n","import ParchmentError from '../../error.js';\nimport Registry from '../../registry.js';\nimport Scope from '../../scope.js';\nimport type {\n  Blot,\n  BlotConstructor,\n  Formattable,\n  Parent,\n  Root,\n} from './blot.js';\n\nclass ShadowBlot implements Blot {\n  public static blotName = 'abstract';\n  public static className: string;\n  public static requiredContainer: BlotConstructor;\n  public static scope: Scope;\n  public static tagName: string | string[];\n\n  public static create(rawValue?: unknown): Node {\n    if (this.tagName == null) {\n      throw new ParchmentError('Blot definition missing tagName');\n    }\n    let node: HTMLElement;\n    let value: string | number | undefined;\n    if (Array.isArray(this.tagName)) {\n      if (typeof rawValue === 'string') {\n        value = rawValue.toUpperCase();\n        if (parseInt(value, 10).toString() === value) {\n          value = parseInt(value, 10);\n        }\n      } else if (typeof rawValue === 'number') {\n        value = rawValue;\n      }\n      if (typeof value === 'number') {\n        node = document.createElement(this.tagName[value - 1]);\n      } else if (value && this.tagName.indexOf(value) > -1) {\n        node = document.createElement(value);\n      } else {\n        node = document.createElement(this.tagName[0]);\n      }\n    } else {\n      node = document.createElement(this.tagName);\n    }\n    if (this.className) {\n      node.classList.add(this.className);\n    }\n    return node;\n  }\n\n  public prev: Blot | null;\n  public next: Blot | null;\n  // @ts-expect-error Fix me later\n  public parent: Parent;\n\n  // Hack for accessing inherited static methods\n  get statics(): any {\n    return this.constructor;\n  }\n  constructor(\n    public scroll: Root,\n    public domNode: Node,\n  ) {\n    Registry.blots.set(domNode, this);\n    this.prev = null;\n    this.next = null;\n  }\n\n  public attach(): void {\n    // Nothing to do\n  }\n\n  public clone(): Blot {\n    const domNode = this.domNode.cloneNode(false);\n    return this.scroll.create(domNode);\n  }\n\n  public detach(): void {\n    if (this.parent != null) {\n      this.parent.removeChild(this);\n    }\n    Registry.blots.delete(this.domNode);\n  }\n\n  public deleteAt(index: number, length: number): void {\n    const blot = this.isolate(index, length);\n    blot.remove();\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    const blot = this.isolate(index, length);\n    if (this.scroll.query(name, Scope.BLOT) != null && value) {\n      blot.wrap(name, value);\n    } else if (this.scroll.query(name, Scope.ATTRIBUTE) != null) {\n      const parent = this.scroll.create(this.statics.scope) as Parent &\n        Formattable;\n      blot.wrap(parent);\n      parent.format(name, value);\n    }\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    const blot =\n      def == null\n        ? this.scroll.create('text', value)\n        : this.scroll.create(value, def);\n    const ref = this.split(index);\n    this.parent.insertBefore(blot, ref || undefined);\n  }\n\n  public isolate(index: number, length: number): Blot {\n    const target = this.split(index);\n    if (target == null) {\n      throw new Error('Attempt to isolate at end');\n    }\n    target.split(length);\n    return target;\n  }\n\n  public length(): number {\n    return 1;\n  }\n\n  public offset(root: Blot = this.parent): number {\n    if (this.parent == null || this === root) {\n      return 0;\n    }\n    return this.parent.children.offset(this) + this.parent.offset(root);\n  }\n\n  public optimize(_context?: { [key: string]: any }): void {\n    if (\n      this.statics.requiredContainer &&\n      !(this.parent instanceof this.statics.requiredContainer)\n    ) {\n      this.wrap(this.statics.requiredContainer.blotName);\n    }\n  }\n\n  public remove(): void {\n    if (this.domNode.parentNode != null) {\n      this.domNode.parentNode.removeChild(this.domNode);\n    }\n    this.detach();\n  }\n\n  public replaceWith(name: string | Blot, value?: any): Blot {\n    const replacement =\n      typeof name === 'string' ? this.scroll.create(name, value) : name;\n    if (this.parent != null) {\n      this.parent.insertBefore(replacement, this.next || undefined);\n      this.remove();\n    }\n    return replacement;\n  }\n\n  public split(index: number, _force?: boolean): Blot | null {\n    return index === 0 ? this : this.next;\n  }\n\n  public update(\n    _mutations: MutationRecord[],\n    _context: { [key: string]: any },\n  ): void {\n    // Nothing to do by default\n  }\n\n  public wrap(name: string | Parent, value?: any): Parent {\n    const wrapper =\n      typeof name === 'string'\n        ? (this.scroll.create(name, value) as Parent)\n        : name;\n    if (this.parent != null) {\n      this.parent.insertBefore(wrapper, this.next || undefined);\n    }\n    if (typeof wrapper.appendChild !== 'function') {\n      throw new ParchmentError(`Cannot wrap ${name}`);\n    }\n    wrapper.appendChild(this);\n    return wrapper;\n  }\n}\n\nexport default ShadowBlot;\n","import Scope from '../../scope.js';\nimport type { Leaf } from './blot.js';\nimport ShadowBlot from './shadow.js';\n\nclass LeafBlot extends ShadowBlot implements Leaf {\n  public static scope = Scope.INLINE_BLOT;\n\n  /**\n   * Returns the value represented by domNode if it is this Blot's type\n   * No checking that domNode can represent this Blot type is required so\n   * applications needing it should check externally before calling.\n   */\n  public static value(_domNode: Node): any {\n    return true;\n  }\n\n  /**\n   * Given location represented by node and offset from DOM Selection Range,\n   * return index to that location.\n   */\n  public index(node: Node, offset: number): number {\n    if (\n      this.domNode === node ||\n      this.domNode.compareDocumentPosition(node) &\n        Node.DOCUMENT_POSITION_CONTAINED_BY\n    ) {\n      return Math.min(offset, 1);\n    }\n    return -1;\n  }\n\n  /**\n   * Given index to location within blot, return node and offset representing\n   * that location, consumable by DOM Selection Range\n   */\n  public position(index: number, _inclusive?: boolean): [Node, number] {\n    const childNodes: Node[] = Array.from(this.parent.domNode.childNodes);\n    let offset = childNodes.indexOf(this.domNode);\n    if (index > 0) {\n      offset += 1;\n    }\n    return [this.parent.domNode, offset];\n  }\n\n  /**\n   * Return value represented by this blot\n   * Should not change without interaction from API or\n   * user change detectable by update()\n   */\n  public value(): any {\n    return {\n      [this.statics.blotName]: this.statics.value(this.domNode) || true,\n    };\n  }\n}\n\nexport default LeafBlot;\n","import type LinkedNode from './linked-node.js';\n\nclass LinkedList<T extends LinkedNode> {\n  public head: T | null;\n  public tail: T | null;\n  public length: number;\n\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  public append(...nodes: T[]): void {\n    this.insertBefore(nodes[0], null);\n    if (nodes.length > 1) {\n      const rest = nodes.slice(1);\n      this.append(...rest);\n    }\n  }\n\n  public at(index: number): T | null {\n    const next = this.iterator();\n    let cur = next();\n    while (cur && index > 0) {\n      index -= 1;\n      cur = next();\n    }\n    return cur;\n  }\n\n  public contains(node: T): boolean {\n    const next = this.iterator();\n    let cur = next();\n    while (cur) {\n      if (cur === node) {\n        return true;\n      }\n      cur = next();\n    }\n    return false;\n  }\n\n  public indexOf(node: T): number {\n    const next = this.iterator();\n    let cur = next();\n    let index = 0;\n    while (cur) {\n      if (cur === node) {\n        return index;\n      }\n      index += 1;\n      cur = next();\n    }\n    return -1;\n  }\n\n  public insertBefore(node: T | null, refNode: T | null): void {\n    if (node == null) {\n      return;\n    }\n    this.remove(node);\n    node.next = refNode;\n    if (refNode != null) {\n      node.prev = refNode.prev;\n      if (refNode.prev != null) {\n        refNode.prev.next = node;\n      }\n      refNode.prev = node;\n      if (refNode === this.head) {\n        this.head = node;\n      }\n    } else if (this.tail != null) {\n      this.tail.next = node;\n      node.prev = this.tail;\n      this.tail = node;\n    } else {\n      node.prev = null;\n      this.head = this.tail = node;\n    }\n    this.length += 1;\n  }\n\n  public offset(target: T): number {\n    let index = 0;\n    let cur = this.head;\n    while (cur != null) {\n      if (cur === target) {\n        return index;\n      }\n      index += cur.length();\n      cur = cur.next as T;\n    }\n    return -1;\n  }\n\n  public remove(node: T): void {\n    if (!this.contains(node)) {\n      return;\n    }\n    if (node.prev != null) {\n      node.prev.next = node.next;\n    }\n    if (node.next != null) {\n      node.next.prev = node.prev;\n    }\n    if (node === this.head) {\n      this.head = node.next as T;\n    }\n    if (node === this.tail) {\n      this.tail = node.prev as T;\n    }\n    this.length -= 1;\n  }\n\n  public iterator(curNode: T | null = this.head): () => T | null {\n    // TODO use yield when we can\n    return (): T | null => {\n      const ret = curNode;\n      if (curNode != null) {\n        curNode = curNode.next as T;\n      }\n      return ret;\n    };\n  }\n\n  public find(index: number, inclusive = false): [T | null, number] {\n    const next = this.iterator();\n    let cur = next();\n    while (cur) {\n      const length = cur.length();\n      if (\n        index < length ||\n        (inclusive &&\n          index === length &&\n          (cur.next == null || cur.next.length() !== 0))\n      ) {\n        return [cur, index];\n      }\n      index -= length;\n      cur = next();\n    }\n    return [null, 0];\n  }\n\n  public forEach(callback: (cur: T) => void): void {\n    const next = this.iterator();\n    let cur = next();\n    while (cur) {\n      callback(cur);\n      cur = next();\n    }\n  }\n\n  public forEachAt(\n    index: number,\n    length: number,\n    callback: (cur: T, offset: number, length: number) => void,\n  ): void {\n    if (length <= 0) {\n      return;\n    }\n    const [startNode, offset] = this.find(index);\n    let curIndex = index - offset;\n    const next = this.iterator(startNode);\n    let cur = next();\n    while (cur && curIndex < index + length) {\n      const curLength = cur.length();\n      if (index > curIndex) {\n        callback(\n          cur,\n          index - curIndex,\n          Math.min(length, curIndex + curLength - index),\n        );\n      } else {\n        callback(cur, 0, Math.min(curLength, index + length - curIndex));\n      }\n      curIndex += curLength;\n      cur = next();\n    }\n  }\n\n  public map(callback: (cur: T) => any): any[] {\n    return this.reduce((memo: T[], cur: T) => {\n      memo.push(callback(cur));\n      return memo;\n    }, []);\n  }\n\n  public reduce<M>(callback: (memo: M, cur: T) => M, memo: M): M {\n    const next = this.iterator();\n    let cur = next();\n    while (cur) {\n      memo = callback(memo, cur);\n      cur = next();\n    }\n    return memo;\n  }\n}\n\nexport default LinkedList;\n","import LinkedList from '../../collection/linked-list.js';\nimport ParchmentError from '../../error.js';\nimport Scope from '../../scope.js';\nimport type { Blot, BlotConstructor, Parent, Root } from './blot.js';\nimport ShadowBlot from './shadow.js';\n\nfunction makeAttachedBlot(node: Node, scroll: Root): Blot {\n  const found = scroll.find(node);\n  if (found) return found;\n  try {\n    return scroll.create(node);\n  } catch (e) {\n    const blot = scroll.create(Scope.INLINE);\n    Array.from(node.childNodes).forEach((child: Node) => {\n      blot.domNode.appendChild(child);\n    });\n    if (node.parentNode) {\n      node.parentNode.replaceChild(blot.domNode, node);\n    }\n    blot.attach();\n    return blot;\n  }\n}\n\nclass ParentBlot extends ShadowBlot implements Parent {\n  /**\n   * Whitelist array of Blots that can be direct children.\n   */\n  public static allowedChildren?: BlotConstructor[];\n\n  /**\n   * Default child blot to be inserted if this blot becomes empty.\n   */\n  public static defaultChild?: BlotConstructor;\n  public static uiClass = '';\n\n  public children!: LinkedList<Blot>;\n  public domNode!: HTMLElement;\n  public uiNode: HTMLElement | null = null;\n\n  constructor(scroll: Root, domNode: Node) {\n    super(scroll, domNode);\n    this.build();\n  }\n\n  public appendChild(other: Blot): void {\n    this.insertBefore(other);\n  }\n\n  public attach(): void {\n    super.attach();\n    this.children.forEach((child) => {\n      child.attach();\n    });\n  }\n\n  public attachUI(node: HTMLElement): void {\n    if (this.uiNode != null) {\n      this.uiNode.remove();\n    }\n    this.uiNode = node;\n    if (ParentBlot.uiClass) {\n      this.uiNode.classList.add(ParentBlot.uiClass);\n    }\n    this.uiNode.setAttribute('contenteditable', 'false');\n    this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);\n  }\n\n  /**\n   * Called during construction, should fill its own children LinkedList.\n   */\n  public build(): void {\n    this.children = new LinkedList<Blot>();\n    // Need to be reversed for if DOM nodes already in order\n    Array.from(this.domNode.childNodes)\n      .filter((node: Node) => node !== this.uiNode)\n      .reverse()\n      .forEach((node: Node) => {\n        try {\n          const child = makeAttachedBlot(node, this.scroll);\n          this.insertBefore(child, this.children.head || undefined);\n        } catch (err) {\n          if (err instanceof ParchmentError) {\n            return;\n          } else {\n            throw err;\n          }\n        }\n      });\n  }\n\n  public deleteAt(index: number, length: number): void {\n    if (index === 0 && length === this.length()) {\n      return this.remove();\n    }\n    this.children.forEachAt(index, length, (child, offset, childLength) => {\n      child.deleteAt(offset, childLength);\n    });\n  }\n\n  public descendant<T extends Blot>(\n    criteria: new (...args: any[]) => T,\n    index: number,\n  ): [T | null, number];\n  public descendant(\n    criteria: (blot: Blot) => boolean,\n    index: number,\n  ): [Blot | null, number];\n  public descendant(criteria: any, index = 0): [Blot | null, number] {\n    const [child, offset] = this.children.find(index);\n    if (\n      (criteria.blotName == null && criteria(child)) ||\n      (criteria.blotName != null && child instanceof criteria)\n    ) {\n      return [child as any, offset];\n    } else if (child instanceof ParentBlot) {\n      return child.descendant(criteria, offset);\n    } else {\n      return [null, -1];\n    }\n  }\n\n  public descendants<T extends Blot>(\n    criteria: new (...args: any[]) => T,\n    index?: number,\n    length?: number,\n  ): T[];\n  public descendants(\n    criteria: (blot: Blot) => boolean,\n    index?: number,\n    length?: number,\n  ): Blot[];\n  public descendants(\n    criteria: any,\n    index = 0,\n    length: number = Number.MAX_VALUE,\n  ): Blot[] {\n    let descendants: Blot[] = [];\n    let lengthLeft = length;\n    this.children.forEachAt(\n      index,\n      length,\n      (child: Blot, childIndex: number, childLength: number) => {\n        if (\n          (criteria.blotName == null && criteria(child)) ||\n          (criteria.blotName != null && child instanceof criteria)\n        ) {\n          descendants.push(child);\n        }\n        if (child instanceof ParentBlot) {\n          descendants = descendants.concat(\n            child.descendants(criteria, childIndex, lengthLeft),\n          );\n        }\n        lengthLeft -= childLength;\n      },\n    );\n    return descendants;\n  }\n\n  public detach(): void {\n    this.children.forEach((child) => {\n      child.detach();\n    });\n    super.detach();\n  }\n\n  public enforceAllowedChildren(): void {\n    let done = false;\n    this.children.forEach((child: Blot) => {\n      if (done) {\n        return;\n      }\n      const allowed = this.statics.allowedChildren.some(\n        (def: BlotConstructor) => child instanceof def,\n      );\n      if (allowed) {\n        return;\n      }\n      if (child.statics.scope === Scope.BLOCK_BLOT) {\n        if (child.next != null) {\n          this.splitAfter(child);\n        }\n        if (child.prev != null) {\n          this.splitAfter(child.prev);\n        }\n        child.parent.unwrap();\n        done = true;\n      } else if (child instanceof ParentBlot) {\n        child.unwrap();\n      } else {\n        child.remove();\n      }\n    });\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    this.children.forEachAt(index, length, (child, offset, childLength) => {\n      child.formatAt(offset, childLength, name, value);\n    });\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    const [child, offset] = this.children.find(index);\n    if (child) {\n      child.insertAt(offset, value, def);\n    } else {\n      const blot =\n        def == null\n          ? this.scroll.create('text', value)\n          : this.scroll.create(value, def);\n      this.appendChild(blot);\n    }\n  }\n\n  public insertBefore(childBlot: Blot, refBlot?: Blot | null): void {\n    if (childBlot.parent != null) {\n      childBlot.parent.children.remove(childBlot);\n    }\n    let refDomNode: Node | null = null;\n    this.children.insertBefore(childBlot, refBlot || null);\n    childBlot.parent = this;\n    if (refBlot != null) {\n      refDomNode = refBlot.domNode;\n    }\n    if (\n      this.domNode.parentNode !== childBlot.domNode ||\n      this.domNode.nextSibling !== refDomNode\n    ) {\n      this.domNode.insertBefore(childBlot.domNode, refDomNode);\n    }\n    childBlot.attach();\n  }\n\n  public length(): number {\n    return this.children.reduce((memo, child) => {\n      return memo + child.length();\n    }, 0);\n  }\n\n  public moveChildren(targetParent: Parent, refNode?: Blot | null): void {\n    this.children.forEach((child) => {\n      targetParent.insertBefore(child, refNode);\n    });\n  }\n\n  public optimize(context?: { [key: string]: any }): void {\n    super.optimize(context);\n    this.enforceAllowedChildren();\n    if (this.uiNode != null && this.uiNode !== this.domNode.firstChild) {\n      this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);\n    }\n    if (this.children.length === 0) {\n      if (this.statics.defaultChild != null) {\n        const child = this.scroll.create(this.statics.defaultChild.blotName);\n        this.appendChild(child);\n        // TODO double check if necessary\n        // child.optimize(context);\n      } else {\n        this.remove();\n      }\n    }\n  }\n\n  public path(index: number, inclusive = false): [Blot, number][] {\n    const [child, offset] = this.children.find(index, inclusive);\n    const position: [Blot, number][] = [[this, index]];\n    if (child instanceof ParentBlot) {\n      return position.concat(child.path(offset, inclusive));\n    } else if (child != null) {\n      position.push([child, offset]);\n    }\n    return position;\n  }\n\n  public removeChild(child: Blot): void {\n    this.children.remove(child);\n  }\n\n  public replaceWith(name: string | Blot, value?: any): Blot {\n    const replacement =\n      typeof name === 'string' ? this.scroll.create(name, value) : name;\n    if (replacement instanceof ParentBlot) {\n      this.moveChildren(replacement);\n    }\n    return super.replaceWith(replacement);\n  }\n\n  public split(index: number, force = false): Blot | null {\n    if (!force) {\n      if (index === 0) {\n        return this;\n      }\n      if (index === this.length()) {\n        return this.next;\n      }\n    }\n    const after = this.clone() as ParentBlot;\n    if (this.parent) {\n      this.parent.insertBefore(after, this.next || undefined);\n    }\n    this.children.forEachAt(index, this.length(), (child, offset, _length) => {\n      const split = child.split(offset, force);\n      if (split != null) {\n        after.appendChild(split);\n      }\n    });\n    return after;\n  }\n\n  public splitAfter(child: Blot): Parent {\n    const after = this.clone() as ParentBlot;\n    while (child.next != null) {\n      after.appendChild(child.next);\n    }\n    if (this.parent) {\n      this.parent.insertBefore(after, this.next || undefined);\n    }\n    return after;\n  }\n\n  public unwrap(): void {\n    if (this.parent) {\n      this.moveChildren(this.parent, this.next || undefined);\n    }\n    this.remove();\n  }\n\n  public update(\n    mutations: MutationRecord[],\n    _context: { [key: string]: any },\n  ): void {\n    const addedNodes: Node[] = [];\n    const removedNodes: Node[] = [];\n    mutations.forEach((mutation) => {\n      if (mutation.target === this.domNode && mutation.type === 'childList') {\n        addedNodes.push(...mutation.addedNodes);\n        removedNodes.push(...mutation.removedNodes);\n      }\n    });\n    removedNodes.forEach((node: Node) => {\n      // Check node has actually been removed\n      // One exception is Chrome does not immediately remove IFRAMEs\n      // from DOM but MutationRecord is correct in its reported removal\n      if (\n        node.parentNode != null &&\n        // @ts-expect-error Fix me later\n        node.tagName !== 'IFRAME' &&\n        document.body.compareDocumentPosition(node) &\n          Node.DOCUMENT_POSITION_CONTAINED_BY\n      ) {\n        return;\n      }\n      const blot = this.scroll.find(node);\n      if (blot == null) {\n        return;\n      }\n      if (\n        blot.domNode.parentNode == null ||\n        blot.domNode.parentNode === this.domNode\n      ) {\n        blot.detach();\n      }\n    });\n    addedNodes\n      .filter((node) => {\n        return node.parentNode === this.domNode && node !== this.uiNode;\n      })\n      .sort((a, b) => {\n        if (a === b) {\n          return 0;\n        }\n        if (a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING) {\n          return 1;\n        }\n        return -1;\n      })\n      .forEach((node) => {\n        let refBlot: Blot | null = null;\n        if (node.nextSibling != null) {\n          refBlot = this.scroll.find(node.nextSibling);\n        }\n        const blot = makeAttachedBlot(node, this.scroll);\n        if (blot.next !== refBlot || blot.next == null) {\n          if (blot.parent != null) {\n            blot.parent.removeChild(this);\n          }\n          this.insertBefore(blot, refBlot || undefined);\n        }\n      });\n    this.enforceAllowedChildren();\n  }\n}\n\nexport default ParentBlot;\n","import Attributor from '../attributor/attributor.js';\nimport AttributorStore from '../attributor/store.js';\nimport Scope from '../scope.js';\nimport type {\n  Blot,\n  BlotConstructor,\n  Formattable,\n  Parent,\n  Root,\n} from './abstract/blot.js';\nimport LeafBlot from './abstract/leaf.js';\nimport ParentBlot from './abstract/parent.js';\n\n// Shallow object comparison\nfunction isEqual(\n  obj1: Record<string, unknown>,\n  obj2: Record<string, unknown>,\n): boolean {\n  if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n    return false;\n  }\n  for (const prop in obj1) {\n    if (obj1[prop] !== obj2[prop]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nclass InlineBlot extends ParentBlot implements Formattable {\n  public static allowedChildren: BlotConstructor[] = [InlineBlot, LeafBlot];\n  public static blotName = 'inline';\n  public static scope = Scope.INLINE_BLOT;\n  public static tagName: string | string[] = 'SPAN';\n\n  static create(value?: unknown) {\n    return super.create(value) as HTMLElement;\n  }\n\n  public static formats(domNode: HTMLElement, scroll: Root): any {\n    const match = scroll.query(InlineBlot.blotName);\n    if (\n      match != null &&\n      domNode.tagName === (match as BlotConstructor).tagName\n    ) {\n      return undefined;\n    } else if (typeof this.tagName === 'string') {\n      return true;\n    } else if (Array.isArray(this.tagName)) {\n      return domNode.tagName.toLowerCase();\n    }\n    return undefined;\n  }\n\n  protected attributes: AttributorStore;\n\n  constructor(scroll: Root, domNode: Node) {\n    super(scroll, domNode);\n    this.attributes = new AttributorStore(this.domNode);\n  }\n\n  public format(name: string, value: any): void {\n    if (name === this.statics.blotName && !value) {\n      this.children.forEach((child) => {\n        if (!(child instanceof InlineBlot)) {\n          child = child.wrap(InlineBlot.blotName, true);\n        }\n        this.attributes.copy(child as InlineBlot);\n      });\n      this.unwrap();\n    } else {\n      const format = this.scroll.query(name, Scope.INLINE);\n      if (format == null) {\n        return;\n      }\n      if (format instanceof Attributor) {\n        this.attributes.attribute(format, value);\n      } else if (\n        value &&\n        (name !== this.statics.blotName || this.formats()[name] !== value)\n      ) {\n        this.replaceWith(name, value);\n      }\n    }\n  }\n\n  public formats(): { [index: string]: any } {\n    const formats = this.attributes.values();\n    const format = this.statics.formats(this.domNode, this.scroll);\n    if (format != null) {\n      formats[this.statics.blotName] = format;\n    }\n    return formats;\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    if (\n      this.formats()[name] != null ||\n      this.scroll.query(name, Scope.ATTRIBUTE)\n    ) {\n      const blot = this.isolate(index, length) as InlineBlot;\n      blot.format(name, value);\n    } else {\n      super.formatAt(index, length, name, value);\n    }\n  }\n\n  public optimize(context: { [key: string]: any }): void {\n    super.optimize(context);\n    const formats = this.formats();\n    if (Object.keys(formats).length === 0) {\n      return this.unwrap(); // unformatted span\n    }\n    const next = this.next;\n    if (\n      next instanceof InlineBlot &&\n      next.prev === this &&\n      isEqual(formats, next.formats())\n    ) {\n      next.moveChildren(this);\n      next.remove();\n    }\n  }\n\n  public replaceWith(name: string | Blot, value?: any): Blot {\n    const replacement = super.replaceWith(name, value) as InlineBlot;\n    this.attributes.copy(replacement);\n    return replacement;\n  }\n\n  public update(\n    mutations: MutationRecord[],\n    context: { [key: string]: any },\n  ): void {\n    super.update(mutations, context);\n    const attributeChanged = mutations.some(\n      (mutation) =>\n        mutation.target === this.domNode && mutation.type === 'attributes',\n    );\n    if (attributeChanged) {\n      this.attributes.build();\n    }\n  }\n\n  public wrap(name: string | Parent, value?: any): Parent {\n    const wrapper = super.wrap(name, value);\n    if (wrapper instanceof InlineBlot) {\n      this.attributes.move(wrapper);\n    }\n    return wrapper;\n  }\n}\n\nexport default InlineBlot;\n","import Attributor from '../attributor/attributor.js';\nimport AttributorStore from '../attributor/store.js';\nimport Scope from '../scope.js';\nimport type {\n  Blot,\n  BlotConstructor,\n  Formattable,\n  Root,\n} from './abstract/blot.js';\nimport LeafBlot from './abstract/leaf.js';\nimport ParentBlot from './abstract/parent.js';\nimport InlineBlot from './inline.js';\n\nclass BlockBlot extends ParentBlot implements Formattable {\n  public static blotName = 'block';\n  public static scope = Scope.BLOCK_BLOT;\n  public static tagName: string | string[] = 'P';\n  public static allowedChildren: BlotConstructor[] = [\n    InlineBlot,\n    BlockBlot,\n    LeafBlot,\n  ];\n\n  static create(value?: unknown) {\n    return super.create(value) as HTMLElement;\n  }\n\n  public static formats(domNode: HTMLElement, scroll: Root): any {\n    const match = scroll.query(BlockBlot.blotName);\n    if (\n      match != null &&\n      domNode.tagName === (match as BlotConstructor).tagName\n    ) {\n      return undefined;\n    } else if (typeof this.tagName === 'string') {\n      return true;\n    } else if (Array.isArray(this.tagName)) {\n      return domNode.tagName.toLowerCase();\n    }\n  }\n\n  protected attributes: AttributorStore;\n\n  constructor(scroll: Root, domNode: Node) {\n    super(scroll, domNode);\n    this.attributes = new AttributorStore(this.domNode);\n  }\n\n  public format(name: string, value: any): void {\n    const format = this.scroll.query(name, Scope.BLOCK);\n    if (format == null) {\n      return;\n    } else if (format instanceof Attributor) {\n      this.attributes.attribute(format, value);\n    } else if (name === this.statics.blotName && !value) {\n      this.replaceWith(BlockBlot.blotName);\n    } else if (\n      value &&\n      (name !== this.statics.blotName || this.formats()[name] !== value)\n    ) {\n      this.replaceWith(name, value);\n    }\n  }\n\n  public formats(): { [index: string]: any } {\n    const formats = this.attributes.values();\n    const format = this.statics.formats(this.domNode, this.scroll);\n    if (format != null) {\n      formats[this.statics.blotName] = format;\n    }\n    return formats;\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    if (this.scroll.query(name, Scope.BLOCK) != null) {\n      this.format(name, value);\n    } else {\n      super.formatAt(index, length, name, value);\n    }\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    if (def == null || this.scroll.query(value, Scope.INLINE) != null) {\n      // Insert text or inline\n      super.insertAt(index, value, def);\n    } else {\n      const after = this.split(index);\n      if (after != null) {\n        const blot = this.scroll.create(value, def);\n        after.parent.insertBefore(blot, after);\n      } else {\n        throw new Error('Attempt to insertAt after block boundaries');\n      }\n    }\n  }\n\n  public replaceWith(name: string | Blot, value?: any): Blot {\n    const replacement = super.replaceWith(name, value) as BlockBlot;\n    this.attributes.copy(replacement);\n    return replacement;\n  }\n\n  public update(\n    mutations: MutationRecord[],\n    context: { [key: string]: any },\n  ): void {\n    super.update(mutations, context);\n    const attributeChanged = mutations.some(\n      (mutation) =>\n        mutation.target === this.domNode && mutation.type === 'attributes',\n    );\n    if (attributeChanged) {\n      this.attributes.build();\n    }\n  }\n}\n\nexport default BlockBlot;\n","import Scope from '../../scope.js';\nimport BlockBlot from '../block.js';\nimport ParentBlot from './parent.js';\n\nclass ContainerBlot extends ParentBlot {\n  public static blotName = 'container';\n  public static scope = Scope.BLOCK_BLOT;\n  public static tagName: string | string[];\n\n  public prev!: BlockBlot | ContainerBlot | null;\n  public next!: BlockBlot | ContainerBlot | null;\n\n  public checkMerge(): boolean {\n    return (\n      this.next !== null && this.next.statics.blotName === this.statics.blotName\n    );\n  }\n\n  public deleteAt(index: number, length: number): void {\n    super.deleteAt(index, length);\n    this.enforceAllowedChildren();\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    super.formatAt(index, length, name, value);\n    this.enforceAllowedChildren();\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    super.insertAt(index, value, def);\n    this.enforceAllowedChildren();\n  }\n\n  public optimize(context: { [key: string]: any }): void {\n    super.optimize(context);\n    if (this.children.length > 0 && this.next != null && this.checkMerge()) {\n      this.next.moveChildren(this);\n      this.next.remove();\n    }\n  }\n}\n\nexport default ContainerBlot;\n","import type { Formattable, Root } from './abstract/blot.js';\nimport LeafBlot from './abstract/leaf.js';\n\nclass EmbedBlot extends LeafBlot implements Formattable {\n  public static formats(_domNode: HTMLElement, _scroll: Root): any {\n    return undefined;\n  }\n\n  public format(name: string, value: any): void {\n    // super.formatAt wraps, which is what we want in general,\n    // but this allows subclasses to overwrite for formats\n    // that just apply to particular embeds\n    super.formatAt(0, this.length(), name, value);\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    if (index === 0 && length === this.length()) {\n      this.format(name, value);\n    } else {\n      super.formatAt(index, length, name, value);\n    }\n  }\n\n  public formats(): { [index: string]: any } {\n    return this.statics.formats(this.domNode, this.scroll);\n  }\n}\n\nexport default EmbedBlot;\n","import Registry, { type RegistryDefinition } from '../registry.js';\nimport Scope from '../scope.js';\nimport type { Blot, BlotConstructor, Root } from './abstract/blot.js';\nimport ContainerBlot from './abstract/container.js';\nimport ParentBlot from './abstract/parent.js';\nimport BlockBlot from './block.js';\n\nconst OBSERVER_CONFIG = {\n  attributes: true,\n  characterData: true,\n  characterDataOldValue: true,\n  childList: true,\n  subtree: true,\n};\n\nconst MAX_OPTIMIZE_ITERATIONS = 100;\n\nclass ScrollBlot extends ParentBlot implements Root {\n  public static blotName = 'scroll';\n  public static defaultChild = BlockBlot;\n  public static allowedChildren: BlotConstructor[] = [BlockBlot, ContainerBlot];\n  public static scope = Scope.BLOCK_BLOT;\n  public static tagName = 'DIV';\n\n  public observer: MutationObserver;\n\n  constructor(\n    public registry: Registry,\n    node: HTMLDivElement,\n  ) {\n    // @ts-expect-error scroll is the root with no parent\n    super(null, node);\n    this.scroll = this;\n    this.build();\n    this.observer = new MutationObserver((mutations: MutationRecord[]) => {\n      this.update(mutations);\n    });\n    this.observer.observe(this.domNode, OBSERVER_CONFIG);\n    this.attach();\n  }\n\n  public create(input: Node | string | Scope, value?: any): Blot {\n    return this.registry.create(this, input, value);\n  }\n\n  public find(node: Node | null, bubble = false): Blot | null {\n    const blot = this.registry.find(node, bubble);\n    if (!blot) {\n      return null;\n    }\n    if (blot.scroll === this) {\n      return blot;\n    }\n    return bubble ? this.find(blot.scroll.domNode.parentNode, true) : null;\n  }\n\n  public query(\n    query: string | Node | Scope,\n    scope: Scope = Scope.ANY,\n  ): RegistryDefinition | null {\n    return this.registry.query(query, scope);\n  }\n\n  public register(...definitions: RegistryDefinition[]) {\n    return this.registry.register(...definitions);\n  }\n\n  public build(): void {\n    if (this.scroll == null) {\n      return;\n    }\n    super.build();\n  }\n\n  public detach(): void {\n    super.detach();\n    this.observer.disconnect();\n  }\n\n  public deleteAt(index: number, length: number): void {\n    this.update();\n    if (index === 0 && length === this.length()) {\n      this.children.forEach((child) => {\n        child.remove();\n      });\n    } else {\n      super.deleteAt(index, length);\n    }\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    this.update();\n    super.formatAt(index, length, name, value);\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    this.update();\n    super.insertAt(index, value, def);\n  }\n\n  public optimize(context?: { [key: string]: any }): void;\n  public optimize(\n    mutations: MutationRecord[],\n    context: { [key: string]: any },\n  ): void;\n  public optimize(mutations: any = [], context: any = {}): void {\n    super.optimize(context);\n    const mutationsMap = context.mutationsMap || new WeakMap();\n    // We must modify mutations directly, cannot make copy and then modify\n    let records = Array.from(this.observer.takeRecords());\n    // Array.push currently seems to be implemented by a non-tail recursive function\n    // so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());\n    while (records.length > 0) {\n      mutations.push(records.pop());\n    }\n    const mark = (blot: Blot | null, markParent = true): void => {\n      if (blot == null || blot === this) {\n        return;\n      }\n      if (blot.domNode.parentNode == null) {\n        return;\n      }\n      if (!mutationsMap.has(blot.domNode)) {\n        mutationsMap.set(blot.domNode, []);\n      }\n      if (markParent) {\n        mark(blot.parent);\n      }\n    };\n    const optimize = (blot: Blot): void => {\n      // Post-order traversal\n      if (!mutationsMap.has(blot.domNode)) {\n        return;\n      }\n      if (blot instanceof ParentBlot) {\n        blot.children.forEach(optimize);\n      }\n      mutationsMap.delete(blot.domNode);\n      blot.optimize(context);\n    };\n    let remaining = mutations;\n    for (let i = 0; remaining.length > 0; i += 1) {\n      if (i >= MAX_OPTIMIZE_ITERATIONS) {\n        throw new Error('[Parchment] Maximum optimize iterations reached');\n      }\n      remaining.forEach((mutation: MutationRecord) => {\n        const blot = this.find(mutation.target, true);\n        if (blot == null) {\n          return;\n        }\n        if (blot.domNode === mutation.target) {\n          if (mutation.type === 'childList') {\n            mark(this.find(mutation.previousSibling, false));\n            Array.from(mutation.addedNodes).forEach((node: Node) => {\n              const child = this.find(node, false);\n              mark(child, false);\n              if (child instanceof ParentBlot) {\n                child.children.forEach((grandChild: Blot) => {\n                  mark(grandChild, false);\n                });\n              }\n            });\n          } else if (mutation.type === 'attributes') {\n            mark(blot.prev);\n          }\n        }\n        mark(blot);\n      });\n      this.children.forEach(optimize);\n      remaining = Array.from(this.observer.takeRecords());\n      records = remaining.slice();\n      while (records.length > 0) {\n        mutations.push(records.pop());\n      }\n    }\n  }\n\n  public update(\n    mutations?: MutationRecord[],\n    context: { [key: string]: any } = {},\n  ): void {\n    mutations = mutations || this.observer.takeRecords();\n    const mutationsMap = new WeakMap();\n    mutations\n      .map((mutation: MutationRecord) => {\n        const blot = this.find(mutation.target, true);\n        if (blot == null) {\n          return null;\n        }\n        if (mutationsMap.has(blot.domNode)) {\n          mutationsMap.get(blot.domNode).push(mutation);\n          return null;\n        } else {\n          mutationsMap.set(blot.domNode, [mutation]);\n          return blot;\n        }\n      })\n      .forEach((blot: Blot | null) => {\n        if (blot != null && blot !== this && mutationsMap.has(blot.domNode)) {\n          blot.update(mutationsMap.get(blot.domNode) || [], context);\n        }\n      });\n    context.mutationsMap = mutationsMap;\n    if (mutationsMap.has(this.domNode)) {\n      super.update(mutationsMap.get(this.domNode), context);\n    }\n    this.optimize(mutations, context);\n  }\n}\n\nexport default ScrollBlot;\n","import Scope from '../scope.js';\nimport type { Blot, Leaf, Root } from './abstract/blot.js';\nimport LeafBlot from './abstract/leaf.js';\n\nclass TextBlot extends LeafBlot implements Leaf {\n  public static readonly blotName = 'text';\n  public static scope = Scope.INLINE_BLOT;\n\n  public static create(value: string): Text {\n    return document.createTextNode(value);\n  }\n\n  public static value(domNode: Text): string {\n    return domNode.data;\n  }\n\n  public domNode!: Text;\n  protected text: string;\n\n  constructor(scroll: Root, node: Node) {\n    super(scroll, node);\n    this.text = this.statics.value(this.domNode);\n  }\n\n  public deleteAt(index: number, length: number): void {\n    this.domNode.data = this.text =\n      this.text.slice(0, index) + this.text.slice(index + length);\n  }\n\n  public index(node: Node, offset: number): number {\n    if (this.domNode === node) {\n      return offset;\n    }\n    return -1;\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    if (def == null) {\n      this.text = this.text.slice(0, index) + value + this.text.slice(index);\n      this.domNode.data = this.text;\n    } else {\n      super.insertAt(index, value, def);\n    }\n  }\n\n  public length(): number {\n    return this.text.length;\n  }\n\n  public optimize(context: { [key: string]: any }): void {\n    super.optimize(context);\n    this.text = this.statics.value(this.domNode);\n    if (this.text.length === 0) {\n      this.remove();\n    } else if (this.next instanceof TextBlot && this.next.prev === this) {\n      this.insertAt(this.length(), (this.next as TextBlot).value());\n      this.next.remove();\n    }\n  }\n\n  public position(index: number, _inclusive = false): [Node, number] {\n    return [this.domNode, index];\n  }\n\n  public split(index: number, force = false): Blot | null {\n    if (!force) {\n      if (index === 0) {\n        return this;\n      }\n      if (index === this.length()) {\n        return this.next;\n      }\n    }\n    const after = this.scroll.create(this.domNode.splitText(index));\n    this.parent.insertBefore(after, this.next || undefined);\n    this.text = this.statics.value(this.domNode);\n    return after;\n  }\n\n  public update(\n    mutations: MutationRecord[],\n    _context: { [key: string]: any },\n  ): void {\n    if (\n      mutations.some((mutation) => {\n        return (\n          mutation.type === 'characterData' && mutation.target === this.domNode\n        );\n      })\n    ) {\n      this.text = this.statics.value(this.domNode);\n    }\n  }\n\n  public value(): string {\n    return this.text;\n  }\n}\n\nexport default TextBlot;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAK,IAAAA,KAAA,4BAAAC,MAAA;EAAA,OACHA,MAAA,CAAAA,MAAA,CAAAC,IAAA,GAAQ,CAAR,YACAD,MAAA,CAAAA,MAAA,CAAAE,KAAA,GAAU,EAAV,aAEAF,MAAA,CAAAA,MAAA,CAAAG,SAAA,GAAa,EAAb,iBACAH,MAAA,CAAAA,MAAA,CAAAI,IAAA,GAAQ,EAAR,YACAJ,MAAA,CAAAA,MAAA,CAAAK,MAAA,GAAU,CAAV,cACAL,MAAA,CAAAA,MAAA,CAAAM,KAAA,GAAS,EAAT,aAEAN,MAAA,CAAAA,MAAA,CAAAO,UAAA,GAAa,EAAb,kBACAP,MAAA,CAAAA,MAAA,CAAAQ,WAAA,GAAc,CAAd,mBACAR,MAAA,CAAAA,MAAA,CAAAS,eAAA,GAAkB,CAAlB,uBACAT,MAAA,CAAAA,MAAA,CAAAU,gBAAA,GAAmB,CAAnB,wBAEAV,MAAA,CAAAA,MAAA,CAAAW,GAAA,GAAM,EAAN,WAdGX,MAAA;AAAA,EAAAD,KAAA;AAAA,ICOgBa,UAAA;EAQnB,SAAAA,WACkBC,QAAA,EACAC,OAAA,EAEhB;IAAA,IADAC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAA6B;IAAAG,eAAA,OAAAP,UAAA;IAFb,KAAAC,QAAA,GAAAA,QAAA,EACA,KAAAC,OAAA,GAAAA,OAAA;IAGV,IAAAM,YAAA,GAAerB,KAAA,CAAME,IAAA,GAAOF,KAAA,CAAMI,SAAA;IACnC,KAAAkB,KAAA,GACHN,OAAA,CAAQM,KAAA,IAAS;IAAA;IAEZN,OAAA,CAAQM,KAAA,GAAQtB,KAAA,CAAMG,KAAA,GAASkB,YAAA,GAChCrB,KAAA,CAAMI,SAAA,EACRY,OAAA,CAAQO,SAAA,IAAa,SACvB,KAAKA,SAAA,GAAYP,OAAA,CAAQO,SAAA;EAE7B;EAAA,OAAAC,YAAA,CAAAX,UAAA;IAAAY,GAAA;IAAAC,KAAA,EAEO,SAAAC,IAAIC,IAAA,EAAmBF,KAAA,EAAqB;MACjD,OAAK,KAAKG,MAAA,CAAOD,IAAA,EAAMF,KAAK,KAGvBE,IAAA,CAAAE,YAAA,CAAa,KAAKf,OAAA,EAASW,KAAK,GAC9B,MAHE;IAIX;EAAA;IAAAD,GAAA;IAAAC,KAAA,EAEO,SAAAG,OAAOE,KAAA,EAAoBL,KAAA,EAAqB;MACjD,YAAKH,SAAA,IAAa,OACb,KAEL,OAAOG,KAAA,IAAU,WACZ,KAAKH,SAAA,CAAUS,OAAA,CAAQN,KAAA,CAAMO,OAAA,CAAQ,SAAS,EAAE,CAAC,IAAI,KAErD,KAAKV,SAAA,CAAUS,OAAA,CAAQN,KAAK,IAAI;IAE3C;EAAA;IAAAD,GAAA;IAAAC,KAAA,EAEO,SAAAQ,OAAON,IAAA,EAAyB;MAChCA,IAAA,CAAAO,eAAA,CAAgB,KAAKpB,OAAO;IACnC;EAAA;IAAAU,GAAA;IAAAC,KAAA,EAEO,SAAAA,MAAME,IAAA,EAAwB;MACnC,IAAMF,KAAA,GAAQE,IAAA,CAAKQ,YAAA,CAAa,KAAKrB,OAAO;MAC5C,OAAI,KAAKc,MAAA,CAAOD,IAAA,EAAMF,KAAK,KAAKA,KAAA,GACvBA,KAAA,GAEF;IACT;EAAA;IAAAD,GAAA;IAAAC,KAAA,EApDA,SAAcW,KAAKT,IAAA,EAA6B;MACvC,OAAAU,KAAA,CAAMC,IAAA,CAAKX,IAAA,CAAKY,UAAU,EAAEC,GAAA,CAAI,UAACC,IAAA;QAAA,OAAeA,IAAA,CAAKC,IAAI;MAAA;IAClE;EAAA;AAAA;AAAA,ICVmBC,cAAA,0BAAAC,MAAA;EAKnB,SAAAD,eAAYE,OAAA,EAAiB;IAAA,IAAAC,KAAA;IAAA3B,eAAA,OAAAwB,cAAA;IAC3BE,OAAA,GAAU,iBAAiBA,OAAA,EAAAC,KAAA,GAAAC,UAAA,OAAAJ,cAAA,GACrBE,OAAO,IACbC,KAAA,CAAKD,OAAA,GAAUA,OAAA,EACVC,KAAA,CAAAJ,IAAA,GAAOI,KAAA,CAAKE,WAAA,CAAYN,IAAA;IAAA,OAAAI,KAAA;EAC/B;EAAAG,SAAA,CAAAN,cAAA,EAAAC,MAAA;EAAA,OAAArB,YAAA,CAAAoB,cAAA;AAAA,eAAAO,gBAAA,CAV0CC,KAAA;ACiB5C,IAAqBC,SAAA;EAArB,SAAAA,UAAA;IAAAjC,eAAA,OAAAiC,SAAA;IA0BE,KAAQb,UAAA,GAA4C,IACpD,KAAQc,OAAA,GAA8C,IACtD,KAAQC,IAAA,GAA2C,IACnD,KAAQC,KAAA,GAA+C;EAAC;EAAA,OAAAhC,YAAA,CAAA6B,SAAA;IAAA5B,GAAA;IAAAC,KAAA,EAEjD,SAAA+B,OAAOC,MAAA,EAAcC,KAAA,EAA8BjC,KAAA,EAAmB;MACrE,IAAAkC,MAAA,GAAQ,KAAKC,KAAA,CAAMF,KAAK;MAC9B,IAAIC,MAAA,IAAS,MACX,MAAM,IAAIhB,cAAA,qBAAAkB,MAAA,CAAmCH,KAAK,UAAO;MAE3D,IAAMI,SAAA,GAAYH,MAAA;QACZhC,IAAA;QAAA;QAEJ+B,KAAA,YAAiBK,IAAA,IAAQL,KAAA,CAAMM,QAAA,KAAaD,IAAA,CAAKE,SAAA,GAC7CP,KAAA,GACAI,SAAA,CAAUN,MAAA,CAAO/B,KAAK;QAEtByC,IAAA,GAAO,IAAIJ,SAAA,CAAUL,MAAA,EAAQ9B,IAAA,EAAcF,KAAK;MACtD,OAAA2B,SAAA,CAASe,KAAA,CAAMC,GAAA,CAAIF,IAAA,CAAKG,OAAA,EAASH,IAAI,GAC9BA,IAAA;IACT;EAAA;IAAA1C,GAAA;IAAAC,KAAA,EAEO,SAAA6C,KAAK3C,IAAA,EAAgD;MAAA,IAA7B4C,MAAA,GAAAvD,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAS;MAC/B,OAAAoC,SAAA,CAASkB,IAAA,CAAK3C,IAAA,EAAM4C,MAAM;IACnC;EAAA;IAAA/C,GAAA;IAAAC,KAAA,EAEO,SAAAmC,MACLA,MAAA,EAE2B;MAAA,IAAAY,MAAA;MAAA,IAD3BnD,KAAA,GAAAL,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAejB,KAAA,CAAMY,GAAA;MAEjB,IAAAgD,MAAA;MAuBJ,OAtBI,OAAOC,MAAA,IAAU,WACnBD,MAAA,GAAQ,KAAKJ,KAAA,CAAMK,MAAK,KAAK,KAAKrB,UAAA,CAAWqB,MAAK,IAEzCA,MAAA,YAAiBa,IAAA,IAAQb,MAAA,CAAMI,QAAA,KAAaD,IAAA,CAAKE,SAAA,GAC1DN,MAAA,GAAQ,KAAKJ,KAAA,CAAMmB,IAAA,GACV,OAAOd,MAAA,IAAU,WACtBA,MAAA,GAAQ7D,KAAA,CAAMG,KAAA,GAAQH,KAAA,CAAMO,KAAA,GAC9BqD,MAAA,GAAQ,KAAKJ,KAAA,CAAMoB,KAAA,GACVf,MAAA,GAAQ7D,KAAA,CAAMG,KAAA,GAAQH,KAAA,CAAMM,MAAA,KACrCsD,MAAA,GAAQ,KAAKJ,KAAA,CAAMqB,MAAA,IAEZhB,MAAA,YAAiBiB,OAAA,MACXjB,MAAA,CAAMzB,YAAA,CAAa,OAAO,KAAK,IAAI2C,KAAA,CAAM,KAAK,EACvDC,IAAA,CAAK,UAACrC,IAAA;QAAA,OACFiB,MAAA,GAAAa,MAAA,CAAKnB,OAAA,CAAQX,IAAI,GACrB,EAAAiB,MAAA;MAAA,CAIL,GACDA,MAAA,GAAQA,MAAA,IAAS,KAAKL,IAAA,CAAKM,MAAA,CAAMoB,OAAO,IAEtCrB,MAAA,IAAS,OACJ,OAGP,WAAWA,MAAA,IACXtC,KAAA,GAAQtB,KAAA,CAAMG,KAAA,GAAQyD,MAAA,CAAMtC,KAAA,IAC5BA,KAAA,GAAQtB,KAAA,CAAME,IAAA,GAAO0D,MAAA,CAAMtC,KAAA,GAEpBsC,MAAA,GAEF;IACT;EAAA;IAAAnC,GAAA;IAAAC,KAAA,EAEO,SAAAwD,SAAA,EAAqE;MAAA,IAAAC,MAAA;MAAA,SAAAC,IAAA,GAAAnE,SAAA,CAAAC,MAAA,EAAzDmE,WAAA,OAAA/C,KAAA,CAAA8C,IAAA,GAAAE,IAAA,MAAAA,IAAA,GAAAF,IAAA,EAAAE,IAAA;QAAAD,WAAA,CAAAC,IAAA,IAAArE,SAAA,CAAAqE,IAAA;MAAA;MACV,OAAAD,WAAA,CAAY5C,GAAA,CAAI,UAAC8C,UAAA,EAAe;QACrC,IAAMC,MAAA,GAAS,cAAcD,UAAA;UACvBE,MAAA,GAAS,cAAcF,UAAA;QACzB,KAACC,MAAA,IAAU,CAACC,MAAA,EACR,UAAI7C,cAAA,CAAe,oBAAoB;QACpC,IAAA4C,MAAA,IAAUD,UAAA,CAAWG,QAAA,KAAa,YACrC,UAAI9C,cAAA,CAAe,gCAAgC;QAE3D,IAAMnB,GAAA,GAAM+D,MAAA,GACRD,UAAA,CAAWG,QAAA,GACXD,MAAA,GACEF,UAAA,CAAWzE,QAAA,GACV;QACF,OAAAqE,MAAA,CAAA3B,KAAA,CAAM/B,GAAG,IAAI8D,UAAA,EAEdE,MAAA,GACE,OAAOF,UAAA,CAAWxE,OAAA,IAAY,aAC3BoE,MAAA,CAAA3C,UAAA,CAAW+C,UAAA,CAAWxE,OAAO,IAAIwE,UAAA,IAE/BC,MAAA,KACLD,UAAA,CAAWI,SAAA,KACRR,MAAA,CAAA7B,OAAA,CAAQiC,UAAA,CAAWI,SAAS,IAAIJ,UAAA,GAEnCA,UAAA,CAAWN,OAAA,KACT3C,KAAA,CAAMsD,OAAA,CAAQL,UAAA,CAAWN,OAAO,IAClCM,UAAA,CAAWN,OAAA,GAAUM,UAAA,CAAWN,OAAA,CAAQxC,GAAA,CAAI,UAACwC,OAAA;UAAA,OACpCA,OAAA,CAAQY,WAAA,EAChB;QAAA,KAEUN,UAAA,CAAAN,OAAA,GAAUM,UAAA,CAAWN,OAAA,CAAQY,WAAA,CAAY,IAErCvD,KAAA,CAAMsD,OAAA,CAAQL,UAAA,CAAWN,OAAO,IAC7CM,UAAA,CAAWN,OAAA,GACX,CAACM,UAAA,CAAWN,OAAO,GACda,OAAA,CAAQ,UAACC,GAAA,EAAgB;UAChC,CAAIZ,MAAA,CAAK5B,IAAA,CAAKwC,GAAG,KAAK,QAAQR,UAAA,CAAWI,SAAA,IAAa,UAC/CR,MAAA,CAAA5B,IAAA,CAAKwC,GAAG,IAAIR,UAAA;QACnB,CACD,KAGEA,UAAA;MAAA,CACR;IACH;EAAA;IAAA9D,GAAA;IAAAC,KAAA,EArIA,SAAc6C,KAAK3C,IAAA,EAAiD;MAAA,IAA7B4C,MAAA,GAAAvD,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAS;MAC9C,IAAIW,IAAA,IAAQ,MACH;MAET,IAAI,KAAKwC,KAAA,CAAM4B,GAAA,CAAIpE,IAAI,GACrB,OAAO,KAAKwC,KAAA,CAAM6B,GAAA,CAAIrE,IAAI,KAAK;MAEjC,IAAI4C,MAAA,EAAQ;QACV,IAAI0B,UAAA,GAA0B;QAC1B;UACFA,UAAA,GAAatE,IAAA,CAAKsE,UAAA;QAAA,SAAAC,OAAA,EACN;UAKL;QACT;QACO,YAAK5B,IAAA,CAAK2B,UAAA,EAAY1B,MAAM;MACrC;MACO;IACT;EAAA;AAAA,GAiHF;AAxIgBnB,SAAA,CAAAe,KAAA,sBAAYgC,OAAA;AAD5B,IAAqBC,QAAA,GAArBhD,SAAA;ACfA,SAASiD,MAAM1E,IAAA,EAAmB2E,MAAA,EAA0B;EAE1D,QADkB3E,IAAA,CAAKQ,YAAA,CAAa,OAAO,KAAK,IAE7C2C,KAAA,CAAM,KAAK,EACXyB,MAAA,CAAO,UAAC7D,IAAA;IAAA,OAASA,IAAA,CAAKX,OAAA,IAAA8B,MAAA,CAAWyC,MAAM,MAAG,MAAM,CAAC;EAAA;AACtD;AAAA,IAEME,eAAA,0BAAAC,WAAA;EAAA,SAAAD,gBAAA;IAAArF,eAAA,OAAAqF,eAAA;IAAA,OAAAzD,UAAA,OAAAyD,eAAA,EAAAxF,SAAA;EAAA;EAAAiC,SAAA,CAAAuD,eAAA,EAAAC,WAAA;EAAA,OAAAlF,YAAA,CAAAiF,eAAA;IAAAhF,GAAA;IAAAC,KAAA,EAOG,SAAAC,IAAIC,IAAA,EAAmBF,KAAA,EAAqB;MACjD,OAAK,KAAKG,MAAA,CAAOD,IAAA,EAAMF,KAAK,KAG5B,KAAKQ,MAAA,CAAON,IAAI,GAChBA,IAAA,CAAK+E,SAAA,CAAUhF,GAAA,IAAAmC,MAAA,CAAO,KAAK/C,OAAO,OAAA+C,MAAA,CAAIpC,KAAK,CAAE,GACtC,MAJE;IAKX;EAAA;IAAAD,GAAA;IAAAC,KAAA,EAEO,SAAAQ,OAAON,IAAA,EAAyB;MACrB0E,KAAA,CAAM1E,IAAA,EAAM,KAAKb,OAAO,EAChC+E,OAAA,CAAQ,UAACnD,IAAA,EAAS;QACnBf,IAAA,CAAA+E,SAAA,CAAUzE,MAAA,CAAOS,IAAI;MAAA,CAC3B,GACGf,IAAA,CAAK+E,SAAA,CAAUzF,MAAA,KAAW,KAC5BU,IAAA,CAAKO,eAAA,CAAgB,OAAO;IAEhC;EAAA;IAAAV,GAAA;IAAAC,KAAA,EAEO,SAAAA,MAAME,IAAA,EAAwB;MAEnC,IAAMF,KAAA,IADS4E,KAAA,CAAM1E,IAAA,EAAM,KAAKb,OAAO,EAAE,CAAC,KAAK,IAC1B6F,KAAA,CAAM,KAAK7F,OAAA,CAAQG,MAAA,GAAS,CAAC;MAClD,OAAO,KAAKW,MAAA,CAAOD,IAAA,EAAMF,KAAK,IAAIA,KAAA,GAAQ;IAC5C;EAAA;IAAAD,GAAA;IAAAC,KAAA,EA7BA,SAAcW,KAAKT,IAAA,EAA6B;MACtC,QAAAA,IAAA,CAAKQ,YAAA,CAAa,OAAO,KAAK,IACnC2C,KAAA,CAAM,KAAK,EACXtC,GAAA,CAAI,UAACE,IAAA;QAAA,OAASA,IAAA,CAAKoC,KAAA,CAAM,GAAG,EAAE6B,KAAA,CAAM,GAAG,EAAE,EAAEC,IAAA,CAAK,GAAG,CAAC;MAAA;IACzD;EAAA;AAAA,EAL4BhG,UAAA;AAiC9B,IAAAiG,iBAAA,GAAeL,eAAA;ACxCf,SAASM,SAASpE,IAAA,EAAsB;EAChC,IAAAqE,KAAA,GAAQrE,IAAA,CAAKoC,KAAA,CAAM,GAAG;IACtBkC,IAAA,GAAOD,KAAA,CACVJ,KAAA,CAAM,CAAC,EACPnE,GAAA,CAAI,UAACyE,IAAA;MAAA,OAAiBA,IAAA,CAAK,CAAC,EAAErB,WAAA,KAAgBqB,IAAA,CAAKN,KAAA,CAAM,CAAC,CAAC;IAAA,GAC3DC,IAAA,CAAK,EAAE;EACH,OAAAG,KAAA,CAAM,CAAC,IAAIC,IAAA;AACpB;AAAA,IAEME,eAAA,0BAAAC,YAAA;EAAA,SAAAD,gBAAA;IAAA/F,eAAA,OAAA+F,eAAA;IAAA,OAAAnE,UAAA,OAAAmE,eAAA,EAAAlG,SAAA;EAAA;EAAAiC,SAAA,CAAAiE,eAAA,EAAAC,YAAA;EAAA,OAAA5F,YAAA,CAAA2F,eAAA;IAAA1F,GAAA;IAAAC,KAAA,EAQG,SAAAC,IAAIC,IAAA,EAAmBF,KAAA,EAAqB;MACjD,OAAK,KAAKG,MAAA,CAAOD,IAAA,EAAMF,KAAK,KAI5BE,IAAA,CAAKyF,KAAA,CAAMN,QAAA,CAAS,KAAKhG,OAAO,CAAC,IAAIW,KAAA,EAC9B,MAJE;IAKX;EAAA;IAAAD,GAAA;IAAAC,KAAA,EAEO,SAAAQ,OAAON,IAAA,EAAyB;MAErCA,IAAA,CAAKyF,KAAA,CAAMN,QAAA,CAAS,KAAKhG,OAAO,CAAC,IAAI,IAChCa,IAAA,CAAKQ,YAAA,CAAa,OAAO,KAC5BR,IAAA,CAAKO,eAAA,CAAgB,OAAO;IAEhC;EAAA;IAAAV,GAAA;IAAAC,KAAA,EAEO,SAAAA,MAAME,IAAA,EAAwB;MAEnC,IAAMF,KAAA,GAAQE,IAAA,CAAKyF,KAAA,CAAMN,QAAA,CAAS,KAAKhG,OAAO,CAAC;MAC/C,OAAO,KAAKc,MAAA,CAAOD,IAAA,EAAMF,KAAK,IAAIA,KAAA,GAAQ;IAC5C;EAAA;IAAAD,GAAA;IAAAC,KAAA,EA5BA,SAAcW,KAAKT,IAAA,EAA6B;MACtC,QAAAA,IAAA,CAAKQ,YAAA,CAAa,OAAO,KAAK,IAAI2C,KAAA,CAAM,GAAG,EAAEtC,GAAA,CAAI,UAACf,KAAA;QAAA,OAC5CA,KAAA,CAAMqD,KAAA,CAAM,GAAG,EAChB,CAAC,EAAEuC,IAAA,EACf;MAAA;IACH;EAAA;AAAA,EAN4BzG,UAAA;AAgC9B,IAAA0G,iBAAA,GAAeJ,eAAA;AAAA,ICpCTK,eAAA;EAIJ,SAAAA,gBAAYlD,OAAA,EAAsB;IAAAlD,eAAA,OAAAoG,eAAA;IAHlC,KAAQhF,UAAA,GAA4C,IAIlD,KAAK8B,OAAA,GAAUA,OAAA,EACf,KAAKmD,KAAA,CAAM;EACb;EAAA,OAAAjG,YAAA,CAAAgG,eAAA;IAAA/F,GAAA;IAAAC,KAAA,EAEO,SAAAgG,UAAUA,UAAA,EAAuBhG,KAAA,EAAkB;MAEpDA,KAAA,GACEgG,UAAA,CAAU/F,GAAA,CAAI,KAAK2C,OAAA,EAAS5C,KAAK,MAC/BgG,UAAA,CAAUhG,KAAA,CAAM,KAAK4C,OAAO,KAAK,OAC9B,KAAA9B,UAAA,CAAWkF,UAAA,CAAU5G,QAAQ,IAAI4G,UAAA,GAE/B,YAAKlF,UAAA,CAAWkF,UAAA,CAAU5G,QAAQ,MAInC4G,UAAA,CAAAxF,MAAA,CAAO,KAAKoC,OAAO,GACtB,YAAK9B,UAAA,CAAWkF,UAAA,CAAU5G,QAAQ;IAE7C;EAAA;IAAAW,GAAA;IAAAC,KAAA,EAEO,SAAA+F,MAAA,EAAc;MAAA,IAAAE,MAAA;MACnB,KAAKnF,UAAA,GAAa;MAClB,IAAM2B,IAAA,GAAOkC,QAAA,CAAS9B,IAAA,CAAK,KAAKD,OAAO;MACvC,IAAIH,IAAA,IAAQ,MACV;MAEF,IAAM3B,UAAA,GAAa3B,UAAA,CAAWwB,IAAA,CAAK,KAAKiC,OAAO;QACzChB,OAAA,GAAUwD,iBAAA,CAAgBzE,IAAA,CAAK,KAAKiC,OAAO;QAC3CsD,MAAA,GAASL,iBAAA,CAAgBlF,IAAA,CAAK,KAAKiC,OAAO;MAE7C9B,UAAA,CAAAsB,MAAA,CAAOR,OAAO,EACdQ,MAAA,CAAO8D,MAAM,EACb9B,OAAA,CAAQ,UAACnD,IAAA,EAAS;QACjB,IAAMkF,IAAA,GAAO1D,IAAA,CAAKT,MAAA,CAAOG,KAAA,CAAMlB,IAAA,EAAM3C,KAAA,CAAMI,SAAS;QAChDyH,IAAA,YAAgBhH,UAAA,KACb8G,MAAA,CAAAnF,UAAA,CAAWqF,IAAA,CAAK/G,QAAQ,IAAI+G,IAAA;MACnC,CACD;IACL;EAAA;IAAApG,GAAA;IAAAC,KAAA,EAEO,SAAAoG,KAAKC,MAAA,EAA2B;MAAA,IAAAC,MAAA;MACrCC,MAAA,CAAO5F,IAAA,CAAK,KAAKG,UAAU,EAAEsD,OAAA,CAAQ,UAACrE,GAAA,EAAQ;QAC5C,IAAMC,KAAA,GAAQsG,MAAA,CAAKxF,UAAA,CAAWf,GAAG,EAAEC,KAAA,CAAMsG,MAAA,CAAK1D,OAAO;QAC9CyD,MAAA,CAAAG,MAAA,CAAOzG,GAAA,EAAKC,KAAK;MAAA,CACzB;IACH;EAAA;IAAAD,GAAA;IAAAC,KAAA,EAEO,SAAAyG,KAAKJ,MAAA,EAA2B;MAAA,IAAAK,MAAA;MACrC,KAAKN,IAAA,CAAKC,MAAM,GAChBE,MAAA,CAAO5F,IAAA,CAAK,KAAKG,UAAU,EAAEsD,OAAA,CAAQ,UAACrE,GAAA,EAAQ;QAC5C2G,MAAA,CAAK5F,UAAA,CAAWf,GAAG,EAAES,MAAA,CAAOkG,MAAA,CAAK9D,OAAO;MAAA,CACzC,GACD,KAAK9B,UAAA,GAAa;IACpB;EAAA;IAAAf,GAAA;IAAAC,KAAA,EAEO,SAAA2G,OAAA,EAAiC;MAAA,IAAAC,MAAA;MACtC,OAAOL,MAAA,CAAO5F,IAAA,CAAK,KAAKG,UAAU,EAAE+F,MAAA,CAClC,UAAC/F,UAAA,EAAoCG,IAAA;QAAA,OACxBH,UAAA,CAAAG,IAAI,IAAI2F,MAAA,CAAK9F,UAAA,CAAWG,IAAI,EAAEjB,KAAA,CAAM4G,MAAA,CAAKhE,OAAO,GACpD9B,UAAA;MAAA,GAET,CAAC;IAEL;EAAA;AAAA;AAGF,IAAAgG,iBAAA,GAAehB,eAAA;ECnETiB,WAAA;IA+CJ,SAAAA,YACS/E,MAAA,EACAY,OAAA,EACP;MAAAlD,eAAA,OAAAqH,WAAA;MAFO,KAAA/E,MAAA,GAAAA,MAAA,EACA,KAAAY,OAAA,GAAAA,OAAA,EAEE+B,QAAA,CAAAjC,KAAA,CAAMC,GAAA,CAAIC,OAAA,EAAS,IAAI,GAChC,KAAKoE,IAAA,GAAO,MACZ,KAAKC,IAAA,GAAO;IACd;IAAA,OAAAnH,YAAA,CAAAiH,WAAA;MAAAhH,GAAA;MAAAwE,GAAA;MAlBA;MAQA,SAAAA,IAAA,EAAmB;QACjB,OAAO,KAAKhD,WAAA;MACd;IAAA;MAAAxB,GAAA;MAAAC,KAAA,EAUO,SAAAkH,OAAA,EAAe,CAEtB;IAAA;MAAAnH,GAAA;MAAAC,KAAA,EAEO,SAAAmH,MAAA,EAAc;QACnB,IAAMvE,OAAA,GAAU,KAAKA,OAAA,CAAQwE,SAAA,CAAU,EAAK;QACrC,YAAKpF,MAAA,CAAOD,MAAA,CAAOa,OAAO;MACnC;IAAA;MAAA7C,GAAA;MAAAC,KAAA,EAEO,SAAAqH,OAAA,EAAe;QAChB,KAAKC,MAAA,IAAU,QACZ,KAAAA,MAAA,CAAOC,WAAA,CAAY,IAAI,GAErB5C,QAAA,CAAAjC,KAAA,UAAM,CAAO,KAAKE,OAAO;MACpC;IAAA;MAAA7C,GAAA;MAAAC,KAAA,EAEO,SAAAwH,SAASC,KAAA,EAAejI,MAAA,EAAsB;QACtC,KAAKkI,OAAA,CAAQD,KAAA,EAAOjI,MAAM,EAClCgB,MAAA,CAAO;MACd;IAAA;MAAAT,GAAA;MAAAC,KAAA,EAEO,SAAA2H,SACLF,KAAA,EACAjI,MAAA,EACAyB,IAAA,EACAjB,KAAA,EACM;QACN,IAAMyC,IAAA,GAAO,KAAKiF,OAAA,CAAQD,KAAA,EAAOjI,MAAM;QACnC,SAAKwC,MAAA,CAAOG,KAAA,CAAMlB,IAAA,EAAM3C,KAAA,CAAMK,IAAI,KAAK,QAAQqB,KAAA,EAC5CyC,IAAA,CAAAmF,IAAA,CAAK3G,IAAA,EAAMjB,KAAK,WACZ,KAAKgC,MAAA,CAAOG,KAAA,CAAMlB,IAAA,EAAM3C,KAAA,CAAMI,SAAS,KAAK,MAAM;UAC3D,IAAM4I,MAAA,GAAS,KAAKtF,MAAA,CAAOD,MAAA,CAAO,KAAK8F,OAAA,CAAQjI,KAAK;UAEpD6C,IAAA,CAAKmF,IAAA,CAAKN,MAAM,GACTA,MAAA,CAAAd,MAAA,CAAOvF,IAAA,EAAMjB,KAAK;QAC3B;MACF;IAAA;MAAAD,GAAA;MAAAC,KAAA,EAEO,SAAA8H,SAASL,KAAA,EAAezH,KAAA,EAAe+H,GAAA,EAAiB;QAC7D,IAAMtF,IAAA,GACJsF,GAAA,IAAO,OACH,KAAK/F,MAAA,CAAOD,MAAA,CAAO,QAAQ/B,KAAK,IAChC,KAAKgC,MAAA,CAAOD,MAAA,CAAO/B,KAAA,EAAO+H,GAAG;UAC7BC,GAAA,GAAM,KAAK3E,KAAA,CAAMoE,KAAK;QAC5B,KAAKH,MAAA,CAAOW,YAAA,CAAaxF,IAAA,EAAMuF,GAAA,IAAO,MAAS;MACjD;IAAA;MAAAjI,GAAA;MAAAC,KAAA,EAEO,SAAA0H,QAAQD,KAAA,EAAejI,MAAA,EAAsB;QAC5C,IAAA6G,MAAA,GAAS,KAAKhD,KAAA,CAAMoE,KAAK;QAC/B,IAAIpB,MAAA,IAAU,MACN,UAAI3E,KAAA,CAAM,2BAA2B;QAE7C,OAAA2E,MAAA,CAAOhD,KAAA,CAAM7D,MAAM,GACZ6G,MAAA;MACT;IAAA;MAAAtG,GAAA;MAAAC,KAAA,EAEO,SAAAR,OAAA,EAAiB;QACf;MACT;IAAA;MAAAO,GAAA;MAAAC,KAAA,EAEO,SAAAkI,OAAA,EAAyC;QAAA,IAAlCC,IAAA,GAAA5I,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAa,KAAK+H,MAAA;QAC9B,OAAI,KAAKA,MAAA,IAAU,QAAQ,SAASa,IAAA,GAC3B,IAEF,KAAKb,MAAA,CAAOc,QAAA,CAASF,MAAA,CAAO,IAAI,IAAI,KAAKZ,MAAA,CAAOY,MAAA,CAAOC,IAAI;MACpE;IAAA;MAAApI,GAAA;MAAAC,KAAA,EAEO,SAAAqI,SAASC,QAAA,EAAyC;QAErD,KAAKT,OAAA,CAAQU,iBAAA,IACb,EAAE,KAAKjB,MAAA,YAAkB,KAAKO,OAAA,CAAQU,iBAAA,KAEtC,KAAKX,IAAA,CAAK,KAAKC,OAAA,CAAQU,iBAAA,CAAkBvE,QAAQ;MAErD;IAAA;MAAAjE,GAAA;MAAAC,KAAA,EAEO,SAAAQ,OAAA,EAAe;QAChB,KAAKoC,OAAA,CAAQ4B,UAAA,IAAc,QAC7B,KAAK5B,OAAA,CAAQ4B,UAAA,CAAW+C,WAAA,CAAY,KAAK3E,OAAO,GAElD,KAAKyE,MAAA,CAAO;MACd;IAAA;MAAAtH,GAAA;MAAAC,KAAA,EAEO,SAAAwI,YAAYvH,IAAA,EAAqBjB,KAAA,EAAmB;QACnD,IAAAyI,WAAA,GACJ,OAAOxH,IAAA,IAAS,WAAW,KAAKe,MAAA,CAAOD,MAAA,CAAOd,IAAA,EAAMjB,KAAK,IAAIiB,IAAA;QAC3D,YAAKqG,MAAA,IAAU,SACjB,KAAKA,MAAA,CAAOW,YAAA,CAAaQ,WAAA,EAAa,KAAKxB,IAAA,IAAQ,MAAS,GAC5D,KAAKzG,MAAA,CAAO,IAEPiI,WAAA;MACT;IAAA;MAAA1I,GAAA;MAAAC,KAAA,EAEO,SAAAqD,MAAMoE,KAAA,EAAeiB,MAAA,EAA+B;QAClD,OAAAjB,KAAA,KAAU,IAAI,OAAO,KAAKR,IAAA;MACnC;IAAA;MAAAlH,GAAA;MAAAC,KAAA,EAEO,SAAA2I,OACLC,UAAA,EACAN,QAAA,EACM,CAER;IAAA;MAAAvI,GAAA;MAAAC,KAAA,EAEO,SAAA4H,KAAK3G,IAAA,EAAuBjB,KAAA,EAAqB;QAChD,IAAA6I,OAAA,GACJ,OAAO5H,IAAA,IAAS,WACX,KAAKe,MAAA,CAAOD,MAAA,CAAOd,IAAA,EAAMjB,KAAK,IAC/BiB,IAAA;QAIF,IAHA,KAAKqG,MAAA,IAAU,QACjB,KAAKA,MAAA,CAAOW,YAAA,CAAaY,OAAA,EAAS,KAAK5B,IAAA,IAAQ,MAAS,GAEtD,OAAO4B,OAAA,CAAQC,WAAA,IAAgB,YACjC,MAAM,IAAI5H,cAAA,gBAAAkB,MAAA,CAA8BnB,IAAI,CAAE;QAEhD,OAAA4H,OAAA,CAAQC,WAAA,CAAY,IAAI,GACjBD,OAAA;MACT;IAAA;MAAA9I,GAAA;MAAAC,KAAA,EAtKA,SAAc+B,OAAOgH,QAAA,EAA0B;QACzC,SAAKxF,OAAA,IAAW,MACZ,UAAIrC,cAAA,CAAe,iCAAiC;QAExD,IAAAhB,IAAA,EACAF,KAAA;QACJ,OAAIY,KAAA,CAAMsD,OAAA,CAAQ,KAAKX,OAAO,KACxB,OAAOwF,QAAA,IAAa,YACtB/I,KAAA,GAAQ+I,QAAA,CAAS5E,WAAA,IACb6E,QAAA,CAAShJ,KAAA,EAAO,EAAE,EAAEiJ,QAAA,OAAejJ,KAAA,KAC7BA,KAAA,GAAAgJ,QAAA,CAAShJ,KAAA,EAAO,EAAE,MAEnB,OAAO+I,QAAA,IAAa,aACrB/I,KAAA,GAAA+I,QAAA,GAEN,OAAO/I,KAAA,IAAU,WACnBE,IAAA,GAAOgJ,QAAA,CAASC,aAAA,CAAc,KAAK5F,OAAA,CAAQvD,KAAA,GAAQ,CAAC,CAAC,IAC5CA,KAAA,IAAS,KAAKuD,OAAA,CAAQjD,OAAA,CAAQN,KAAK,IAAI,KACzCE,IAAA,GAAAgJ,QAAA,CAASC,aAAA,CAAcnJ,KAAK,IAEnCE,IAAA,GAAOgJ,QAAA,CAASC,aAAA,CAAc,KAAK5F,OAAA,CAAQ,CAAC,CAAC,KAGxCrD,IAAA,GAAAgJ,QAAA,CAASC,aAAA,CAAc,KAAK5F,OAAO,GAExC,KAAKU,SAAA,IACF/D,IAAA,CAAA+E,SAAA,CAAUhF,GAAA,CAAI,KAAKgE,SAAS,GAE5B/D,IAAA;MACT;IAAA;EAAA,GA0IF;AA7KE6G,WAAA,CAAc/C,QAAA,GAAW;AAD3B,IAAMoF,UAAA,GAANrC,WAAA;ACPA,IAAMsC,SAAA,0BAAAC,YAAA;EAAA,SAAAD,UAAA;IAAA3J,eAAA,OAAA2J,SAAA;IAAA,OAAA/H,UAAA,OAAA+H,SAAA,EAAA9J,SAAA;EAAA;EAAAiC,SAAA,CAAA6H,SAAA,EAAAC,YAAA;EAAA,OAAAxJ,YAAA,CAAAuJ,SAAA;IAAAtJ,GAAA;IAAAC,KAAA;IAUJ;AAAA;AAAA;AAAA;IAMO,SAAAyH,MAAMvH,IAAA,EAAYgI,MAAA,EAAwB;MAE7C,YAAKtF,OAAA,KAAY1C,IAAA,IACjB,KAAK0C,OAAA,CAAQ2G,uBAAA,CAAwBrJ,IAAI,IACvCoC,IAAA,CAAKkH,8BAAA,GAEAC,IAAA,CAAKC,GAAA,CAAIxB,MAAA,EAAQ,CAAC,IAEpB;IACT;IAAA;AAAA;AAAA;AAAA;EAAA;IAAAnI,GAAA;IAAAC,KAAA,EAMO,SAAA2J,SAASlC,KAAA,EAAemC,UAAA,EAAsC;MAEnE,IAAI1B,MAAA,GADuBtH,KAAA,CAAMC,IAAA,CAAK,KAAKyG,MAAA,CAAO1E,OAAA,CAAQiH,UAAU,EAC5CvJ,OAAA,CAAQ,KAAKsC,OAAO;MAC5C,OAAI6E,KAAA,GAAQ,MACAS,MAAA,QAEL,CAAC,KAAKZ,MAAA,CAAO1E,OAAA,EAASsF,MAAM;IACrC;IAAA;AAAA;AAAA;AAAA;AAAA;EAAA;IAAAnI,GAAA;IAAAC,KAAA,EAOO,SAAAA,MAAA,EAAa;MACX,OAAA8J,eAAA,KACJ,KAAKjC,OAAA,CAAQ7D,QAAQ,EAAG,KAAK6D,OAAA,CAAQ7H,KAAA,CAAM,KAAK4C,OAAO,KAAK;IAEjE;EAAA;IAAA7C,GAAA;IAAAC,KAAA;IAjDgD;AAAA;AAAA;AAAA;AAAA;IAQhD,SAAcA,MAAM+J,QAAA,EAAqB;MAChC;IACT;EAAA;AAAA,EAVqBX,UAAA,CAkDvB;AAjDEC,SAAA,CAAczJ,KAAA,GAAQtB,KAAA,CAAMS,WAAA;AAD9B,IAAMiL,QAAA,GAANX,SAAA;AAoDA,IAAAY,UAAA,GAAeD,QAAA;AAAA,ICtDTE,UAAA;EAKJ,SAAAA,WAAA,EAAc;IAAAxK,eAAA,OAAAwK,UAAA;IACZ,KAAKC,IAAA,GAAO,MACZ,KAAKC,IAAA,GAAO,MACZ,KAAK5K,MAAA,GAAS;EAChB;EAAA,OAAAM,YAAA,CAAAoK,UAAA;IAAAnK,GAAA;IAAAC,KAAA,EAEO,SAAAqK,OAAA,EAA4B;MAAA,SAAAC,KAAA,GAAA/K,SAAA,CAAAC,MAAA,EAAlB+K,KAAA,OAAA3J,KAAA,CAAA0J,KAAA,GAAAE,KAAA,MAAAA,KAAA,GAAAF,KAAA,EAAAE,KAAA;QAAAD,KAAA,CAAAC,KAAA,IAAAjL,SAAA,CAAAiL,KAAA;MAAA;MAEX,IADJ,KAAKvC,YAAA,CAAasC,KAAA,CAAM,CAAC,GAAG,IAAI,GAC5BA,KAAA,CAAM/K,MAAA,GAAS,GAAG;QACd,IAAA+F,IAAA,GAAOgF,KAAA,CAAMrF,KAAA,CAAM,CAAC;QACrB,KAAAmF,MAAA,CAAAI,KAAA,OAAAC,kBAAA,CAAUnF,IAAI;MACrB;IACF;EAAA;IAAAxF,GAAA;IAAAC,KAAA,EAEO,SAAA2K,GAAGlD,KAAA,EAAyB;MAC3B,IAAAR,IAAA,GAAO,KAAK2D,QAAA;MAClB,IAAIC,GAAA,GAAM5D,IAAA;MACH,OAAA4D,GAAA,IAAOpD,KAAA,GAAQ,IACXA,KAAA,OACToD,GAAA,GAAM5D,IAAA,CAAK;MAEN,OAAA4D,GAAA;IACT;EAAA;IAAA9K,GAAA;IAAAC,KAAA,EAEO,SAAA8K,SAAS5K,IAAA,EAAkB;MAC1B,IAAA+G,IAAA,GAAO,KAAK2D,QAAA;MAClB,IAAIC,GAAA,GAAM5D,IAAA;MACV,OAAO4D,GAAA,GAAK;QACV,IAAIA,GAAA,KAAQ3K,IAAA,EACH;QAET2K,GAAA,GAAM5D,IAAA,CAAK;MACb;MACO;IACT;EAAA;IAAAlH,GAAA;IAAAC,KAAA,EAEO,SAAAM,QAAQJ,IAAA,EAAiB;MACxB,IAAA+G,IAAA,GAAO,KAAK2D,QAAA;MAClB,IAAIC,GAAA,GAAM5D,IAAA;QACNQ,KAAA,GAAQ;MACZ,OAAOoD,GAAA,GAAK;QACV,IAAIA,GAAA,KAAQ3K,IAAA,EACH,OAAAuH,KAAA;QAEAA,KAAA,OACToD,GAAA,GAAM5D,IAAA,CAAK;MACb;MACO;IACT;EAAA;IAAAlH,GAAA;IAAAC,KAAA,EAEO,SAAAiI,aAAa/H,IAAA,EAAgB6K,OAAA,EAAyB;MACvD7K,IAAA,IAAQ,SAGZ,KAAKM,MAAA,CAAON,IAAI,GAChBA,IAAA,CAAK+G,IAAA,GAAO8D,OAAA,EACRA,OAAA,IAAW,QACb7K,IAAA,CAAK8G,IAAA,GAAO+D,OAAA,CAAQ/D,IAAA,EAChB+D,OAAA,CAAQ/D,IAAA,IAAQ,SAClB+D,OAAA,CAAQ/D,IAAA,CAAKC,IAAA,GAAO/G,IAAA,GAEtB6K,OAAA,CAAQ/D,IAAA,GAAO9G,IAAA,EACX6K,OAAA,KAAY,KAAKZ,IAAA,KACnB,KAAKA,IAAA,GAAOjK,IAAA,KAEL,KAAKkK,IAAA,IAAQ,QACtB,KAAKA,IAAA,CAAKnD,IAAA,GAAO/G,IAAA,EACjBA,IAAA,CAAK8G,IAAA,GAAO,KAAKoD,IAAA,EACjB,KAAKA,IAAA,GAAOlK,IAAA,KAEZA,IAAA,CAAK8G,IAAA,GAAO,MACP,KAAAmD,IAAA,GAAO,KAAKC,IAAA,GAAOlK,IAAA,GAE1B,KAAKV,MAAA,IAAU;IACjB;EAAA;IAAAO,GAAA;IAAAC,KAAA,EAEO,SAAAkI,OAAO7B,MAAA,EAAmB;MAC/B,IAAIoB,KAAA,GAAQ;QACRoD,GAAA,GAAM,KAAKV,IAAA;MACf,OAAOU,GAAA,IAAO,OAAM;QAClB,IAAIA,GAAA,KAAQxE,MAAA,EACH,OAAAoB,KAAA;QAETA,KAAA,IAASoD,GAAA,CAAIrL,MAAA,IACbqL,GAAA,GAAMA,GAAA,CAAI5D,IAAA;MACZ;MACO;IACT;EAAA;IAAAlH,GAAA;IAAAC,KAAA,EAEO,SAAAQ,OAAON,IAAA,EAAe;MACtB,KAAK4K,QAAA,CAAS5K,IAAI,MAGnBA,IAAA,CAAK8G,IAAA,IAAQ,SACV9G,IAAA,CAAA8G,IAAA,CAAKC,IAAA,GAAO/G,IAAA,CAAK+G,IAAA,GAEpB/G,IAAA,CAAK+G,IAAA,IAAQ,SACV/G,IAAA,CAAA+G,IAAA,CAAKD,IAAA,GAAO9G,IAAA,CAAK8G,IAAA,GAEpB9G,IAAA,KAAS,KAAKiK,IAAA,KAChB,KAAKA,IAAA,GAAOjK,IAAA,CAAK+G,IAAA,GAEf/G,IAAA,KAAS,KAAKkK,IAAA,KAChB,KAAKA,IAAA,GAAOlK,IAAA,CAAK8G,IAAA,GAEnB,KAAKxH,MAAA,IAAU;IACjB;EAAA;IAAAO,GAAA;IAAAC,KAAA,EAEO,SAAA4K,SAAA,EAAwD;MAAA,IAA/CI,OAAA,GAAAzL,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAoB,KAAK4K,IAAA;MAEvC,OAAO,YAAgB;QACrB,IAAMc,GAAA,GAAMD,OAAA;QACZ,OAAIA,OAAA,IAAW,SACbA,OAAA,GAAUA,OAAA,CAAQ/D,IAAA,GAEbgE,GAAA;MAAA;IAEX;EAAA;IAAAlL,GAAA;IAAAC,KAAA,EAEO,SAAA6C,KAAK4E,KAAA,EAAsD;MAAA,IAAvCyD,SAAA,GAAA3L,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAY;MAC/B,IAAA0H,IAAA,GAAO,KAAK2D,QAAA;MAClB,IAAIC,GAAA,GAAM5D,IAAA;MACV,OAAO4D,GAAA,GAAK;QACJ,IAAArL,MAAA,GAASqL,GAAA,CAAIrL,MAAA;QACnB,IACEiI,KAAA,GAAQjI,MAAA,IACP0L,SAAA,IACCzD,KAAA,KAAUjI,MAAA,KACTqL,GAAA,CAAI5D,IAAA,IAAQ,QAAQ4D,GAAA,CAAI5D,IAAA,CAAKzH,MAAA,CAAO,MAAM,IAEtC,QAACqL,GAAA,EAAKpD,KAAK;QAEXA,KAAA,IAAAjI,MAAA,EACTqL,GAAA,GAAM5D,IAAA,CAAK;MACb;MACO,QAAC,MAAM,CAAC;IACjB;EAAA;IAAAlH,GAAA;IAAAC,KAAA,EAEO,SAAAoE,QAAQ+G,QAAA,EAAkC;MACzC,IAAAlE,IAAA,GAAO,KAAK2D,QAAA;MAClB,IAAIC,GAAA,GAAM5D,IAAA;MACV,OAAO4D,GAAA,GACLM,QAAA,CAASN,GAAG,GACZA,GAAA,GAAM5D,IAAA,CAAK;IAEf;EAAA;IAAAlH,GAAA;IAAAC,KAAA,EAEO,SAAAoL,UACL3D,KAAA,EACAjI,MAAA,EACA2L,QAAA,EACM;MACN,IAAI3L,MAAA,IAAU,GACZ;MAEF,IAAA6L,UAAA,GAA4B,KAAKxI,IAAA,CAAK4E,KAAK;QAAA6D,WAAA,GAAAC,cAAA,CAAAF,UAAA;QAApCG,SAAA,GAAAF,WAAA;QAAWpD,MAAM,GAAAoD,WAAA;MACxB,IAAIG,QAAA,GAAWhE,KAAA,GAAQS,MAAA;MACjB,IAAAjB,IAAA,GAAO,KAAK2D,QAAA,CAASY,SAAS;MACpC,IAAIX,GAAA,GAAM5D,IAAA;MACH,OAAA4D,GAAA,IAAOY,QAAA,GAAWhE,KAAA,GAAQjI,MAAA,GAAQ;QACjC,IAAAkM,SAAA,GAAYb,GAAA,CAAIrL,MAAA;QAClBiI,KAAA,GAAQgE,QAAA,GACVN,QAAA,CACEN,GAAA,EACApD,KAAA,GAAQgE,QAAA,EACRhC,IAAA,CAAKC,GAAA,CAAIlK,MAAA,EAAQiM,QAAA,GAAWC,SAAA,GAAYjE,KAAK,KAGtC0D,QAAA,CAAAN,GAAA,EAAK,GAAGpB,IAAA,CAAKC,GAAA,CAAIgC,SAAA,EAAWjE,KAAA,GAAQjI,MAAA,GAASiM,QAAQ,CAAC,GAErDA,QAAA,IAAAC,SAAA,EACZb,GAAA,GAAM5D,IAAA,CAAK;MACb;IACF;EAAA;IAAAlH,GAAA;IAAAC,KAAA,EAEO,SAAAe,IAAIoK,QAAA,EAAkC;MAC3C,OAAO,KAAKtE,MAAA,CAAO,UAAC8E,IAAA,EAAWd,GAAA;QAAA,OACxBc,IAAA,CAAAC,IAAA,CAAKT,QAAA,CAASN,GAAG,CAAC,GAChBc,IAAA;MAAA,GACN,EAAE;IACP;EAAA;IAAA5L,GAAA;IAAAC,KAAA,EAEO,SAAA6G,OAAUsE,QAAA,EAAkCQ,IAAA,EAAY;MACvD,IAAA1E,IAAA,GAAO,KAAK2D,QAAA;MAClB,IAAIC,GAAA,GAAM5D,IAAA;MACV,OAAO4D,GAAA,GACEc,IAAA,GAAAR,QAAA,CAASQ,IAAA,EAAMd,GAAG,GACzBA,GAAA,GAAM5D,IAAA,CAAK;MAEN,OAAA0E,IAAA;IACT;EAAA;AAAA;AC/LF,SAASE,iBAAiB3L,IAAA,EAAY8B,MAAA,EAAoB;EAClD,IAAA8J,KAAA,GAAQ9J,MAAA,CAAOa,IAAA,CAAK3C,IAAI;EAC1B,IAAA4L,KAAA,EAAc,OAAAA,KAAA;EACd;IACK,OAAA9J,MAAA,CAAOD,MAAA,CAAO7B,IAAI;EAAA,SAAA6L,QAAA,EACf;IACV,IAAMtJ,IAAA,GAAOT,MAAA,CAAOD,MAAA,CAAOzD,KAAA,CAAMM,MAAM;IACvC,OAAAgC,KAAA,CAAMC,IAAA,CAAKX,IAAA,CAAK2J,UAAU,EAAEzF,OAAA,CAAQ,UAAC4H,KAAA,EAAgB;MAC9CvJ,IAAA,CAAAG,OAAA,CAAQkG,WAAA,CAAYkD,KAAK;IAAA,CAC/B,GACG9L,IAAA,CAAKsE,UAAA,IACPtE,IAAA,CAAKsE,UAAA,CAAWyH,YAAA,CAAaxJ,IAAA,CAAKG,OAAA,EAAS1C,IAAI,GAEjDuC,IAAA,CAAKyE,MAAA,CAAO,GACLzE,IAAA;EACT;AACF;AAEA,IAAMyJ,WAAA,0BAAAC,YAAA;EAgBJ,SAAAD,YAAYlK,MAAA,EAAcY,OAAA,EAAe;IAAA,IAAAwJ,MAAA;IAAA1M,eAAA,OAAAwM,WAAA;IACvCE,MAAA,GAAA9K,UAAA,OAAA4K,WAAA,GAAMlK,MAAA,EAAQY,OAAO,IAHvBwJ,MAAA,CAAOC,MAAA,GAA6B,MAIlCD,MAAA,CAAKrG,KAAA,CAAM;IAAA,OAAAqG,MAAA;EACb;EAAA5K,SAAA,CAAA0K,WAAA,EAAAC,YAAA;EAAA,OAAArM,YAAA,CAAAoM,WAAA;IAAAnM,GAAA;IAAAC,KAAA,EAEO,SAAA8I,YAAYwD,KAAA,EAAmB;MACpC,KAAKrE,YAAA,CAAaqE,KAAK;IACzB;EAAA;IAAAvM,GAAA;IAAAC,KAAA,EAEO,SAAAkH,OAAA,EAAe;MACpBqF,aAAA,CAAAL,WAAA,0BACK,KAAA9D,QAAA,CAAShE,OAAA,CAAQ,UAAC4H,KAAA,EAAU;QAC/BA,KAAA,CAAM9E,MAAA,CAAO;MAAA,CACd;IACH;EAAA;IAAAnH,GAAA;IAAAC,KAAA,EAEO,SAAAwM,SAAStM,IAAA,EAAyB;MACnC,KAAKmM,MAAA,IAAU,QACjB,KAAKA,MAAA,CAAO7L,MAAA,IAEd,KAAK6L,MAAA,GAASnM,IAAA,EACVgM,WAAA,CAAWO,OAAA,IACb,KAAKJ,MAAA,CAAOpH,SAAA,CAAUhF,GAAA,CAAIiM,WAAA,CAAWO,OAAO,GAEzC,KAAAJ,MAAA,CAAOjM,YAAA,CAAa,mBAAmB,OAAO,GACnD,KAAKwC,OAAA,CAAQqF,YAAA,CAAa,KAAKoE,MAAA,EAAQ,KAAKzJ,OAAA,CAAQ8J,UAAU;IAChE;IAAA;AAAA;AAAA;EAAA;IAAA3M,GAAA;IAAAC,KAAA,EAKO,SAAA+F,MAAA,EAAc;MAAA,IAAA4G,MAAA;MACd,KAAAvE,QAAA,GAAW,IAAI8B,UAAA,IAEpBtJ,KAAA,CAAMC,IAAA,CAAK,KAAK+B,OAAA,CAAQiH,UAAU,EAC/B/E,MAAA,CAAO,UAAC5E,IAAA;QAAA,OAAeA,IAAA,KAASyM,MAAA,CAAKN,MAAM;MAAA,GAC3CO,OAAA,GACAxI,OAAA,CAAQ,UAAClE,IAAA,EAAe;QACnB;UACF,IAAM8L,KAAA,GAAQH,gBAAA,CAAiB3L,IAAA,EAAMyM,MAAA,CAAK3K,MAAM;UAChD2K,MAAA,CAAK1E,YAAA,CAAa+D,KAAA,EAAOW,MAAA,CAAKvE,QAAA,CAAS+B,IAAA,IAAQ,MAAS;QAAA,SACjD0C,GAAA,EAAK;UACZ,IAAIA,GAAA,YAAe3L,cAAA,EACjB;UAEM,MAAA2L,GAAA;QAEV;MAAA,CACD;IACL;EAAA;IAAA9M,GAAA;IAAAC,KAAA,EAEO,SAAAwH,SAASC,KAAA,EAAejI,MAAA,EAAsB;MACnD,IAAIiI,KAAA,KAAU,KAAKjI,MAAA,KAAW,KAAKA,MAAA,IACjC,OAAO,KAAKgB,MAAA;MAEd,KAAK4H,QAAA,CAASgD,SAAA,CAAU3D,KAAA,EAAOjI,MAAA,EAAQ,UAACwM,KAAA,EAAO9D,MAAA,EAAQ4E,WAAA,EAAgB;QAC/Dd,KAAA,CAAAxE,QAAA,CAASU,MAAA,EAAQ4E,WAAW;MAAA,CACnC;IACH;EAAA;IAAA/M,GAAA;IAAAC,KAAA,EAUO,SAAA+M,WAAWC,QAAA,EAAiD;MAAA,IAAlCvF,KAAA,GAAAlI,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAQ;MACvC,IAAA0N,mBAAA,GAAwB,KAAK7E,QAAA,CAASvF,IAAA,CAAK4E,KAAK;QAAAyF,oBAAA,GAAA3B,cAAA,CAAA0B,mBAAA;QAAzCjB,KAAA,GAAAkB,oBAAA;QAAOhF,MAAM,GAAAgF,oBAAA;MAEjB,OAAAF,QAAA,CAAShJ,QAAA,IAAY,QAAQgJ,QAAA,CAAShB,KAAK,KAC3CgB,QAAA,CAAShJ,QAAA,IAAY,QAAQgI,KAAA,YAAiBgB,QAAA,GAExC,CAAChB,KAAA,EAAc9D,MAAM,IACnB8D,KAAA,YAAiBE,WAAA,GACnBF,KAAA,CAAMe,UAAA,CAAWC,QAAA,EAAU9E,MAAM,IAEjC,CAAC,MAAM,EAAE;IAEpB;EAAA;IAAAnI,GAAA;IAAAC,KAAA,EAYO,SAAAmN,YACLH,QAAA,EAGQ;MAAA,IAFRvF,KAAA,GAAAlI,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAQ;MAAA,IACRC,MAAA,GAAAD,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAiB6N,MAAA,CAAOC,SAAA;MAExB,IAAIF,WAAA,GAAsB;QACtBG,UAAA,GAAa9N,MAAA;MACjB,YAAK4I,QAAA,CAASgD,SAAA,CACZ3D,KAAA,EACAjI,MAAA,EACA,UAACwM,KAAA,EAAauB,UAAA,EAAoBT,WAAA,EAAwB;QAErD,CAAAE,QAAA,CAAShJ,QAAA,IAAY,QAAQgJ,QAAA,CAAShB,KAAK,KAC3CgB,QAAA,CAAShJ,QAAA,IAAY,QAAQgI,KAAA,YAAiBgB,QAAA,KAE/CG,WAAA,CAAYvB,IAAA,CAAKI,KAAK,GAEpBA,KAAA,YAAiBE,WAAA,KACnBiB,WAAA,GAAcA,WAAA,CAAY/K,MAAA,CACxB4J,KAAA,CAAMmB,WAAA,CAAYH,QAAA,EAAUO,UAAA,EAAYD,UAAU,KAGxCA,UAAA,IAAAR,WAAA;MAChB,IAEKK,WAAA;IACT;EAAA;IAAApN,GAAA;IAAAC,KAAA,EAEO,SAAAqH,OAAA,EAAe;MACf,KAAAe,QAAA,CAAShE,OAAA,CAAQ,UAAC4H,KAAA,EAAU;QAC/BA,KAAA,CAAM3E,MAAA,CAAO;MAAA,CACd,GAAAkF,aAAA,CAAAL,WAAA,wBACY;IACf;EAAA;IAAAnM,GAAA;IAAAC,KAAA,EAEO,SAAAwN,uBAAA,EAA+B;MAAA,IAAAC,OAAA;MACpC,IAAIC,IAAA,GAAO;MACN,KAAAtF,QAAA,CAAShE,OAAA,CAAQ,UAAC4H,KAAA,EAAgB;QACjC0B,IAAA,IAGYD,OAAA,CAAK5F,OAAA,CAAQ8F,eAAA,CAAgBrK,IAAA,CAC3C,UAACyE,GAAA;UAAA,OAAyBiE,KAAA,YAAiBjE,GAAA;QAAA,OAKzCiE,KAAA,CAAMnE,OAAA,CAAQjI,KAAA,KAAUtB,KAAA,CAAMQ,UAAA,IAC5BkN,KAAA,CAAM/E,IAAA,IAAQ,QAChBwG,OAAA,CAAKG,UAAA,CAAW5B,KAAK,GAEnBA,KAAA,CAAMhF,IAAA,IAAQ,QACXyG,OAAA,CAAAG,UAAA,CAAW5B,KAAA,CAAMhF,IAAI,GAE5BgF,KAAA,CAAM1E,MAAA,CAAOuG,MAAA,IACNH,IAAA,SACE1B,KAAA,YAAiBE,WAAA,GAC1BF,KAAA,CAAM6B,MAAA,CAAO,IAEb7B,KAAA,CAAMxL,MAAA,CAAO;MACf,CACD;IACH;EAAA;IAAAT,GAAA;IAAAC,KAAA,EAEO,SAAA2H,SACLF,KAAA,EACAjI,MAAA,EACAyB,IAAA,EACAjB,KAAA,EACM;MACN,KAAKoI,QAAA,CAASgD,SAAA,CAAU3D,KAAA,EAAOjI,MAAA,EAAQ,UAACwM,KAAA,EAAO9D,MAAA,EAAQ4E,WAAA,EAAgB;QACrEd,KAAA,CAAMrE,QAAA,CAASO,MAAA,EAAQ4E,WAAA,EAAa7L,IAAA,EAAMjB,KAAK;MAAA,CAChD;IACH;EAAA;IAAAD,GAAA;IAAAC,KAAA,EAEO,SAAA8H,SAASL,KAAA,EAAezH,KAAA,EAAe+H,GAAA,EAAiB;MAC7D,IAAA+F,oBAAA,GAAwB,KAAK1F,QAAA,CAASvF,IAAA,CAAK4E,KAAK;QAAAsG,oBAAA,GAAAxC,cAAA,CAAAuC,oBAAA;QAAzC9B,KAAA,GAAA+B,oBAAA;QAAO7F,MAAM,GAAA6F,oBAAA;MACpB,IAAI/B,KAAA,EACIA,KAAA,CAAAlE,QAAA,CAASI,MAAA,EAAQlI,KAAA,EAAO+H,GAAG,OAC5B;QACL,IAAMtF,IAAA,GACJsF,GAAA,IAAO,OACH,KAAK/F,MAAA,CAAOD,MAAA,CAAO,QAAQ/B,KAAK,IAChC,KAAKgC,MAAA,CAAOD,MAAA,CAAO/B,KAAA,EAAO+H,GAAG;QACnC,KAAKe,WAAA,CAAYrG,IAAI;MACvB;IACF;EAAA;IAAA1C,GAAA;IAAAC,KAAA,EAEO,SAAAiI,aAAa+F,SAAA,EAAiBC,OAAA,EAA6B;MAC5DD,SAAA,CAAU1G,MAAA,IAAU,QACZ0G,SAAA,CAAA1G,MAAA,CAAOc,QAAA,CAAS5H,MAAA,CAAOwN,SAAS;MAE5C,IAAIE,UAAA,GAA0B;MAC9B,KAAK9F,QAAA,CAASH,YAAA,CAAa+F,SAAA,EAAWC,OAAA,IAAW,IAAI,GACrDD,SAAA,CAAU1G,MAAA,GAAS,MACf2G,OAAA,IAAW,SACbC,UAAA,GAAaD,OAAA,CAAQrL,OAAA,IAGrB,KAAKA,OAAA,CAAQ4B,UAAA,KAAewJ,SAAA,CAAUpL,OAAA,IACtC,KAAKA,OAAA,CAAQuL,WAAA,KAAgBD,UAAA,KAE7B,KAAKtL,OAAA,CAAQqF,YAAA,CAAa+F,SAAA,CAAUpL,OAAA,EAASsL,UAAU,GAEzDF,SAAA,CAAU9G,MAAA,CAAO;IACnB;EAAA;IAAAnH,GAAA;IAAAC,KAAA,EAEO,SAAAR,OAAA,EAAiB;MACtB,OAAO,KAAK4I,QAAA,CAASvB,MAAA,CAAO,UAAC8E,IAAA,EAAMK,KAAA;QAAA,OAC1BL,IAAA,GAAOK,KAAA,CAAMxM,MAAA;MAAA,GACnB,CAAC;IACN;EAAA;IAAAO,GAAA;IAAAC,KAAA,EAEO,SAAAoO,aAAaC,YAAA,EAAsBtD,OAAA,EAA6B;MAChE,KAAA3C,QAAA,CAAShE,OAAA,CAAQ,UAAC4H,KAAA,EAAU;QAClBqC,YAAA,CAAApG,YAAA,CAAa+D,KAAA,EAAOjB,OAAO;MAAA,CACzC;IACH;EAAA;IAAAhL,GAAA;IAAAC,KAAA,EAEO,SAAAqI,SAASiG,OAAA,EAAwC;MAMlD,IALJ/B,aAAA,CAAAL,WAAA,wBAAeoC,OAAO,IACtB,KAAKd,sBAAA,CAAuB,GACxB,KAAKnB,MAAA,IAAU,QAAQ,KAAKA,MAAA,KAAW,KAAKzJ,OAAA,CAAQ8J,UAAA,IACtD,KAAK9J,OAAA,CAAQqF,YAAA,CAAa,KAAKoE,MAAA,EAAQ,KAAKzJ,OAAA,CAAQ8J,UAAU,GAE5D,KAAKtE,QAAA,CAAS5I,MAAA,KAAW,GACvB,SAAKqI,OAAA,CAAQ0G,YAAA,IAAgB,MAAM;QACrC,IAAMvC,KAAA,GAAQ,KAAKhK,MAAA,CAAOD,MAAA,CAAO,KAAK8F,OAAA,CAAQ0G,YAAA,CAAavK,QAAQ;QACnE,KAAK8E,WAAA,CAAYkD,KAAK;MAAA,OAItB,KAAKxL,MAAA,CAAO;IAGlB;EAAA;IAAAT,GAAA;IAAAC,KAAA,EAEO,SAAAwO,KAAK/G,KAAA,EAAoD;MAAA,IAArCyD,SAAA,GAAA3L,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAY;MAC/B,IAAAkP,oBAAA,GAAkB,KAAKrG,QAAA,CAASvF,IAAA,CAAK4E,KAAA,EAAOyD,SAAS;QAAAwD,oBAAA,GAAAnD,cAAA,CAAAkD,oBAAA;QAApDzC,KAAA,GAAA0C,oBAAA;QAAOxG,MAAM,GAAAwG,oBAAA;QACd/E,QAAA,GAA6B,CAAC,CAAC,MAAMlC,KAAK,CAAC;MACjD,OAAIuE,KAAA,YAAiBE,WAAA,GACZvC,QAAA,CAASvH,MAAA,CAAO4J,KAAA,CAAMwC,IAAA,CAAKtG,MAAA,EAAQgD,SAAS,CAAC,KAC3Cc,KAAA,IAAS,QAClBrC,QAAA,CAASiC,IAAA,CAAK,CAACI,KAAA,EAAO9D,MAAM,CAAC,GAExByB,QAAA;IACT;EAAA;IAAA5J,GAAA;IAAAC,KAAA,EAEO,SAAAuH,YAAYyE,KAAA,EAAmB;MAC/B,KAAA5D,QAAA,CAAS5H,MAAA,CAAOwL,KAAK;IAC5B;EAAA;IAAAjM,GAAA;IAAAC,KAAA,EAEO,SAAAwI,YAAYvH,IAAA,EAAqBjB,KAAA,EAAmB;MACnD,IAAAyI,WAAA,GACJ,OAAOxH,IAAA,IAAS,WAAW,KAAKe,MAAA,CAAOD,MAAA,CAAOd,IAAA,EAAMjB,KAAK,IAAIiB,IAAA;MAC/D,OAAIwH,WAAA,YAAuByD,WAAA,IACzB,KAAKkC,YAAA,CAAa3F,WAAW,GAAA8D,aAAA,CAAAL,WAAA,2BAENzD,WAAW;IACtC;EAAA;IAAA1I,GAAA;IAAAC,KAAA,EAEO,SAAAqD,MAAMoE,KAAA,EAA2C;MAAA,IAA5BkH,KAAA,GAAApP,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAQ;MAClC,IAAI,CAACoP,KAAA,EAAO;QACV,IAAIlH,KAAA,KAAU,GACL;QAEL,IAAAA,KAAA,KAAU,KAAKjI,MAAA,IACjB,OAAO,KAAKyH,IAAA;MAEhB;MACM,IAAA2H,KAAA,GAAQ,KAAKzH,KAAA;MACnB,OAAI,KAAKG,MAAA,IACP,KAAKA,MAAA,CAAOW,YAAA,CAAa2G,KAAA,EAAO,KAAK3H,IAAA,IAAQ,MAAS,GAEnD,KAAAmB,QAAA,CAASgD,SAAA,CAAU3D,KAAA,EAAO,KAAKjI,MAAA,IAAU,UAACwM,KAAA,EAAO9D,MAAA,EAAQ2G,OAAA,EAAY;QACxE,IAAMxL,KAAA,GAAQ2I,KAAA,CAAM3I,KAAA,CAAM6E,MAAA,EAAQyG,KAAK;QACnCtL,KAAA,IAAS,QACXuL,KAAA,CAAM9F,WAAA,CAAYzF,KAAK;MACzB,CACD,GACMuL,KAAA;IACT;EAAA;IAAA7O,GAAA;IAAAC,KAAA,EAEO,SAAA4N,WAAW5B,KAAA,EAAqB;MAC/B,IAAA4C,KAAA,GAAQ,KAAKzH,KAAA;MACZ,OAAA6E,KAAA,CAAM/E,IAAA,IAAQ,OACb2H,KAAA,CAAA9F,WAAA,CAAYkD,KAAA,CAAM/E,IAAI;MAE9B,OAAI,KAAKK,MAAA,IACP,KAAKA,MAAA,CAAOW,YAAA,CAAa2G,KAAA,EAAO,KAAK3H,IAAA,IAAQ,MAAS,GAEjD2H,KAAA;IACT;EAAA;IAAA7O,GAAA;IAAAC,KAAA,EAEO,SAAA6N,OAAA,EAAe;MAChB,KAAKvG,MAAA,IACP,KAAK8G,YAAA,CAAa,KAAK9G,MAAA,EAAQ,KAAKL,IAAA,IAAQ,MAAS,GAEvD,KAAKzG,MAAA,CAAO;IACd;EAAA;IAAAT,GAAA;IAAAC,KAAA,EAEO,SAAA2I,OACLmG,SAAA,EACAxG,QAAA,EACM;MAAA,IAAAyG,OAAA;MACN,IAAMC,UAAA,GAAqB;QACrBC,YAAA,GAAuB;MACnBH,SAAA,CAAA1K,OAAA,CAAQ,UAAC8K,QAAA,EAAa;QAC1BA,QAAA,CAAS7I,MAAA,KAAW0I,OAAA,CAAKnM,OAAA,IAAWsM,QAAA,CAASC,IAAA,KAAS,gBAC7CH,UAAA,CAAApD,IAAA,CAAAnB,KAAA,CAAAuE,UAAA,EAAAtE,kBAAA,CAAQwE,QAAA,CAASF,UAAU,IACzBC,YAAA,CAAArD,IAAA,CAAAnB,KAAA,CAAAwE,YAAA,EAAAvE,kBAAA,CAAQwE,QAAA,CAASD,YAAY;MAC5C,CACD,GACYA,YAAA,CAAA7K,OAAA,CAAQ,UAAClE,IAAA,EAAe;QAInC,IACEA,IAAA,CAAKsE,UAAA,IAAc;QAAA;QAEnBtE,IAAA,CAAKqD,OAAA,KAAY,YACjB2F,QAAA,CAASkG,IAAA,CAAK7F,uBAAA,CAAwBrJ,IAAI,IACxCoC,IAAA,CAAKkH,8BAAA,EAEP;QAEF,IAAM/G,IAAA,GAAOsM,OAAA,CAAK/M,MAAA,CAAOa,IAAA,CAAK3C,IAAI;QAC9BuC,IAAA,IAAQ,SAIVA,IAAA,CAAKG,OAAA,CAAQ4B,UAAA,IAAc,QAC3B/B,IAAA,CAAKG,OAAA,CAAQ4B,UAAA,KAAeuK,OAAA,CAAKnM,OAAA,KAEjCH,IAAA,CAAK4E,MAAA,CAAO;MACd,CACD,GAEE2H,UAAA,CAAAlK,MAAA,CAAO,UAAC5E,IAAA;QAAA,OACAA,IAAA,CAAKsE,UAAA,KAAeuK,OAAA,CAAKnM,OAAA,IAAW1C,IAAA,KAAS6O,OAAA,CAAK1C,MAC1D;MAAA,GACAgD,IAAA,CAAK,UAACC,CAAA,EAAGC,CAAA;QAAA,OACJD,CAAA,KAAMC,CAAA,GACD,IAELD,CAAA,CAAE/F,uBAAA,CAAwBgG,CAAC,IAAIjN,IAAA,CAAKkN,2BAAA,GAC/B,IAEF,EACR;MAAA,GACApL,OAAA,CAAQ,UAAClE,IAAA,EAAS;QACjB,IAAI+N,OAAA,GAAuB;QACvB/N,IAAA,CAAKiO,WAAA,IAAe,SACtBF,OAAA,GAAUc,OAAA,CAAK/M,MAAA,CAAOa,IAAA,CAAK3C,IAAA,CAAKiO,WAAW;QAE7C,IAAM1L,IAAA,GAAOoJ,gBAAA,CAAiB3L,IAAA,EAAM6O,OAAA,CAAK/M,MAAM;QAC/C,CAAIS,IAAA,CAAKwE,IAAA,KAASgH,OAAA,IAAWxL,IAAA,CAAKwE,IAAA,IAAQ,UACpCxE,IAAA,CAAK6E,MAAA,IAAU,QACZ7E,IAAA,CAAA6E,MAAA,CAAOC,WAAA,CAAYwH,OAAI,GAEzBA,OAAA,CAAA9G,YAAA,CAAaxF,IAAA,EAAMwL,OAAA,IAAW,MAAS;MAC9C,CACD,GACH,KAAKT,sBAAA,CAAuB;IAC9B;EAAA;AAAA,EApXuBpE,UAAA,CAqXzB;AA3WE8C,WAAA,CAAcO,OAAA,GAAU;AAV1B,IAAMgD,UAAA,GAANvD,WAAA;AAuXA,IAAAwD,YAAA,GAAeD,UAAA;ACjYf,SAASE,QACPC,IAAA,EACAC,IAAA,EACS;EACL,IAAAtJ,MAAA,CAAO5F,IAAA,CAAKiP,IAAI,EAAEpQ,MAAA,KAAW+G,MAAA,CAAO5F,IAAA,CAAKkP,IAAI,EAAErQ,MAAA,EAC1C;EAET,SAAWsQ,IAAA,IAAQF,IAAA,EACjB,IAAIA,IAAA,CAAKE,IAAI,MAAMD,IAAA,CAAKC,IAAI,GACnB;EAGJ;AACT;AAEA,IAAMC,WAAA,0BAAAC,YAAA;EA2BJ,SAAAD,YAAY/N,MAAA,EAAcY,OAAA,EAAe;IAAA,IAAAqN,OAAA;IAAAvQ,eAAA,OAAAqQ,WAAA;IACvCE,OAAA,GAAA3O,UAAA,OAAAyO,WAAA,GAAM/N,MAAA,EAAQY,OAAO,IACrBqN,OAAA,CAAKnP,UAAA,GAAa,IAAIgG,iBAAA,CAAgBmJ,OAAA,CAAKrN,OAAO;IAAA,OAAAqN,OAAA;EACpD;EAAAzO,SAAA,CAAAuO,WAAA,EAAAC,YAAA;EAAA,OAAAlQ,YAAA,CAAAiQ,WAAA;IAAAhQ,GAAA;IAAAC,KAAA,EAEO,SAAAwG,OAAOvF,IAAA,EAAcjB,KAAA,EAAkB;MAAA,IAAAkQ,OAAA;MAC5C,IAAIjP,IAAA,KAAS,KAAK4G,OAAA,CAAQ7D,QAAA,IAAY,CAAChE,KAAA,EAChC,KAAAoI,QAAA,CAAShE,OAAA,CAAQ,UAAC4H,KAAA,EAAU;QACzBA,KAAA,YAAiB+D,WAAA,KACrB/D,KAAA,GAAQA,KAAA,CAAMpE,IAAA,CAAKmI,WAAA,CAAW/L,QAAA,EAAU,EAAI,IAEzCkM,OAAA,CAAApP,UAAA,CAAWsF,IAAA,CAAK4F,KAAmB;MAAA,CACzC,GACD,KAAK6B,MAAA,CAAO,OACP;QACL,IAAMrH,OAAA,GAAS,KAAKxE,MAAA,CAAOG,KAAA,CAAMlB,IAAA,EAAM3C,KAAA,CAAMM,MAAM;QACnD,IAAI4H,OAAA,IAAU,MACZ;QAEEA,OAAA,YAAkBrH,UAAA,GACf,KAAA2B,UAAA,CAAWkF,SAAA,CAAUQ,OAAA,EAAQxG,KAAK,IAEvCA,KAAA,KACCiB,IAAA,KAAS,KAAK4G,OAAA,CAAQ7D,QAAA,IAAY,KAAKmM,OAAA,CAAQ,EAAElP,IAAI,MAAMjB,KAAA,KAEvD,KAAAwI,WAAA,CAAYvH,IAAA,EAAMjB,KAAK;MAEhC;IACF;EAAA;IAAAD,GAAA;IAAAC,KAAA,EAEO,SAAAmQ,QAAA,EAAoC;MACnC,IAAAA,OAAA,GAAU,KAAKrP,UAAA,CAAW6F,MAAA,CAAO;QACjCH,MAAA,GAAS,KAAKqB,OAAA,CAAQsI,OAAA,CAAQ,KAAKvN,OAAA,EAAS,KAAKZ,MAAM;MAC7D,OAAIwE,MAAA,IAAU,SACJ2J,OAAA,MAAKtI,OAAA,CAAQ7D,QAAQ,IAAIwC,MAAA,GAE5B2J,OAAA;IACT;EAAA;IAAApQ,GAAA;IAAAC,KAAA,EAEO,SAAA2H,SACLF,KAAA,EACAjI,MAAA,EACAyB,IAAA,EACAjB,KAAA,EACM;MAEJ,KAAKmQ,OAAA,GAAUlP,IAAI,KAAK,QACxB,KAAKe,MAAA,CAAOG,KAAA,CAAMlB,IAAA,EAAM3C,KAAA,CAAMI,SAAS,IAE1B,KAAKgJ,OAAA,CAAQD,KAAA,EAAOjI,MAAM,EAClCgH,MAAA,CAAOvF,IAAA,EAAMjB,KAAK,IAAAuM,aAAA,CAAAwD,WAAA,wBAERtI,KAAA,EAAOjI,MAAA,EAAQyB,IAAA,EAAMjB,KAAK;IAE7C;EAAA;IAAAD,GAAA;IAAAC,KAAA,EAEO,SAAAqI,SAASiG,OAAA,EAAuC;MACrD/B,aAAA,CAAAwD,WAAA,wBAAezB,OAAO;MAChB,IAAA6B,OAAA,GAAU,KAAKA,OAAA;MACrB,IAAI5J,MAAA,CAAO5F,IAAA,CAAKwP,OAAO,EAAE3Q,MAAA,KAAW,GAClC,OAAO,KAAKqO,MAAA;MAEd,IAAM5G,IAAA,GAAO,KAAKA,IAAA;MAEhBA,IAAA,YAAgB8I,WAAA,IAChB9I,IAAA,CAAKD,IAAA,KAAS,QACd2I,OAAA,CAAQQ,OAAA,EAASlJ,IAAA,CAAKkJ,OAAA,CAAQ,CAAC,MAE/BlJ,IAAA,CAAKmH,YAAA,CAAa,IAAI,GACtBnH,IAAA,CAAKzG,MAAA,CAAO;IAEhB;EAAA;IAAAT,GAAA;IAAAC,KAAA,EAEO,SAAAwI,YAAYvH,IAAA,EAAqBjB,KAAA,EAAmB;MACzD,IAAMyI,WAAA,GAAA8D,aAAA,CAAAwD,WAAA,2BAAgC9O,IAAA,EAAMjB,KAAK;MAC5C,YAAAc,UAAA,CAAWsF,IAAA,CAAKqC,WAAW,GACzBA,WAAA;IACT;EAAA;IAAA1I,GAAA;IAAAC,KAAA,EAEO,SAAA2I,OACLmG,SAAA,EACAR,OAAA,EACM;MAAA,IAAA8B,OAAA;MACA7D,aAAA,CAAAwD,WAAA,sBAAOjB,SAAA,EAAWR,OAAO,IACNQ,SAAA,CAAUxL,IAAA,CACjC,UAAC4L,QAAA;QAAA,OACCA,QAAA,CAAS7I,MAAA,KAAW+J,OAAA,CAAKxN,OAAA,IAAWsM,QAAA,CAASC,IAAA,KAAS;MAAA,MAGxD,KAAKrO,UAAA,CAAWiF,KAAA;IAEpB;EAAA;IAAAhG,GAAA;IAAAC,KAAA,EAEO,SAAA4H,KAAK3G,IAAA,EAAuBjB,KAAA,EAAqB;MACtD,IAAM6I,OAAA,GAAA0D,aAAA,CAAAwD,WAAA,oBAAqB9O,IAAA,EAAMjB,KAAK;MACtC,OAAI6I,OAAA,YAAmBkH,WAAA,IAChB,KAAAjP,UAAA,CAAW2F,IAAA,CAAKoC,OAAO,GAEvBA,OAAA;IACT;EAAA;IAAA9I,GAAA;IAAAC,KAAA,EAxHA,SAAO+B,OAAO/B,KAAA,EAAiB;MACtB,OAAAuM,aAAA,CAAAwD,WAAA,sBAAa/P,KAAK;IAC3B;EAAA;IAAAD,GAAA;IAAAC,KAAA,EAEA,SAAcmQ,QAAQvN,OAAA,EAAsBZ,MAAA,EAAmB;MAC7D,IAAME,MAAA,GAAQF,MAAA,CAAOG,KAAA,CAAM4N,WAAA,CAAW/L,QAAQ;MAC9C,IACE,EAAA9B,MAAA,IAAS,QACTU,OAAA,CAAQW,OAAA,KAAarB,MAAA,CAA0BqB,OAAA,GAGtC;QAAA,WAAO,KAAKA,OAAA,IAAY,UAC1B;QACE,IAAA3C,KAAA,CAAMsD,OAAA,CAAQ,KAAKX,OAAO,GAC5B,OAAAX,OAAA,CAAQW,OAAA,CAAQ8M,WAAA;;IAG3B;EAAA;AAAA,EAvBuBX,YAAA,CA+HzB;AA9HgBK,WAAA,CAAApC,eAAA,GAAqC,CAACoC,WAAA,EAAY9F,UAAQ,GACxE8F,WAAA,CAAc/L,QAAA,GAAW,UACzB+L,WAAA,CAAcnQ,KAAA,GAAQtB,KAAA,CAAMS,WAAA,EAC5BgR,WAAA,CAAcxM,OAAA,GAA6B;AAJ7C,IAAM+M,UAAA,GAANP,WAAA;AAiIA,IAAAQ,YAAA,GAAeD,UAAA;ECjJTE,UAAA,0BAAAC,aAAA;IA8BJ,SAAAD,WAAYxO,MAAA,EAAcY,OAAA,EAAe;MAAA,IAAA8N,OAAA;MAAAhR,eAAA,OAAA8Q,UAAA;MACvCE,OAAA,GAAApP,UAAA,OAAAkP,UAAA,GAAMxO,MAAA,EAAQY,OAAO,IACrB8N,OAAA,CAAK5P,UAAA,GAAa,IAAIgG,iBAAA,CAAgB4J,OAAA,CAAK9N,OAAO;MAAA,OAAA8N,OAAA;IACpD;IAAAlP,SAAA,CAAAgP,UAAA,EAAAC,aAAA;IAAA,OAAA3Q,YAAA,CAAA0Q,UAAA;MAAAzQ,GAAA;MAAAC,KAAA,EAEO,SAAAwG,OAAOvF,IAAA,EAAcjB,KAAA,EAAkB;QAC5C,IAAMwG,MAAA,GAAS,KAAKxE,MAAA,CAAOG,KAAA,CAAMlB,IAAA,EAAM3C,KAAA,CAAMO,KAAK;QAC9C2H,MAAA,IAAU,SAEHA,MAAA,YAAkBrH,UAAA,GACtB,KAAA2B,UAAA,CAAWkF,SAAA,CAAUQ,MAAA,EAAQxG,KAAK,IAC9BiB,IAAA,KAAS,KAAK4G,OAAA,CAAQ7D,QAAA,IAAY,CAAChE,KAAA,GACvC,KAAAwI,WAAA,CAAYgI,UAAA,CAAUxM,QAAQ,IAEnChE,KAAA,KACCiB,IAAA,KAAS,KAAK4G,OAAA,CAAQ7D,QAAA,IAAY,KAAKmM,OAAA,CAAQ,EAAElP,IAAI,MAAMjB,KAAA,KAEvD,KAAAwI,WAAA,CAAYvH,IAAA,EAAMjB,KAAK;MAEhC;IAAA;MAAAD,GAAA;MAAAC,KAAA,EAEO,SAAAmQ,QAAA,EAAoC;QACnC,IAAAA,OAAA,GAAU,KAAKrP,UAAA,CAAW6F,MAAA,CAAO;UACjCH,MAAA,GAAS,KAAKqB,OAAA,CAAQsI,OAAA,CAAQ,KAAKvN,OAAA,EAAS,KAAKZ,MAAM;QAC7D,OAAIwE,MAAA,IAAU,SACJ2J,OAAA,MAAKtI,OAAA,CAAQ7D,QAAQ,IAAIwC,MAAA,GAE5B2J,OAAA;MACT;IAAA;MAAApQ,GAAA;MAAAC,KAAA,EAEO,SAAA2H,SACLF,KAAA,EACAjI,MAAA,EACAyB,IAAA,EACAjB,KAAA,EACM;QACF,KAAKgC,MAAA,CAAOG,KAAA,CAAMlB,IAAA,EAAM3C,KAAA,CAAMO,KAAK,KAAK,OACrC,KAAA2H,MAAA,CAAOvF,IAAA,EAAMjB,KAAK,IAAAuM,aAAA,CAAAiE,UAAA,wBAER/I,KAAA,EAAOjI,MAAA,EAAQyB,IAAA,EAAMjB,KAAK;MAE7C;IAAA;MAAAD,GAAA;MAAAC,KAAA,EAEO,SAAA8H,SAASL,KAAA,EAAezH,KAAA,EAAe+H,GAAA,EAAiB;QACzD,IAAAA,GAAA,IAAO,QAAQ,KAAK/F,MAAA,CAAOG,KAAA,CAAMnC,KAAA,EAAO1B,KAAA,CAAMM,MAAM,KAAK,MAErD2N,aAAA,CAAAiE,UAAA,wBAAS/I,KAAA,EAAOzH,KAAA,EAAO+H,GAAG,QAC3B;UACC,IAAA6G,KAAA,GAAQ,KAAKvL,KAAA,CAAMoE,KAAK;UAC9B,IAAImH,KAAA,IAAS,MAAM;YACjB,IAAMnM,IAAA,GAAO,KAAKT,MAAA,CAAOD,MAAA,CAAO/B,KAAA,EAAO+H,GAAG;YACpC6G,KAAA,CAAAtH,MAAA,CAAOW,YAAA,CAAaxF,IAAA,EAAMmM,KAAK;UAAA,OAE/B,UAAIlN,KAAA,CAAM,4CAA4C;QAEhE;MACF;IAAA;MAAA3B,GAAA;MAAAC,KAAA,EAEO,SAAAwI,YAAYvH,IAAA,EAAqBjB,KAAA,EAAmB;QACzD,IAAMyI,WAAA,GAAA8D,aAAA,CAAAiE,UAAA,2BAAgCvP,IAAA,EAAMjB,KAAK;QAC5C,YAAAc,UAAA,CAAWsF,IAAA,CAAKqC,WAAW,GACzBA,WAAA;MACT;IAAA;MAAA1I,GAAA;MAAAC,KAAA,EAEO,SAAA2I,OACLmG,SAAA,EACAR,OAAA,EACM;QAAA,IAAAqC,OAAA;QACApE,aAAA,CAAAiE,UAAA,sBAAO1B,SAAA,EAAWR,OAAO,IACNQ,SAAA,CAAUxL,IAAA,CACjC,UAAC4L,QAAA;UAAA,OACCA,QAAA,CAAS7I,MAAA,KAAWsK,OAAA,CAAK/N,OAAA,IAAWsM,QAAA,CAASC,IAAA,KAAS;QAAA,MAGxD,KAAKrO,UAAA,CAAWiF,KAAA;MAEpB;IAAA;MAAAhG,GAAA;MAAAC,KAAA,EAhGA,SAAO+B,OAAO/B,KAAA,EAAiB;QACtB,OAAAuM,aAAA,CAAAiE,UAAA,sBAAaxQ,KAAK;MAC3B;IAAA;MAAAD,GAAA;MAAAC,KAAA,EAEA,SAAcmQ,QAAQvN,OAAA,EAAsBZ,MAAA,EAAmB;QAC7D,IAAME,MAAA,GAAQF,MAAA,CAAOG,KAAA,CAAMqO,UAAA,CAAUxM,QAAQ;QAC7C,IACE,EAAA9B,MAAA,IAAS,QACTU,OAAA,CAAQW,OAAA,KAAarB,MAAA,CAA0BqB,OAAA,GAGtC;UAAA,WAAO,KAAKA,OAAA,IAAY,UAC1B;UACE,IAAA3C,KAAA,CAAMsD,OAAA,CAAQ,KAAKX,OAAO,GAC5B,OAAAX,OAAA,CAAQW,OAAA,CAAQ8M,WAAA;;MAE3B;IAAA;EAAA,EA1BsBX,YAAA,CA2GxB;AA1GEc,UAAA,CAAcxM,QAAA,GAAW,SACzBwM,UAAA,CAAc5Q,KAAA,GAAQtB,KAAA,CAAMQ,UAAA,EAC5B0R,UAAA,CAAcjN,OAAA,GAA6B,KAC3CiN,UAAA,CAAc7C,eAAA,GAAqC,CACjD4C,YAAA,EACAC,UAAA,EACAvG,UAAA;AAPJ,IAAM2G,SAAA,GAANJ,UAAA;AA6GA,IAAAK,WAAA,GAAeD,SAAA;ECtHTE,cAAA,0BAAAC,aAAA;IAAA,SAAAD,eAAA;MAAApR,eAAA,OAAAoR,cAAA;MAAA,OAAAxP,UAAA,OAAAwP,cAAA,EAAAvR,SAAA;IAAA;IAAAiC,SAAA,CAAAsP,cAAA,EAAAC,aAAA;IAAA,OAAAjR,YAAA,CAAAgR,cAAA;MAAA/Q,GAAA;MAAAC,KAAA,EAQG,SAAAgR,WAAA,EAAsB;QAEzB,YAAK/J,IAAA,KAAS,QAAQ,KAAKA,IAAA,CAAKY,OAAA,CAAQ7D,QAAA,KAAa,KAAK6D,OAAA,CAAQ7D,QAAA;MAEtE;IAAA;MAAAjE,GAAA;MAAAC,KAAA,EAEO,SAAAwH,SAASC,KAAA,EAAejI,MAAA,EAAsB;QAC7C+M,aAAA,CAAAuE,cAAA,wBAASrJ,KAAA,EAAOjI,MAAM,IAC5B,KAAKgO,sBAAA,CAAuB;MAC9B;IAAA;MAAAzN,GAAA;MAAAC,KAAA,EAEO,SAAA2H,SACLF,KAAA,EACAjI,MAAA,EACAyB,IAAA,EACAjB,KAAA,EACM;QACNuM,aAAA,CAAAuE,cAAA,wBAAerJ,KAAA,EAAOjI,MAAA,EAAQyB,IAAA,EAAMjB,KAAK,IACzC,KAAKwN,sBAAA,CAAuB;MAC9B;IAAA;MAAAzN,GAAA;MAAAC,KAAA,EAEO,SAAA8H,SAASL,KAAA,EAAezH,KAAA,EAAe+H,GAAA,EAAiB;QACvDwE,aAAA,CAAAuE,cAAA,wBAASrJ,KAAA,EAAOzH,KAAA,EAAO+H,GAAG,IAChC,KAAKyF,sBAAA,CAAuB;MAC9B;IAAA;MAAAzN,GAAA;MAAAC,KAAA,EAEO,SAAAqI,SAASiG,OAAA,EAAuC;QACrD/B,aAAA,CAAAuE,cAAA,wBAAexC,OAAO,IAClB,KAAKlG,QAAA,CAAS5I,MAAA,GAAS,KAAK,KAAKyH,IAAA,IAAQ,QAAQ,KAAK+J,UAAA,OACnD,KAAA/J,IAAA,CAAKmH,YAAA,CAAa,IAAI,GAC3B,KAAKnH,IAAA,CAAKzG,MAAA;MAEd;IAAA;EAAA,EAxC0BkP,YAAA,CAyC5B;AAxCEoB,cAAA,CAAc9M,QAAA,GAAW,aACzB8M,cAAA,CAAclR,KAAA,GAAQtB,KAAA,CAAMQ,UAAA;AAF9B,IAAMmS,aAAA,GAANH,cAAA;AA2CA,IAAAI,eAAA,GAAeD,aAAA;AAAA,IC5CTE,SAAA,0BAAAC,UAAA;EAAA,SAAAD,UAAA;IAAAzR,eAAA,OAAAyR,SAAA;IAAA,OAAA7P,UAAA,OAAA6P,SAAA,EAAA5R,SAAA;EAAA;EAAAiC,SAAA,CAAA2P,SAAA,EAAAC,UAAA;EAAA,OAAAtR,YAAA,CAAAqR,SAAA;IAAApR,GAAA;IAAAC,KAAA,EAKG,SAAAwG,OAAOvF,IAAA,EAAcjB,KAAA,EAAkB;MAI5CuM,aAAA,CAAA4E,SAAA,wBAAe,GAAG,KAAK3R,MAAA,IAAUyB,IAAA,EAAMjB,KAAK;IAC9C;EAAA;IAAAD,GAAA;IAAAC,KAAA,EAEO,SAAA2H,SACLF,KAAA,EACAjI,MAAA,EACAyB,IAAA,EACAjB,KAAA,EACM;MACFyH,KAAA,KAAU,KAAKjI,MAAA,KAAW,KAAKA,MAAA,KAC5B,KAAAgH,MAAA,CAAOvF,IAAA,EAAMjB,KAAK,IAAAuM,aAAA,CAAA4E,SAAA,wBAER1J,KAAA,EAAOjI,MAAA,EAAQyB,IAAA,EAAMjB,KAAK;IAE7C;EAAA;IAAAD,GAAA;IAAAC,KAAA,EAEO,SAAAmQ,QAAA,EAAoC;MACzC,OAAO,KAAKtI,OAAA,CAAQsI,OAAA,CAAQ,KAAKvN,OAAA,EAAS,KAAKZ,MAAM;IACvD;EAAA;IAAAjC,GAAA;IAAAC,KAAA,EA1BA,SAAcmQ,QAAQpG,QAAA,EAAuBsH,OAAA,EAAoB,CAEjE;EAAA;AAAA,EAHsBpH,UAAA;AA8BxB,IAAAqH,WAAA,GAAeH,SAAA;EC1BTI,eAAA,GAAkB;IACtBzQ,UAAA,EAAY;IACZ0Q,aAAA,EAAe;IACfC,qBAAA,EAAuB;IACvBC,SAAA,EAAW;IACXC,OAAA,EAAS;EACX;EAEMC,uBAAA,GAA0B;EAE1BC,WAAA,0BAAAC,aAAA;IASJ,SAAAD,YACSE,QAAA,EACP7R,IAAA,EACA;MAAA,IAAA8R,OAAA;MAAAtS,eAAA,OAAAmS,WAAA;MAEAG,OAAA,GAAA1Q,UAAA,OAAAuQ,WAAA,GAAM,MAAM3R,IAAI,IAJT8R,OAAA,CAAAD,QAAA,GAAAA,QAAA,EAKPC,OAAA,CAAKhQ,MAAA,GAAAiQ,sBAAA,CAAAD,OAAA,CAAS,EACdA,OAAA,CAAKjM,KAAA,CAAM,GACXiM,OAAA,CAAKE,QAAA,GAAW,IAAIC,gBAAA,CAAiB,UAACrD,SAAA,EAAgC;QACpEkD,OAAA,CAAKrJ,MAAA,CAAOmG,SAAS;MAAA,CACtB,GACDkD,OAAA,CAAKE,QAAA,CAASE,OAAA,CAAQJ,OAAA,CAAKpP,OAAA,EAAS2O,eAAe,GACnDS,OAAA,CAAK9K,MAAA,CAAO;MAAA,OAAA8K,OAAA;IACd;IAAAxQ,SAAA,CAAAqQ,WAAA,EAAAC,aAAA;IAAA,OAAAhS,YAAA,CAAA+R,WAAA;MAAA9R,GAAA;MAAAC,KAAA,EAEO,SAAA+B,OAAOE,KAAA,EAA8BjC,KAAA,EAAmB;QAC7D,OAAO,KAAK+R,QAAA,CAAShQ,MAAA,CAAO,MAAME,KAAA,EAAOjC,KAAK;MAChD;IAAA;MAAAD,GAAA;MAAAC,KAAA,EAEO,SAAA6C,KAAK3C,IAAA,EAAgD;QAAA,IAA7B4C,MAAA,GAAAvD,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAS;QACtC,IAAMkD,IAAA,GAAO,KAAKsP,QAAA,CAASlP,IAAA,CAAK3C,IAAA,EAAM4C,MAAM;QAC5C,OAAKL,IAAA,GAGDA,IAAA,CAAKT,MAAA,KAAW,OACXS,IAAA,GAEFK,MAAA,GAAS,KAAKD,IAAA,CAAKJ,IAAA,CAAKT,MAAA,CAAOY,OAAA,CAAQ4B,UAAA,EAAY,EAAI,IAAI,OALzD;MAMX;IAAA;MAAAzE,GAAA;MAAAC,KAAA,EAEO,SAAAmC,MACLA,OAAA,EAE2B;QAAA,IAD3BvC,KAAA,GAAAL,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAejB,KAAA,CAAMY,GAAA;QAErB,OAAO,KAAK6S,QAAA,CAAS5P,KAAA,CAAMA,OAAA,EAAOvC,KAAK;MACzC;IAAA;MAAAG,GAAA;MAAAC,KAAA,EAEO,SAAAwD,SAAA,EAA+C;QAAA,IAAA6O,cAAA;QACpD,OAAO,CAAAA,cAAA,QAAKN,QAAA,EAASvO,QAAA,CAAAiH,KAAA,CAAA4H,cAAA,EAAA9S,SAAuB;MAC9C;IAAA;MAAAQ,GAAA;MAAAC,KAAA,EAEO,SAAA+F,MAAA,EAAc;QACf,KAAK/D,MAAA,IAAU,QAAAuK,aAAA,CAAAsF,WAAA,uBAGP;MACd;IAAA;MAAA9R,GAAA;MAAAC,KAAA,EAEO,SAAAqH,OAAA,EAAe;QACpBkF,aAAA,CAAAsF,WAAA,0BACA,KAAKK,QAAA,CAASI,UAAA;MAChB;IAAA;MAAAvS,GAAA;MAAAC,KAAA,EAEO,SAAAwH,SAASC,KAAA,EAAejI,MAAA,EAAsB;QACnD,KAAKmJ,MAAA,CAAO,GACRlB,KAAA,KAAU,KAAKjI,MAAA,KAAW,KAAKA,MAAA,KAC5B,KAAA4I,QAAA,CAAShE,OAAA,CAAQ,UAAC4H,KAAA,EAAU;UAC/BA,KAAA,CAAMxL,MAAA,CAAO;QAAA,CACd,IAAA+L,aAAA,CAAAsF,WAAA,wBAEcpK,KAAA,EAAOjI,MAAM;MAEhC;IAAA;MAAAO,GAAA;MAAAC,KAAA,EAEO,SAAA2H,SACLF,KAAA,EACAjI,MAAA,EACAyB,IAAA,EACAjB,KAAA,EACM;QACN,KAAK2I,MAAA,CAAO,GAAA4D,aAAA,CAAAsF,WAAA,wBACGpK,KAAA,EAAOjI,MAAA,EAAQyB,IAAA,EAAMjB,KAAK;MAC3C;IAAA;MAAAD,GAAA;MAAAC,KAAA,EAEO,SAAA8H,SAASL,KAAA,EAAezH,KAAA,EAAe+H,GAAA,EAAiB;QAC7D,KAAKY,MAAA,CAAO,GAAA4D,aAAA,CAAAsF,WAAA,wBACGpK,KAAA,EAAOzH,KAAA,EAAO+H,GAAG;MAClC;IAAA;MAAAhI,GAAA;MAAAC,KAAA,EAOO,SAAAqI,UAAA,EAAuD;QAAA,IAAAkK,OAAA;QAAA,IAA9CzD,SAAA,GAAAvP,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAiB;QAAA,IAAI+O,OAAA,GAAA/O,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAe;QAClDgN,aAAA,CAAAsF,WAAA,wBAAevD,OAAO;QACtB,IAAMkE,YAAA,GAAelE,OAAA,CAAQkE,YAAA,IAAgB,mBAAI9N,OAAA,CAAQ;QAEzD,IAAI+N,OAAA,GAAU7R,KAAA,CAAMC,IAAA,CAAK,KAAKqR,QAAA,CAASQ,WAAA,EAAa;QAG7C,OAAAD,OAAA,CAAQjT,MAAA,GAAS,IACZsP,SAAA,CAAAlD,IAAA,CAAK6G,OAAA,CAAQE,GAAA,CAAK;QAE9B,IAAMC,KAAA,GAAO,SAAPA,KAAQnQ,IAAA,EAA+C;YAAA,IAA5BoQ,UAAA,GAAAtT,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAa;YACxCkD,IAAA,IAAQ,QAAQA,IAAA,KAAS8P,OAAA,IAGzB9P,IAAA,CAAKG,OAAA,CAAQ4B,UAAA,IAAc,SAG1BgO,YAAA,CAAalO,GAAA,CAAI7B,IAAA,CAAKG,OAAO,KAChC4P,YAAA,CAAa7P,GAAA,CAAIF,IAAA,CAAKG,OAAA,EAAS,EAAE,GAE/BiQ,UAAA,IACFD,KAAA,CAAKnQ,IAAA,CAAK6E,MAAM;UAClB;UAEIe,SAAA,GAAW,SAAXA,SAAY5F,IAAA,EAAqB;YAEhC+P,YAAA,CAAalO,GAAA,CAAI7B,IAAA,CAAKG,OAAO,MAG9BH,IAAA,YAAgBiN,YAAA,IACbjN,IAAA,CAAA2F,QAAA,CAAShE,OAAA,CAAQiE,SAAQ,GAEnBmK,YAAA,WAAO/P,IAAA,CAAKG,OAAO,GAChCH,IAAA,CAAK4F,QAAA,CAASiG,OAAO;UAAA;QAEvB,IAAIwE,SAAA,GAAYhE,SAAA;QAChB,SAASiE,CAAA,GAAI,GAAGD,SAAA,CAAUtT,MAAA,GAAS,GAAGuT,CAAA,IAAK,GAAG;UAC5C,IAAIA,CAAA,IAAKnB,uBAAA,EACD,UAAIlQ,KAAA,CAAM,iDAAiD;UA4B5D,KA1BGoR,SAAA,CAAA1O,OAAA,CAAQ,UAAC8K,QAAA,EAA6B;YAC9C,IAAMzM,IAAA,GAAO8P,OAAA,CAAK1P,IAAA,CAAKqM,QAAA,CAAS7I,MAAA,EAAQ,EAAI;YACxC5D,IAAA,IAAQ,SAGRA,IAAA,CAAKG,OAAA,KAAYsM,QAAA,CAAS7I,MAAA,KACxB6I,QAAA,CAASC,IAAA,KAAS,eACpByD,KAAA,CAAKL,OAAA,CAAK1P,IAAA,CAAKqM,QAAA,CAAS8D,eAAA,EAAiB,EAAK,CAAC,GAC/CpS,KAAA,CAAMC,IAAA,CAAKqO,QAAA,CAASF,UAAU,EAAE5K,OAAA,CAAQ,UAAClE,IAAA,EAAe;cACtD,IAAM8L,KAAA,GAAQuG,OAAA,CAAK1P,IAAA,CAAK3C,IAAA,EAAM,EAAK;cACnC0S,KAAA,CAAK5G,KAAA,EAAO,EAAK,GACbA,KAAA,YAAiB0D,YAAA,IACb1D,KAAA,CAAA5D,QAAA,CAAShE,OAAA,CAAQ,UAAC6O,UAAA,EAAqB;gBAC3CL,KAAA,CAAKK,UAAA,EAAY,EAAK;cAAA,CACvB;YACH,CACD,KACQ/D,QAAA,CAASC,IAAA,KAAS,gBAC3ByD,KAAA,CAAKnQ,IAAA,CAAKuE,IAAI,IAGlB4L,KAAA,CAAKnQ,IAAI;UAAA,CACV,GACI,KAAA2F,QAAA,CAAShE,OAAA,CAAQiE,SAAQ,GAC9ByK,SAAA,GAAYlS,KAAA,CAAMC,IAAA,CAAK,KAAKqR,QAAA,CAASQ,WAAA,EAAa,GAClDD,OAAA,GAAUK,SAAA,CAAU5N,KAAA,IACbuN,OAAA,CAAQjT,MAAA,GAAS,IACZsP,SAAA,CAAAlD,IAAA,CAAK6G,OAAA,CAAQE,GAAA,CAAK;QAEhC;MACF;IAAA;MAAA5S,GAAA;MAAAC,KAAA,EAEO,SAAA2I,OACLmG,SAAA,EAEM;QAAA,IAAAoE,OAAA;QAAA,IADN5E,OAAA,GAAA/O,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAkC;QAEtBuP,SAAA,GAAAA,SAAA,IAAa,KAAKoD,QAAA,CAASQ,WAAA,CAAY;QAC7C,IAAAF,YAAA,sBAAmB9N,OAAA;QAEtBoK,SAAA,CAAA/N,GAAA,CAAI,UAACmO,QAAA,EAA6B;UACjC,IAAMzM,IAAA,GAAOyQ,OAAA,CAAKrQ,IAAA,CAAKqM,QAAA,CAAS7I,MAAA,EAAQ,EAAI;UAC5C,OAAI5D,IAAA,IAAQ,OACH,OAEL+P,YAAA,CAAalO,GAAA,CAAI7B,IAAA,CAAKG,OAAO,KAC/B4P,YAAA,CAAajO,GAAA,CAAI9B,IAAA,CAAKG,OAAO,EAAEgJ,IAAA,CAAKsD,QAAQ,GACrC,SAEPsD,YAAA,CAAa7P,GAAA,CAAIF,IAAA,CAAKG,OAAA,EAAS,CAACsM,QAAQ,CAAC,GAClCzM,IAAA;QACT,CACD,EACA2B,OAAA,CAAQ,UAAC3B,IAAA,EAAsB;UAC1BA,IAAA,IAAQ,QAAQA,IAAA,KAASyQ,OAAA,IAAQV,YAAA,CAAalO,GAAA,CAAI7B,IAAA,CAAKG,OAAO,KAC3DH,IAAA,CAAAkG,MAAA,CAAO6J,YAAA,CAAajO,GAAA,CAAI9B,IAAA,CAAKG,OAAO,KAAK,IAAI0L,OAAO;QAC3D,CACD,GACHA,OAAA,CAAQkE,YAAA,GAAeA,YAAA,EACnBA,YAAA,CAAalO,GAAA,CAAI,KAAK1B,OAAO,KAAA2J,aAAA,CAAAsF,WAAA,sBAClBW,YAAA,CAAajO,GAAA,CAAI,KAAK3B,OAAO,GAAG0L,OAAO,IAEjD,KAAAjG,QAAA,CAASyG,SAAA,EAAWR,OAAO;MAClC;IAAA;EAAA,EAnMuBoB,YAAA,CAoMzB;AAnMEmC,WAAA,CAAc7N,QAAA,GAAW,UACzB6N,WAAA,CAActD,YAAA,GAAesC,WAAA,EACfgB,WAAA,CAAAlE,eAAA,GAAqC,CAACkD,WAAA,EAAWK,eAAa,GAC5EW,WAAA,CAAcjS,KAAA,GAAQtB,KAAA,CAAMQ,UAAA,EAC5B+S,WAAA,CAActO,OAAA,GAAU;AAL1B,IAAM4P,UAAA,GAANtB,WAAA;AAsMA,IAAAuB,YAAA,GAAeD,UAAA;ECnNTE,SAAA,0BAAAC,WAAA;IAeJ,SAAAD,UAAYrR,MAAA,EAAc9B,IAAA,EAAY;MAAA,IAAAqT,OAAA;MAAA7T,eAAA,OAAA2T,SAAA;MACpCE,OAAA,GAAAjS,UAAA,OAAA+R,SAAA,GAAMrR,MAAA,EAAQ9B,IAAI,IAClBqT,OAAA,CAAKtQ,IAAA,GAAOsQ,OAAA,CAAK1L,OAAA,CAAQ7H,KAAA,CAAMuT,OAAA,CAAK3Q,OAAO;MAAA,OAAA2Q,OAAA;IAC7C;IAAA/R,SAAA,CAAA6R,SAAA,EAAAC,WAAA;IAAA,OAAAxT,YAAA,CAAAuT,SAAA;MAAAtT,GAAA;MAAAC,KAAA,EAEO,SAAAwH,SAASC,KAAA,EAAejI,MAAA,EAAsB;QACnD,KAAKoD,OAAA,CAAQ4Q,IAAA,GAAO,KAAKvQ,IAAA,GACvB,KAAKA,IAAA,CAAKiC,KAAA,CAAM,GAAGuC,KAAK,IAAI,KAAKxE,IAAA,CAAKiC,KAAA,CAAMuC,KAAA,GAAQjI,MAAM;MAC9D;IAAA;MAAAO,GAAA;MAAAC,KAAA,EAEO,SAAAyH,MAAMvH,IAAA,EAAYgI,MAAA,EAAwB;QAC3C,YAAKtF,OAAA,KAAY1C,IAAA,GACZgI,MAAA,GAEF;MACT;IAAA;MAAAnI,GAAA;MAAAC,KAAA,EAEO,SAAA8H,SAASL,KAAA,EAAezH,KAAA,EAAe+H,GAAA,EAAiB;QACzDA,GAAA,IAAO,QACJ,KAAA9E,IAAA,GAAO,KAAKA,IAAA,CAAKiC,KAAA,CAAM,GAAGuC,KAAK,IAAIzH,KAAA,GAAQ,KAAKiD,IAAA,CAAKiC,KAAA,CAAMuC,KAAK,GAChE,KAAA7E,OAAA,CAAQ4Q,IAAA,GAAO,KAAKvQ,IAAA,IAAAsJ,aAAA,CAAA8G,SAAA,wBAEV5L,KAAA,EAAOzH,KAAA,EAAO+H,GAAG;MAEpC;IAAA;MAAAhI,GAAA;MAAAC,KAAA,EAEO,SAAAR,OAAA,EAAiB;QACtB,OAAO,KAAKyD,IAAA,CAAKzD,MAAA;MACnB;IAAA;MAAAO,GAAA;MAAAC,KAAA,EAEO,SAAAqI,SAASiG,OAAA,EAAuC;QACrD/B,aAAA,CAAA8G,SAAA,wBAAe/E,OAAO,IACtB,KAAKrL,IAAA,GAAO,KAAK4E,OAAA,CAAQ7H,KAAA,CAAM,KAAK4C,OAAO,GACvC,KAAKK,IAAA,CAAKzD,MAAA,KAAW,IACvB,KAAKgB,MAAA,CAAO,IACH,KAAKyG,IAAA,YAAgBoM,SAAA,IAAY,KAAKpM,IAAA,CAAKD,IAAA,KAAS,SAC7D,KAAKc,QAAA,CAAS,KAAKtI,MAAA,IAAW,KAAKyH,IAAA,CAAkBjH,KAAA,EAAO,GAC5D,KAAKiH,IAAA,CAAKzG,MAAA;MAEd;IAAA;MAAAT,GAAA;MAAAC,KAAA,EAEO,SAAA2J,SAASlC,KAAA,EAAmD;QAAA,IAApCmC,UAAA,GAAArK,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAa;QACnC,QAAC,KAAKqD,OAAA,EAAS6E,KAAK;MAC7B;IAAA;MAAA1H,GAAA;MAAAC,KAAA,EAEO,SAAAqD,MAAMoE,KAAA,EAA2C;QAAA,IAA5BkH,KAAA,GAAApP,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAQ;QAClC,IAAI,CAACoP,KAAA,EAAO;UACV,IAAIlH,KAAA,KAAU,GACL;UAEL,IAAAA,KAAA,KAAU,KAAKjI,MAAA,IACjB,OAAO,KAAKyH,IAAA;QAEhB;QACM,IAAA2H,KAAA,GAAQ,KAAK5M,MAAA,CAAOD,MAAA,CAAO,KAAKa,OAAA,CAAQ6Q,SAAA,CAAUhM,KAAK,CAAC;QAC9D,YAAKH,MAAA,CAAOW,YAAA,CAAa2G,KAAA,EAAO,KAAK3H,IAAA,IAAQ,MAAS,GACtD,KAAKhE,IAAA,GAAO,KAAK4E,OAAA,CAAQ7H,KAAA,CAAM,KAAK4C,OAAO,GACpCgM,KAAA;MACT;IAAA;MAAA7O,GAAA;MAAAC,KAAA,EAEO,SAAA2I,OACLmG,SAAA,EACAxG,QAAA,EACM;QAAA,IAAAoL,OAAA;QAEJ5E,SAAA,CAAUxL,IAAA,CAAK,UAAC4L,QAAA;UAAA,OAEZA,QAAA,CAASC,IAAA,KAAS,mBAAmBD,QAAA,CAAS7I,MAAA,KAAWqN,OAAA,CAAK9Q,OAEjE;QAAA,OAED,KAAKK,IAAA,GAAO,KAAK4E,OAAA,CAAQ7H,KAAA,CAAM,KAAK4C,OAAO;MAE/C;IAAA;MAAA7C,GAAA;MAAAC,KAAA,EAEO,SAAAA,MAAA,EAAgB;QACrB,OAAO,KAAKiD,IAAA;MACd;IAAA;MAAAlD,GAAA;MAAAC,KAAA,EAxFA,SAAc+B,OAAO/B,KAAA,EAAqB;QACjC,OAAAkJ,QAAA,CAASyK,cAAA,CAAe3T,KAAK;MACtC;IAAA;MAAAD,GAAA;MAAAC,KAAA,EAEA,SAAcA,MAAM4C,OAAA,EAAuB;QACzC,OAAOA,OAAA,CAAQ4Q,IAAA;MACjB;IAAA;EAAA,EAVqBvJ,UAAA,CA6FvB;AA5FEoJ,SAAA,CAAuBrP,QAAA,GAAW,QAClCqP,SAAA,CAAczT,KAAA,GAAQtB,KAAA,CAAMS,WAAA;AAF9B,IAAM6U,QAAA,GAANP,SAAA;AA+FA,IAAAQ,UAAA,GAAeD,QAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}